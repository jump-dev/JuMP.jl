var documenterSearchIndex = {"docs":
[{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/robust_uncertainty.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/#Robust-uncertainty-sets","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"Computes the Value at Risk for a data-driven uncertainty set; see \"Data-Driven Robust Optimization\" (Bertsimas 2013), section 6.1 for details. Closed-form expressions for the optimal value are available.","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Test\n\nfunction example_robust_uncertainty()\n    R = 1\n    d = 3\n    ùõø = 0.05\n    …õ = 0.05\n    N = ceil((2 + 2 * log(2 / ùõø))^2) + 1\n    c = randn(d)\n    Œºhat = rand(d)\n    M = rand(d, d)\n    Œ£hat = 1 / (d - 1) * (M - ones(d) * Œºhat')' * (M - ones(d) * Œºhat')\n    Œì1(ùõø, N) = R / sqrt(N) * (2 + sqrt(2 * log(1 / ùõø)))\n    Œì2(ùõø, N) = 2 * R^2 / sqrt(N) * (2 + sqrt(2 * log(2 / ùõø)))\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, Œ£[1:d, 1:d], PSD)\n    @variable(model, u[1:d])\n    @variable(model, Œº[1:d])\n    @constraint(model, [Œì1(ùõø / 2, N); Œº - Œºhat] in SecondOrderCone())\n    @constraint(model, [Œì2(ùõø / 2, N); vec(Œ£ - Œ£hat)] in SecondOrderCone())\n    @SDconstraint(model, [((1 - …õ) / …õ) (u - Œº)'; (u - Œº) Œ£] >= 0)\n    @objective(model, Max, LinearAlgebra.dot(c, u))\n    optimize!(model)\n    I = Matrix(1.0 * LinearAlgebra.I, d, d)\n    exact =\n        LinearAlgebra.dot(Œºhat, c) +\n        Œì1(ùõø / 2, N) * LinearAlgebra.norm(c) +\n        sqrt((1 - …õ) / …õ) * sqrt(LinearAlgebra.dot(c, (Œ£hat + Œì2(ùõø / 2, N) * I) * c))\n    Test.@test objective_value(model) ‚âà exact atol = 1e-3\n    return\nend\n\nexample_robust_uncertainty()","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/robust_uncertainty/","page":"Robust uncertainty sets","title":"Robust uncertainty sets","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/solvers_and_solutions.jl\"","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Solvers-and-Solutions","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"The purpose of this part of the tutorial is to introduce you to solvers and how to use them with JuMP. We'll also learn what to do with a problem after the solver has finished optimizing it.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#What-is-a-Solver?","page":"Solvers and Solutions","title":"What is a Solver?","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"A solver is a software package that incorporates algorithms for finding solutions to one or more classes of problem. For example, GLPK, which we used in the previous tutorials is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method, interior-point method etc. JuMP currently supports a number of open-source and commercial solvers which can be viewed in the Supported-solvers table.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#What-is-MathOptInterface?","page":"Solvers and Solutions","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Each mathematical optimization solver API has its own concepts and data structures for representing optimization models and obtaining results. However, it is often desirable to represent an instance of an optimization problem at a higher level so that it is easy to try using different solvers.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Note that JuMP re-exports MathOptInterface and you can use the shortcut MOI to refer to MathOptInterface in your code.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Constructing-a-model","page":"Solvers and Solutions","title":"Constructing a model","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"JuMP models can be created in three different modes: AUTOMATIC, MANUAL and DIRECT. We'll use the following LP to illustrate them.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"beginaligned\n max_xy  x + 2y \n textst  x + y leq 1 \n  0leq x y leq 1 \nendaligned","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"using JuMP\nusing GLPK","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#AUTOMATIC-Mode","page":"Solvers and Solutions","title":"AUTOMATIC Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/#With-Optimizer","page":"Solvers and Solutions","title":"With Optimizer","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This is the easiest method to use a solver in JuMP. In order to do so, we simply set the solver inside the Model constructor.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_auto = Model(GLPK.Optimizer)\n@variable(model_auto, 0 <= x <= 1)\n@variable(model_auto, 0 <= y <= 1)\n@constraint(model_auto, x + y <= 1)\n@objective(model_auto, Max, x + 2y)\noptimize!(model_auto)\nobjective_value(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#No-Optimizer-(at-first)","page":"Solvers and Solutions","title":"No Optimizer (at first)","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"It is also possible to create a JuMP model with no optimizer attached. After the model object is initialized empty and all its variables, constraints and objective are set, then we can attach the solver at optimize! time.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_auto_no = Model()\n@variable(model_auto_no, 0 <= x <= 1)\n@variable(model_auto_no, 0 <= y <= 1)\n@constraint(model_auto_no, x + y <= 1)\n@objective(model_auto_no, Max, x + 2y)\nset_optimizer(model_auto_no, GLPK.Optimizer)\noptimize!(model_auto_no)\nobjective_value(model_auto_no)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Note that we can also enforce the automatic mode by passing caching_mode = MOIU.AUTOMATIC in the Model function call.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#MANUAL-Mode","page":"Solvers and Solutions","title":"MANUAL Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This mode is similar to the AUTOMATIC mode, but there are less protections from the user getting errors from the solver API. On the other side, nothing happens silently, which might give the user more control. It requires attaching the solver before the solve step using the MOIU.attach_optimizer() function.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_manual = Model(GLPK.Optimizer, caching_mode = MOIU.MANUAL)\n@variable(model_manual, 0 <= x <= 1)\n@variable(model_manual, 0 <= y <= 1)\n@constraint(model_manual, x + y <= 1)\n@objective(model_manual, Max, x + 2y)\nMOIU.attach_optimizer(model_manual)\noptimize!(model_manual)\nobjective_value(model_manual)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#DIRECT-Mode","page":"Solvers and Solutions","title":"DIRECT Mode","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Some solvers are able to handle the problem data directly. This is common for LP/MIP solver but not very common for open-source conic solvers. In this case we do not set a optimizer, we set a backend which is more generic and is able to hold data and not only solving a model.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_direct = direct_model(GLPK.Optimizer())\n@variable(model_direct, 0 <= x <= 1)\n@variable(model_direct, 0 <= y <= 1)\n@constraint(model_direct, x + y <= 1)\n@objective(model_direct, Max, x + 2y)\noptimize!(model_direct)\nobjective_value(model_direct)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Solver-Options","page":"Solvers and Solutions","title":"Solver Options","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Many of the solvers also allow options to be passed in. However, these options are solver-specific. To find out the various options available, please check out the individual solver packages. Some examples for the GLPK solver are given below.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"using GLPK","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To turn off printing (i.e. silence the solver),","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To increase the maximum number of simplex iterations:","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"it_lim\" => 10_000));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"To set the solution timeout limit (in milliseconds):","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model = Model(optimizer_with_attributes(GLPK.Optimizer, \"tm_lim\" => 5_000));\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#How-to-querying-the-solution","page":"Solvers and Solutions","title":"How to querying the solution","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"So far we have seen all the elements and constructs related to writing a JuMP optimization model. In this section we reach the point of what to do with a solved problem. JuMP follows closely the concepts defined in MathOptInterface to answer user questions about a finished call to optimize!(model). The three main steps in querying a solution are given below. We'll use the model we created in AUTOMATIC mode with an optimizer attached in this section.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#The-termination-status","page":"Solvers and Solutions","title":"The termination status","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Termination statuses are meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"termination_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"You can view the different termination status codes by referring to the docs or though checking the possible types using the below command.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"display(typeof(MOI.OPTIMAL))","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#The-primal-and-dual-status","page":"Solvers and Solutions","title":"The primal and dual status","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"These statuses indicate what kind of result is available to be queried from the model. It's possible that no result is available to be queried. We shall discuss more on the dual status and solutions in the Duality tutorial.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"primal_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"dual_status(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"As we saw before, the result (solution) status codes can be viewed directly from Julia.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"display(typeof(MOI.FEASIBLE_POINT))","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/#Getting-the-primal-solution","page":"Solvers and Solutions","title":"Getting the primal solution","text":"","category":"section"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Provided the primal status is not MOI.NO_SOLUTION, we can inspect the solution values and optimal cost.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"value(x)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"value(y)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"objective_value(model_auto)","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"Since it is possible that no solution is available to be queried from the model, calls to value may throw errors. Hence, it is recommended to check for the presence of solutions.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"model_no_solution = Model(GLPK.Optimizer)\n@variable(model_no_solution, 0 <= x <= 1)\n@variable(model_no_solution, 0 <= y <= 1)\n@constraint(model_no_solution, x + y >= 3)\n@objective(model_no_solution, Max, x + 2y)\n\noptimize!(model_no_solution)\n\ntry #hide\nif termination_status(model_no_solution) == MOI.OPTIMAL\n    optimal_solution = value(x)\n    optimal_objective = objective_value(model_no_solution)\nelseif termination_status(model_no_solution) == MOI.TIME_LIMIT && has_values(model_no_solution)\n    suboptimal_solution = value(x)\n    suboptimal_objective = objective_value(model_no_solution)\nelse\n    error(\"The model was not solved correctly.\")\nend\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"","category":"page"},{"location":"tutorials/Getting started/solvers_and_solutions/","page":"Solvers and Solutions","title":"Solvers and Solutions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/transp.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/#The-transportation-problem","page":"The transportation problem","title":"The transportation problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Allocation of passenger cars to trains to minimize cars required or car-miles run. Based on:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Fourer, D.M. Gay and Brian W. Kernighan, A Modeling Language for Mathematical Programming, https://ampl.com/REFS/amplmod.ps.gz Appendix D.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"Originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_transp()\n\tORIG = [\"GARY\", \"CLEV\", \"PITT\"]\n\tDEST = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n\tsupply = [1_400, 2_600, 2_900]\n\tdemand = [900, 1_200, 600, 400, 1_700, 1_100, 1_000]\n\tTest.@test sum(supply) == sum(demand)\n\tcost = [\n\t\t39   14   11   14   16   82    8;\n\t\t27    9   12    9   26   95   17;\n\t\t24   14   17   13   28   99   20\n\t]\n\tmodel = Model(GLPK.Optimizer)\n\t@variable(model, trans[1:length(ORIG), 1:length(DEST)] >= 0)\n\t@objective(\n\t\tmodel,\n\t\tMin,\n\t\tsum(\n\t\t\tcost[i, j] * trans[i, j]\n\t\t\tfor i in 1:length(ORIG), j in 1:length(DEST)\n\t\t)\n\t)\n\t@constraints(model, begin\n\t\t[i in 1:length(ORIG)], sum(trans[i, :]) == supply[i]\n\t\t[j in 1:length(DEST)], sum(trans[:, j]) == demand[j]\n\tend)\n\toptimize!(model)\n\tTest.@test termination_status(model) == MOI.OPTIMAL\n\tTest.@test primal_status(model) == MOI.FEASIBLE_POINT\n\tTest.@test objective_value(model) == 196200.0\n\tprintln(\"The optimal solution is:\")\n\tprintln(value.(trans))\n\treturn\nend\n\nexample_transp()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/transp/","page":"The transportation problem","title":"The transportation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/containers/#ContainersAPI","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"More information can be found in the Containers section of the manual.","category":"page"},{"location":"reference/containers/","page":"Containers","title":"Containers","text":"Containers\nContainers.DenseAxisArray\nContainers.SparseAxisArray\nContainers.container\nContainers.default_container\nContainers.VectorizedProductIterator\nContainers.NestedIterator\nContainers.@container","category":"page"},{"location":"reference/containers/#JuMP.Containers","page":"Containers","title":"JuMP.Containers","text":"Containers\n\nModule defining the containers DenseAxisArray and SparseAxisArray that behaves as a regular AbstractArray but with custom indexes that are not necessarily integers.\n\n\n\n\n\n","category":"module"},{"location":"reference/containers/#JuMP.Containers.DenseAxisArray","page":"Containers","title":"JuMP.Containers.DenseAxisArray","text":"DenseAxisArray(data::Array{T, N}, axes...) where {T, N}\n\nConstruct a JuMP array with the underlying data specified by the data array and the given axes. Exactly N axes must be provided, and their lengths must match size(data) in the corresponding dimensions.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray([1 2; 3 4], [:a, :b], 2:3)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 2:3\nAnd data, a 2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> array[:b, 3]\n4\n\n\n\n\n\nDenseAxisArray{T}(undef, axes...) where T\n\nConstruct an uninitialized DenseAxisArray with element-type T indexed over the given axes.\n\nExample\n\njulia> array = JuMP.Containers.DenseAxisArray{Float64}(undef, [:a, :b], 1:2);\n\njulia> fill!(array, 1.0)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2√ó2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> array[:a, 2] = 5.0\n5.0\n\njulia> array[:a, 2]\n5.0\n\njulia> array\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\n    Dimension 2, 1:2\nAnd data, a 2√ó2 Array{Float64,2}:\n 1.0  5.0\n 1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.SparseAxisArray","page":"Containers","title":"JuMP.Containers.SparseAxisArray","text":"struct SparseAxisArray{T,N,K<:NTuple{N, Any}} <: AbstractArray{T,N}\n    data::Dict{K,T}\nend\n\nN-dimensional array with elements of type T where only a subset of the entries are defined. The entries with indices idx = (i1, i2, ..., iN) in keys(data) has value data[idx]. Note that as opposed to SparseArrays.AbstractSparseArray, the missing entries are not assumed to be zero(T), they are simply not part of the array. This means that the result of map(f, sa::SparseAxisArray) or f.(sa::SparseAxisArray) has the same sparsity structure than sa even if f(zero(T)) is not zero.\n\nExample\n\njulia> dict = Dict((:a, 2) => 1.0, (:a, 3) => 2.0, (:b, 3) => 3.0)\nDict{Tuple{Symbol,Int64},Float64} with 3 entries:\n  (:b, 3) => 3.0\n  (:a, 2) => 1.0\n  (:a, 3) => 2.0\n\njulia> array = JuMP.Containers.SparseAxisArray(dict)\nJuMP.Containers.SparseAxisArray{Float64,2,Tuple{Symbol,Int64}} with 3 entries:\n  [b, 3]  =  3.0\n  [a, 2]  =  1.0\n  [a, 3]  =  2.0\n\njulia> array[:b, 3]\n3.0\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.container","page":"Containers","title":"JuMP.Containers.container","text":"container(f::Function, indices, ::Type{C})\n\nCreate a container of type C with indices indices and values at given indices given by f.\n\ncontainer(f::Function, indices)\n\nCreate a container with indices indices and values at given indices given by f. The type of container used is determined by default_container.\n\nExamples\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(Base.OneTo(3), Base.OneTo(3)))\n3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(1:3, 1:3))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.vectorized_product(2:3, Base.OneTo(3)))\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2√ó3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.container((i, j) -> i + j, Containers.nested(() -> 1:3, i -> i:3, condition = (i, j) -> isodd(i) || isodd(j)))\nSparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 5 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.default_container","page":"Containers","title":"JuMP.Containers.default_container","text":"default_container(indices)\n\nIf indices is a NestedIterator, return a SparseAxisArray. Otherwise, indices should be a VectorizedProductIterator and the function returns Array if all iterators of the product are Base.OneTo and retunrs DenseAxisArray otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/containers/#JuMP.Containers.VectorizedProductIterator","page":"Containers","title":"JuMP.Containers.VectorizedProductIterator","text":"struct VectorizedProductIterator{T}\n    prod::Iterators.ProductIterator{T}\nend\n\nCartesian product of the iterators prod.iterators. It is the same iterator as Base.Iterators.ProductIterator except that it is independent of the IteratorSize of the elements of prod.iterators. For instance:\n\nsize(Iterators.product(1, 2)) is tuple() while size(VectorizedProductIterator(1, 2)) is (1, 1).\nsize(Iterators.product(ones(2, 3))) is (2, 3) while size(VectorizedProductIterator(ones(2, 3))) is (1, 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.NestedIterator","page":"Containers","title":"JuMP.Containers.NestedIterator","text":"struct NestedIterator{T}\n    iterators::T # Tuple of functions\n    condition::Function\nend\n\nIterators over the tuples that are produced by a nested for loop. For instance, if length(iterators) == 3 , this corresponds to the tuples (i1, i2, i3) produced by:\n\nfor i1 in iterators[1]()\n    for i2 in iterator[2](i1)\n        for i3 in iterator[3](i1, i2)\n            if condition(i1, i2, i3)\n                # produces (i1, i2, i3)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/containers/#JuMP.Containers.@container","page":"Containers","title":"JuMP.Containers.@container","text":"@container([i=..., j=..., ...], expr)\n\nCreate a container with indices i, j, ... and values given by expr that may depend on the value of the indices.\n\n@container(ref[i=..., j=..., ...], expr)\n\nSame as above but the container is assigned to the variable of name ref.\n\nThe type of container can be controlled by the container keyword. Note that when the index set is explicitly given as 1:n for any expression n, it is transformed to Base.OneTo(n) before being given to container.\n\nExamples\n\njulia> Containers.@container([i = 1:3, j = 1:3], i + j)\n3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> I = 1:3\n1:3\n\njulia> Containers.@container([i = I, j = I], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, 1:3\nAnd data, a 3√ó3 Array{Int64,2}:\n 2  3  4\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 2:3, j = 1:3], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, Base.OneTo(3)\nAnd data, a 2√ó3 Array{Int64,2}:\n 3  4  5\n 4  5  6\n\njulia> Containers.@container([i = 1:3, j = 1:3; i <= j], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [1, 2]  =  3\n  [2, 3]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [1, 3]  =  4\n\n\n\n\n\n","category":"macro"},{"location":"reference/extensions/#ExtensionAPI","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"More information can be found in the Extensions section of the manual.","category":"page"},{"location":"reference/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"AbstractVectorSet","category":"page"},{"location":"reference/extensions/#JuMP.AbstractVectorSet","page":"Extensions","title":"JuMP.AbstractVectorSet","text":"AbstractVectorSet\n\nAn abstract type for defining new sets in JuMP.\n\nImplement moi_set(::AbstractVectorSet, dim::Int) to convert the type into an MOI set.\n\nSee also: moi_set.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#Extend-@variable","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"ScalarVariable\nVariableInfo\nadd_variable\nbuild_variable","category":"page"},{"location":"reference/extensions/#JuMP.ScalarVariable","page":"Extensions","title":"JuMP.ScalarVariable","text":"ScalarVariable{S,T,U,V} <: AbstractVariable\n\nA struct used when adding variables.\n\nSee also: add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VariableInfo","page":"Extensions","title":"JuMP.VariableInfo","text":"VariableInfo{S,T,U,V}\n\nA struct by JuMP internally when creating variables. This may also be used by JuMP extensions to create new types of variables.\n\nSee also: ScalarVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.add_variable","page":"Extensions","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.build_variable","page":"Extensions","title":"JuMP.build_variable","text":"build_variable(_error::Function, variables, ::SymMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], Symmetric)\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::SkewSymmetricMatrixSpace)\n\nReturn a VariablesConstrainedOnCreation of shape SkewSymmetricMatrixShape creating variables in MOI.Reals, i.e. \"free\" variables unless they are constrained after their creation.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\nbuild_variable(_error::Function, variables, ::PSDCone)\n\nReturn a VariablesConstrainedOnCreation of shape SymmetricMatrixShape constraining the variables to be positive semidefinite.\n\nThis function is used by the @variable macro as follows:\n\n@variable(model, Q[1:2, 1:2], PSD)\n\n\n\n\n\nbuild_variable(_error::Function, info::VariableInfo; extra_kw_args...)\n\nReturns a new variable.\n\nExtensions should define a method with additional positional arguments to dispatch the call to a different method. The return type should only depend on the positional arguments for variable_type to make sense.\n\nAs an example, @variable(model, x, foo) foo will call build_variable(_error, info, foo)\n\nSee the @variable macro doc for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#Extend-@constraint","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"reference/extensions/","page":"Extensions","title":"Extensions","text":"build_constraint\nadd_constraint\nsense_to_set\nAbstractShape\nshape\nreshape_vector\nreshape_set\ndual_shape\nScalarShape\nVectorShape\nSquareMatrixShape\nSymmetricMatrixShape","category":"page"},{"location":"reference/extensions/#JuMP.build_constraint","page":"Extensions","title":"JuMP.build_constraint","text":"build_constraint(_error::Function, Q::Symmetric{V, M},\n                 ::PSDCone) where {V <: AbstractJuMPScalar,\n                                   M <: AbstractMatrix{V}}\n\nReturn a VectorConstraint of shape SymmetricMatrixShape constraining the matrix Q to be positive semidefinite.\n\nThis function is used by the @constraint macros as follows:\n\n@constraint(model, Symmetric(Q) in PSDCone())\n\nThe form above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2] Symmetric\n# The type of `Q` is `Symmetric{VariableRef, Matrix{VariableRef}}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\nbuild_constraint(_error::Function,\n                 Q::AbstractMatrix{<:AbstractJuMPScalar},\n                 ::PSDCone)\n\nReturn a VectorConstraint of shape SquareMatrixShape constraining the matrix Q to be symmetric and positive semidefinite.\n\nThis function is used by the @constraint and @SDconstraint macros as follows:\n\n@constraint(model, Q in PSDCone())\n@SDconstraint(model, P ‚™∞ Q)\n\nThe @constraint call above is usually used when the entries of Q are affine or quadratic expressions, but it can also be used when the entries are variables to get the reference of the semidefinite constraint, e.g.,\n\n@variable model Q[1:2,1:2]\n# The type of `Q` is `Matrix{VariableRef}`\nvar_psd = @constraint model Q in PSDCone()\n# The `var_psd` variable contains a reference to the constraint\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.add_constraint","page":"Extensions","title":"JuMP.add_constraint","text":"add_constraint(model::Model, con::AbstractConstraint, name::String=\"\")\n\nAdd a constraint con to Model model and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.sense_to_set","page":"Extensions","title":"JuMP.sense_to_set","text":"sense_to_set(_error::Function, ::Val{sense_symbol})\n\nConverts a sense symbol to a set set such that @constraint(model, func sense_symbol 0) is equivalent to @constraint(model, func in set) for any func::AbstractJuMPScalar.\n\nExample\n\nOnce a custom set is defined you can directly create a JuMP constraint with it:\n\njulia> struct CustomSet{T} <: MOI.AbstractScalarSet\n           value::T\n       end\n\njulia> Base.copy(x::CustomSet) = CustomSet(x.value)\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> cref = @constraint(model, x in CustomSet(1.0))\nx ‚àà CustomSet{Float64}(1.0)\n\nHowever, there might be an appropriate sign that could be used in order to provide a more convenient syntax:\n\njulia> JuMP.sense_to_set(::Function, ::Val{:‚ä∞}) = CustomSet(0.0)\n\njulia> MOIU.shift_constant(set::CustomSet, value) = CustomSet(set.value + value)\n\njulia> cref = @constraint(model, x ‚ä∞ 1)\nx ‚àà CustomSet{Float64}(1.0)\n\nNote that the whole function is first moved to the right-hand side, then the sign is transformed into a set with zero constant and finally the constant is moved to the set with MOIU.shift_constant.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.AbstractShape","page":"Extensions","title":"JuMP.AbstractShape","text":"AbstractShape\n\nAbstract vectorizable shape. Given a flat vector form of an object of shape shape, the original object can be obtained by reshape_vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.shape","page":"Extensions","title":"JuMP.shape","text":"shape(c::AbstractConstraint)::AbstractShape\n\nReturn the shape of the constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_vector","page":"Extensions","title":"JuMP.reshape_vector","text":"reshape_vector(vectorized_form::Vector, shape::AbstractShape)\n\nReturn an object in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3], the following code returns the matrix Symmetric(Matrix[1 2; 2 3]):\n\njulia> reshape_vector([1, 2, 3], SymmetricMatrixShape(2))\n2√ó2 LinearAlgebra.Symmetric{Int64,Array{Int64,2}}:\n 1  2\n 2  3\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.reshape_set","page":"Extensions","title":"JuMP.reshape_set","text":"reshape_set(vectorized_set::MOI.AbstractSet, shape::AbstractShape)\n\nReturn a set in its original shape shape given its vectorized form vectorized_form.\n\nExamples\n\nGiven a SymmetricMatrixShape of vectorized form [1, 2, 3] in MOI.PositiveSemidefinieConeTriangle(2), the following code returns the set of the original constraint Symmetric(Matrix[1 2; 2 3]) in PSDCone():\n\njulia> reshape_set(MOI.PositiveSemidefiniteConeTriangle(2), SymmetricMatrixShape(2))\nPSDCone()\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.dual_shape","page":"Extensions","title":"JuMP.dual_shape","text":"dual_shape(shape::AbstractShape)::AbstractShape\n\nReturns the shape of the dual space of the space of objects of shape shape. By default, the dual_shape of a shape is itself. See the examples section below for an example for which this is not the case.\n\nExamples\n\nConsider polynomial constraints for which the dual is moment constraints and moment constraints for which the dual is polynomial constraints. Shapes for polynomials can be defined as follows:\n\nstruct Polynomial\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct PolynomialShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::PolynomialShape) = Polynomial(x, shape.monomials)\n\nand a shape for moments can be defined as follows:\n\nstruct Moments\n    coefficients::Vector{Float64}\n    monomials::Vector{Monomial}\nend\nstruct MomentsShape <: AbstractShape\n    monomials::Vector{Monomial}\nend\nJuMP.reshape_vector(x::Vector, shape::MomentsShape) = Moments(x, shape.monomials)\n\nThen dual_shape allows the definition of the shape of the dual of polynomial and moment constraints:\n\ndual_shape(shape::PolynomialShape) = MomentsShape(shape.monomials)\ndual_shape(shape::MomentsShape) = PolynomialShape(shape.monomials)\n\n\n\n\n\n","category":"function"},{"location":"reference/extensions/#JuMP.ScalarShape","page":"Extensions","title":"JuMP.ScalarShape","text":"ScalarShape\n\nShape of scalar constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.VectorShape","page":"Extensions","title":"JuMP.VectorShape","text":"VectorShape\n\nVector for which the vectorized form corresponds exactly to the vector given.\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SquareMatrixShape","page":"Extensions","title":"JuMP.SquareMatrixShape","text":"SquareMatrixShape\n\nShape object for a square matrix of side_dimension rows and columns. The vectorized form contains the entries of the the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"reference/extensions/#JuMP.SymmetricMatrixShape","page":"Extensions","title":"JuMP.SymmetricMatrixShape","text":"SymmetricMatrixShape\n\nShape object for a symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix given column by column (or equivalently, the entries of the lower-left triangular part given row by row).\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/nlp_tricks.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/#Nonlinear-tips-and-tricks","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This example collates some tips and tricks you can use when formulating nonlinear programs. It uses the following packages:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"using JuMP\nimport Ipopt\nimport Test","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/#User-defined-functions-with-vector-outputs","page":"Nonlinear tips and tricks","title":"User-defined functions with vector outputs","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"A common situation is to have a user-defined function like the following that returns multiple outputs (we define function_calls to keep track of how many times we call this method):","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nfunction foo(x, y)\n    global function_calls += 1\n    common_term = x^2 + y^2\n    term_1 = sqrt(1 + common_term)\n    term_2 = common_term\n    return term_1, term_2\nend","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"For example, the first term might be used in the objective, and the second term might be used in a constraint, and often they share share work that is expensive to evaluate.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This is a problem for JuMP, because it requires user-defined functions to return a single number. One option is to define two separate functions, the first returning the first argument, and the second returning the second argument.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"foo_1(x, y) = foo(x, y)[1]\nfoo_2(x, y) = foo(x, y)[2]","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"However, if the common term is expensive to compute, this approach is wasteful because it will evaluate the expensive term twice. Let's have a look at how many times we evaluate x^2 + y^2 during a solve:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, foo_1; autodiff = true)\nregister(model, :foo_2, 2, foo_2; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ‚âà ‚àö3 atol=1e-4\nTest.@test value.(x) ‚âà [1.0, 1.0] atol=1e-4\nprintln(\"Naive approach: function calls = $(function_calls)\")","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"An alternative approach is to use memoization, which uses a cache to store the result of function evaluations. We can write a memoization function as follows:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"\"\"\"\n    memoize(foo::Function, n_outputs::Int)\n\nTake a function `foo` and return a vector of length `n_outputs`, where each\nelement is a function that returns the `i`'th output of `foo`.\n\nTo avoid duplication of work, cache the most-recent evaluations of `foo`.\nBecause `foo_i` is auto-differentiated with ForwardDiff, our cache needs to\nwork when `x` is a `Float64` and a `ForwardDiff.Dual`.\n\"\"\"\nfunction memoize(foo::Function, n_outputs::Int)\n    last_x, last_f = nothing, nothing\n    last_dx, last_dfdx = nothing, nothing\n    function foo_i(i, x::T...) where {T <: Real}\n        if T == Float64\n            if x != last_x\n                last_x, last_f = x, foo(x...)\n            end\n            return last_f[i]::T\n        else\n            if x != last_dx\n                last_dx, last_dfdx = x, foo(x...)\n            end\n            return last_dfdx[i]::T\n        end\n    end\n    return [(x...) -> foo_i(i, x...) for i = 1:n_outputs]\nend","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Let's see how it works. First, construct the memoized versions of foo:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo = memoize(foo, 2)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now try evaluating the first element of memoized_foo.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"function_calls = 0\nmemoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"As expected, this evaluated the function once. However, if we call the function again, we hit the cache instead of needing to re-compute foo and function_calls is still 1!","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"memoized_foo[1](1.0, 1.0)\nprintln(\"function_calls = \", function_calls)","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Now let's see how this works during a real solve:","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"model = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, x[1:2] >= 0, start = 0.1)\nregister(model, :foo_1, 2, memoized_foo[1]; autodiff = true)\nregister(model, :foo_2, 2, memoized_foo[2]; autodiff = true)\n@NLobjective(model, Max, foo_1(x[1], x[2]))\n@NLconstraint(model, foo_2(x[1], x[2]) <= 2)\nfunction_calls = 0\noptimize!(model)\nTest.@test objective_value(model) ‚âà ‚àö3 atol=1e-4\nTest.@test value.(x) ‚âà [1.0, 1.0] atol=1e-4\nprintln(\"Memoized approach: function_calls = $(function_calls)\")","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"Compared to the naive approach, the memoized approach requires half as many function evaluations!","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/nlp_tricks/","page":"Nonlinear tips and tricks","title":"Nonlinear tips and tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"manual/variables/#What-is-a-JuMP-variable?","page":"Variables","title":"What is a JuMP variable?","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The term variable in mathematical optimization has many meanings. Here, we distinguish between the following three types of variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"optimization variables, which are the mathematical x in the problem maxf_0(x)  f_i(x) in S_i.\nJulia variables, which are bindings between a name and a value, for example x = 1. (See here for the Julia docs.)\nJuMP variables, which are instances of the VariableRef struct defined by JuMP that contains a reference to an optimization variable in a model. (Extra for experts: the VariableRef struct is a thin wrapper around a MOI.VariableIndex, and also contains a reference to the JuMP model.)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To illustrate these three types of variables, consider the following JuMP code (the full syntax is explained below):","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x[1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This code does three things:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It adds two optimization variables to model.\nIt creates two JuMP variables that act as references to those optimization variables.\nIt binds those JuMP variables as a vector with two elements to the Julia variable x.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"To reduce confusion, we will attempt, where possible, to always refer to variables with their corresponding prefix.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP variables can have attributes, such as names or an initial primal start value. We illustrate the name attribute in the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y, base_name=\"decision variable\")\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This code does four things:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"It adds one optimization variable to model.\nIt creates one JuMP variable that acts as a reference to that optimization variable.\nIt binds the JuMP variable to the Julia variable y.\nIt tells JuMP that the name attribute of this JuMP variable is \"decision variable\". JuMP uses the value of base_name when it has to print the variable as a string.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, when we print y at the REPL we get:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Because y is a Julia variable, we can bind it to a different value. For example, if we write:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y = 1\n1","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"y is no longer a binding to a JuMP variable. This does not mean that the JuMP variable has been destroyed. It still exists and is still a reference to the same optimization variable. The binding can be reset by querying the model for the symbol as it was written in the @variable macro. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model[:y]\ndecision variable","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This act of looking up the JuMP variable by using the symbol is most useful when composing JuMP models across multiple functions, as illustrated by the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"function add_component_to_model(model::JuMP.Model)\n    x = model[:x]\n    # ... code that uses x\nend\nfunction build_model()\n    model = Model()\n    @variable(model, x)\n    add_component_to_model(model)\nend","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Now that we understand the difference between optimization, JuMP, and Julia variables, we can introduce more of the functionality of the @variable macro.","category":"page"},{"location":"manual/variables/#Variable-bounds","page":"Variables","title":"Variable bounds","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the basic usage of the @variable macro. The next extension is to add lower- and upper-bounds to each optimization variable. This can be done as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x_free)\nx_free\n\njulia> @variable(model, x_lower >= 0)\nx_lower\n\njulia> @variable(model, x_upper <= 1)\nx_upper\n\njulia> @variable(model, 2 <= x_interval <= 3)\nx_interval\n\njulia> @variable(model, x_fixed == 4)\nx_fixed","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the above examples, x_free represents an unbounded optimization variable, x_lower represents an optimization variable with a lower bound and so forth.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nWhen creating a variable with only a lower-bound or an upper-bound, and the value of the bound is not a numeric literal, the name of the variable must appear on the left-hand side. Putting the name on the right-hand side will result in an error. For example:@variable(model, 1 <= x)  # works\na = 1\n@variable(model, a <= x)  # errors\n@variable(model, x >= a)  # works","category":"page"},{"location":"manual/variables/#Check-if-a-variable-bound-exists","page":"Variables","title":"Check if a variable bound exists","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can query whether an optimization variable has a lower- or upper-bound via the has_lower_bound and has_upper_bound functions. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> has_lower_bound(x_free)\nfalse\n\njulia> has_upper_bound(x_upper)\ntrue","category":"page"},{"location":"manual/variables/#Query-a-variable-bound","page":"Variables","title":"Query a variable bound","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If a variable has a lower or upper bound, we can query the value of it via the lower_bound and upper_bound functions. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> lower_bound(x_interval)\n2.0\n\njulia> upper_bound(x_interval)\n3.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"manual/variables/#Set-variable-bounds-via-keyword","page":"Variables","title":"Set variable bounds via keyword","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, lower_bound=1, upper_bound=2)\nx\n\njulia> lower_bound(x)\n1.0","category":"page"},{"location":"manual/variables/#Set-variable-bounds-bounds-via-functions","page":"Variables","title":"Set variable bounds bounds via functions","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Another option is to use the set_lower_bound and set_upper_bound functions. These can also be used to modify an existing variable bound. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> set_lower_bound(x, 2)\n\njulia> lower_bound(x)\n2.0","category":"page"},{"location":"manual/variables/#Delete-a-variable-bound","page":"Variables","title":"Delete a variable bound","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can delete variable bounds using delete_lower_bound and delete_upper_bound:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, 1 <= x <= 2)\nx\n\njulia> lower_bound(x)\n1.0\n\njulia> delete_lower_bound(x)\n\njulia> has_lower_bound(x)\nfalse\n\njulia> upper_bound(x)\n2.0\n\njulia> delete_upper_bound(x)\n\njulia> has_upper_bound(x)\nfalse","category":"page"},{"location":"manual/variables/#Create-a-fixed-variable","page":"Variables","title":"Create a fixed variable","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In addition to upper and lower bounds, JuMP variables can also be fixed to a value using fix. See also is_fixed, fix_value, and unfix.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x == 1)\nx\n\njulia> is_fixed(x)\ntrue\n\njulia> fix_value(x)\n1.0\n\njulia> unfix(x)\n\njulia> is_fixed(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Fixing a variable with existing bounds will throw an error. To delete the bounds prior to fixing, use fix(variable, value; force = true).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x >= 1)\nx\n\njulia> fix(x, 2)\nERROR: Unable to fix x to 2 because it has existing variable bounds. Consider calling `JuMP.fix(variable, value; force=true)` which will delete existing bounds before fixing the variable.\n\njulia> fix(x, 2; force = true)\n\n\njulia> fix_value(x)\n2.0","category":"page"},{"location":"manual/variables/#Variable-names","page":"Variables","title":"Variable names","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The name, i.e. the value of the MOI.VariableName attribute, of a variable can be obtained by JuMP.name(::JuMP.VariableRef) and set by JuMP.set_name(::JuMP.VariableRef, ::String).","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The variable can also be retrieved from its name using JuMP.variable_by_name.","category":"page"},{"location":"manual/variables/#Variable-containers","page":"Variables","title":"Variable containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the examples above, we have mostly created scalar variables. By scalar, we mean that the Julia variable is bound to exactly one JuMP variable. However, it is often useful to create collections of JuMP variables inside more complicated data structures.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP provides a mechanism for creating three types of these data structures, which we refer to as containers. The three types are Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/variables/#Arrays","page":"Variables","title":"Arrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We have already seen the creation of an array of JuMP variables with the x[1:2] syntax. This can naturally be extended to create multi-dimensional arrays of JuMP variables. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2])\n2√ó2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Arrays of JuMP variables can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, 2]\nx[1,2]\n\njulia> x[2, :]\n2-element Array{VariableRef,1}:\n x[2,1]\n x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variable bounds can depend upon the indices:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=1:2] >= 2i + j)\n2√ó2 Array{VariableRef,2}:\n x[1,1]  x[1,2]\n x[2,1]  x[2,2]\n\njulia> lower_bound.(x)\n2√ó2 Array{Float64,2}:\n 3.0  4.0\n 5.0  6.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP will form an Array of JuMP variables when it can determine at compile time that the indices are one-based integer ranges. Therefore x[1:b] will create an Array of JuMP variables, but x[a:b] will not. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of x[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/variables/#variable_jump_arrays","page":"Variables","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We often want to create arrays where the indices are not one-based integer ranges. For example, we may want to create a variable indexed by the name of a product or a location. The syntax is the same as that above, except with an arbitrary vector as an index as opposed to a one-based range. The biggest difference is that instead of returning an Array of JuMP variables, JuMP will return a DenseAxisArray. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, [:A,:B]])\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{VariableRef,2}:\n x[1,A]  x[1,B]\n x[2,A]  x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"DenseAxisArrays can be indexed and sliced as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x[1, :A]\nx[1,A]\n\njulia> x[2, :]\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{VariableRef,1}:\n x[2,A]\n x[2,B]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Similarly to the Array case, bounds can depend upon indices. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=2:3, j=1:2:3] >= 0.5i + j)\n2-dimensional DenseAxisArray{VariableRef,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2√ó2 Array{VariableRef,2}:\n x[2,1]  x[2,3]\n x[3,1]  x[3,3]\n\njulia> lower_bound.(x)\n2-dimensional DenseAxisArray{Float64,2,...} with index sets:\n    Dimension 1, 2:3\n    Dimension 2, 1:2:3\nAnd data, a 2√ó2 Array{Float64,2}:\n 2.0  4.0\n 2.5  4.5","category":"page"},{"location":"manual/variables/#variable_sparseaxisarrays","page":"Variables","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The third container type that JuMP natively supports is SparseAxisArray. These arrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing). JuMP supports this as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:2, j=i:2])\nJuMP.Containers.SparseAxisArray{VariableRef,2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  x[1,2]\n  [2, 2]  =  x[2,2]\n  [1, 1]  =  x[1,1]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can also conditionally create variables via a JuMP-specific syntax. This syntax appends a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;). For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[i=1:4; mod(i, 2)==0])\nJuMP.Containers.SparseAxisArray{VariableRef,1,Tuple{Int64}} with 2 entries:\n  [4]  =  x[4]\n  [2]  =  x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that with many index dimensions and a large amount of sparsity, variable construction may be unnecessarily slow if the semi-colon syntax is naively applied. When using the semi-colon as a filter, JuMP iterates over all indices and evaluates the conditional for each combination. When this is undesired, the recommended work-around is to work directly with a list of tuples or create a dictionary. Consider the following examples:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"# TODO: Reformat the code below as a doctest.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"N = 10\nS = [(1, 1, 1),(N, N, N)]\n# Slow. It evaluates conditional N^3 times.\n@variable(model, x1[i=1:N, j=1:N, k=1:N; (i, j, k) in S])\n# Fast.\n@variable(model, x2[S])\n# Fast. Manually constructs a dictionary and fills it.\nx3 = Dict()\nfor (i, j, k) in S\n    x3[i, j, k] = @variable(model)\n    # Optional, if you care about pretty printing:\n    set_name(x3[i, j, k], \"x[$i,$j,$k]\")\nend","category":"page"},{"location":"manual/variables/#variable_forcing","page":"Variables","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"When creating a container of JuMP variables, JuMP will attempt to choose the tightest container type that can store the JuMP variables. Thus, it will prefer to create an Array before a DenseAxisArray and a DenseAxisArray before a SparseAxisArray. However, because this happens at compile time, it does not always make the best choice. To illustrate this, consider the following example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> A = 1:2\n1:2\n\njulia> @variable(model, x[A])\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, 1:2\nAnd data, a 2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Since the value (and type) of A is unknown at parsing time, JuMP is unable to infer that A is a one-based integer range. Therefore, JuMP creates a DenseAxisArray, even though it could store these two variables in a standard one-dimensional Array.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can share our knowledge that it is possible to store these JuMP variables as an array by setting the container keyword:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[A], container=Array)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP now creates a vector of JuMP variables instead of a DenseAxisArray. Note that choosing an invalid container type will throw an error.","category":"page"},{"location":"manual/variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Adding integrality constraints to a model such as @constraint(model, x in MOI.ZeroOne()) and @constraint(model, x in MOI.Integer()) is a common operation. Therefore, JuMP supports two shortcuts for adding such constraints.","category":"page"},{"location":"manual/variables/#Binary-(ZeroOne)-constraints","page":"Variables","title":"Binary (ZeroOne) constraints","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary optimization variables are constrained to the set x in 0 1. (The MOI.ZeroOne set in MathOptInterface.) Binary optimization variables can be created in JuMP by passing Bin as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Bin)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is binary by calling is_binary on the JuMP variable, and binary constraints can be removed with unset_binary.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_binary(x)\ntrue\n\njulia> unset_binary(x)\n\njulia> is_binary(x)\nfalse","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Binary optimization variables can also be created by setting the binary keyword to true.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, binary=true)\nx","category":"page"},{"location":"manual/variables/#Integer-constraints","page":"Variables","title":"Integer constraints","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer optimization variables are constrained to the set x in mathbbZ. (The MOI.Integer set in MathOptInterface.) Integer optimization variables can be created in JuMP by passing Int as an optional positional argument:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, Int)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Integer optimization variables can also be created by setting the integer keyword to true.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x, integer=true)\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"We can check if an optimization variable is integer by calling is_integer on the JuMP variable, and integer constraints can be removed with unset_integer.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> is_integer(x)\ntrue\n\njulia> unset_integer(x)\n\njulia> is_integer(x)\nfalse","category":"page"},{"location":"manual/variables/#Relaxing-integrality","page":"Variables","title":"Relaxing integrality","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The relax_integrality function relaxes all integrality constraints in the model, returning a function that can be called to undo the operation later on.","category":"page"},{"location":"manual/variables/#Semidefinite-variables","page":"Variables","title":"Semidefinite variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative. We can declare a matrix of JuMP variables to be positive semidefinite as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], PSD)\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"or using the syntax for Variables constrained on creation:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in PSDCone())\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Note that x must be a square 2-dimensional Array of JuMP variables; it cannot be a DenseAxisArray or a SparseAxisArray. (See Variable containers, above, for more on this.)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2], Symmetric)\n2√ó2 LinearAlgebra.Symmetric{VariableRef,Array{VariableRef,2}}:\n x[1,1]  x[1,2]\n x[1,2]  x[2,2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"You can impose a constraint that the square matrix is skew symmetric with SkewSymmetricMatrixSpace:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:2, 1:2] in SkewSymmetricMatrixSpace())\n2√ó2 Array{GenericAffExpr{Float64,VariableRef},2}:\n 0        x[1,2]\n -x[1,2]  0","category":"page"},{"location":"manual/variables/#Anonymous-JuMP-variables","page":"Variables","title":"Anonymous JuMP variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In all of the above examples, we have created named JuMP variables. However, it is also possible to create so called anonymous JuMP variables. To create an anonymous JuMP variable, we drop the name of the variable from the macro call. This means dropping the second positional argument if the JuMP variable is a scalar, or dropping the name before the square bracket ([) if a container is being created. For example:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model)\nnoname","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"This shows how @variable(model, x) is really short for:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = model[:x] = @variable(model, base_name=\"x\")\nx","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An Array of anonymous JuMP variables can be created as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> y = @variable(model, [i=1:2])\n2-element Array{VariableRef,1}:\n noname\n noname","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If necessary, you can store x in model as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> model[:x] = x","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The <= and >= short-hand cannot be used to set bounds on anonymous JuMP variables. Instead, you should use the lower_bound and upper_bound keywords.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Passing the Bin and Int variable types are also invalid. Instead, you should use the binary and integer keywords.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Thus, the anonymous variant of @variable(model, x[i=1:2] >= i, Int) is:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> x = @variable(model, [i=1:2], base_name=\"x\", lower_bound=i, integer=true)\n2-element Array{VariableRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"warn: Warn\nCreating two named JuMP variables with the same name results in an error at runtime. Use anonymous variables as an alternative.","category":"page"},{"location":"manual/variables/#Variables-constrained-on-creation","page":"Variables","title":"Variables constrained on creation","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"info: Info\nWhen using JuMP in Direct mode, it may be required to constrain variables on creation instead of constraining free variables as the solver may only support variables constrained on creation. In Automatic and Manual modes, both ways of adding constraints on variables are equivalent. Indeed, during the copy of the cache to the optimizer, the choice of the constraints on variables that are copied as variables constrained on creation does not depend on how it was added to the cache.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"All uses of the @variable macro documented so far translate to a separate call for variable creation and adding of constraints.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For example, @variable(model, x >= 0, Int), is equivalent to:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"@variable(model, x)\nset_lower_bound(x, 0.0)\n@constraint(model, x in MOI.Integer())","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Importantly, the bound and integrality constraints are added after the variable has been created.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"However, some solvers require a constraining set at creation time. We say that these variables are constrained on creation.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use in within @variable to access the special syntax for constraining variables on creation. For example, the following creates a vector of variables constrained on creation to belong to the SecondOrderCone:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, y[1:3] in SecondOrderCone())\n3-element Array{VariableRef,1}:\n y[1]\n y[2]\n y[3]","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"For contrast, the more standard approach is as follows:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SecondOrderCone())\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The technical difference between the former and the latter is that the former calls MOI.add_constrained_variables while the latter calls MOI.add_variables and then MOI.add_constraint. This distinction is important only in Direct mode, depending on the solver being used. It's often not possible to delete the SecondOrderCone constraint if it was specified at variable creation time.","category":"page"},{"location":"manual/variables/#The-set-keyword","page":"Variables","title":"The set keyword","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"An alternate syntax to x in Set is to use the set keyword of @variable. This is most useful when creating anonymous variables:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"x = @variable(model, [1:2, 1:2], set = PSDCone())","category":"page"},{"location":"manual/variables/#User-defined-containers","page":"Variables","title":"User-defined containers","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"In the section Variable containers, we explained how JuMP supports the efficient creation of collections of JuMP variables in three types of containers. However, users are also free to create collections of JuMP variables in their own data structures. For example, the following code creates a dictionary with symmetric matrices as the values:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> variables = Dict{Symbol, Array{VariableRef,2}}()\nDict{Symbol,Array{VariableRef,2}} with 0 entries\n\njulia> for key in [:A, :B]\n           global variables[key] = @variable(model, [1:2, 1:2])\n       end\n\njulia> variables\nDict{Symbol,Array{VariableRef,2}} with 2 entries:\n  :A => VariableRef[noname noname; noname noname]\n  :B => VariableRef[noname noname; noname noname]","category":"page"},{"location":"manual/variables/#Deleting-variables","page":"Variables","title":"Deleting variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Variables can be deleted from a model using delete.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Check if a variable reference is valid using is_valid.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> is_valid(model, x)\ntrue\n\njulia> delete(model, x)\n\njulia> is_valid(model, x)\nfalse","category":"page"},{"location":"manual/variables/#Listing-all-variables","page":"Variables","title":"Listing all variables","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"Use JuMP.all_variables to obtain a list of all variables present in the model. This is useful for performing operations like:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"relaxing all integrality constraints in the model\nsetting the starting values for variables to the result of the last solve","category":"page"},{"location":"manual/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"There are two ways to provide a primal starting solution (also called MIP-start or a warmstart) for each variable:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"using the start keyword in the @variable macro\nusing set_start_value","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"The starting value of a variable can be queried using start_value. If no start value has been set, start_value will return nothing.","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variable(model, x)\nx\n\njulia> start_value(x)\n\njulia> @variable(model, y, start = 1)\ny\n\njulia> start_value(y)\n1.0\n\njulia> set_start_value(y, 2)\n\njulia> start_value(y)\n2.0","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nPrior to JuMP 0.19, the previous solution to a solve was automatically set as the new starting value. JuMP 0.19 no longer does this automatically. To reproduce the functionality, use:set_start_value.(all_variables(model), value.(all_variables(model)))","category":"page"},{"location":"manual/variables/#variables","page":"Variables","title":"The @variables macro","text":"","category":"section"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"If you have many @variable calls, JuMP provides the macro @variables that can improve readability:","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"julia> @variables(model, begin\n           x\n           y[i=1:2] >= i, (start = i, base_name = \"Y_$i\")\n           z, Bin\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n Y_1[1] ‚â• 1.0\n Y_2[2] ‚â• 2.0\n z binary","category":"page"},{"location":"manual/variables/","page":"Variables","title":"Variables","text":"note: Note\nKeyword arguments must be contained within parentheses. (See the example above.)","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/cluster.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/#K-means-clustering-via-SDP","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"From \"Approximating K-means-type clustering via semidefinite programming\" By Jiming Peng and Yu Wei.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"Given a set of points a_1 ldots a_m  in R_n, allocate them to k clusters.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"using JuMP\nimport LinearAlgebra\nimport SCS\n\nfunction example_cluster(; verbose = true)\n    # Data points\n    n = 2\n    m = 6\n    a = Any[\n        [2.0, 2.0], [2.5, 2.1], [7.0, 7.0], [2.2, 2.3], [6.8, 7.0], [7.2, 7.5]\n    ]\n    k = 2\n    # Weight matrix\n    W = zeros(m, m)\n    for i in 1:m\n        for j in i + 1:m\n            W[i, j] = W[j, i] = exp(-LinearAlgebra.norm(a[i] - a[j]) / 1.0)\n        end\n    end\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    # Z >= 0, PSD\n    @variable(model, Z[1:m, 1:m], PSD)\n    @constraint(model, Z .>= 0)\n    # min Tr(W(I-Z))\n    I = Matrix(1.0 * LinearAlgebra.I, m, m)\n    @objective(model, Min, LinearAlgebra.tr(W * (I - Z)))\n    # Z e = e\n    @constraint(model, Z * ones(m) .== ones(m))\n    # Tr(Z) = k\n    @constraint(model, LinearAlgebra.tr(Z) == k)\n    optimize!(model)\n    Z_val = value.(Z)\n    # A simple rounding scheme\n    which_cluster = zeros(Int, m)\n    num_clusters = 0\n    for i in 1:m\n        Z_val[i, i] <= 1e-6 && continue\n        if which_cluster[i] == 0\n            num_clusters += 1\n            which_cluster[i] = num_clusters\n            for j in i + 1:m\n                if LinearAlgebra.norm(Z_val[i, j] - Z_val[i, i]) <= 1e-6\n                    which_cluster[j] = num_clusters\n                end\n            end\n        end\n    end\n    if verbose\n        # Print results\n        for cluster in 1:k\n            println(\"Cluster $cluster\")\n            for i in 1:m\n                if which_cluster[i] == cluster\n                    println(a[i])\n                end\n            end\n        end\n    end\n    return\nend\n\nexample_cluster()","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/cluster/","page":"K-means clustering via SDP","title":"K-means clustering via SDP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/urban_plan.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/#The-urban-planning-problem","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"An \"urban planning\" problem based on an example from puzzlor.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_urban_plan()\n    model = Model(GLPK.Optimizer)\n    # x is indexed by row and column\n    @variable(model, 0 <= x[1:5, 1:5] <= 1, Int)\n    # y is indexed by R or C, the points, and an index in 1:5. Note how JuMP\n    # allows indexing on arbitrary sets.\n    rowcol = [\"R\", \"C\"]\n    points = [5, 4, 3, -3, -4, -5]\n    @variable(model, 0 <= y[rowcol, points, 1:5] <= 1, Int)\n    # Objective - combine the positive and negative parts\n    @objective(model, Max, sum(\n          3 * (y[\"R\", 3, i] + y[\"C\", 3, i])\n        + 1 * (y[\"R\", 4, i] + y[\"C\", 4, i])\n        + 1 * (y[\"R\", 5, i] + y[\"C\", 5, i])\n        - 3 * (y[\"R\", -3, i] + y[\"C\", -3, i])\n        - 1 * (y[\"R\", -4, i] + y[\"C\", -4, i])\n        - 1 * (y[\"R\", -5, i] + y[\"C\", -5, i])\n        for i in 1:5)\n    )\n    # Constrain the number of residential lots\n    @constraint(model, sum(x) == 12)\n    # Add the constraints that link the auxiliary y variables to the x variables\n    for i = 1:5\n        @constraints(model, begin\n            # Rows\n            y[\"R\", 5, i] <= 1 / 5 * sum(x[i, :]) # sum = 5\n            y[\"R\", 4, i] <= 1 / 4 * sum(x[i, :]) # sum = 4\n            y[\"R\", 3, i] <= 1 / 3 * sum(x[i, :]) # sum = 3\n            y[\"R\", -3, i] >= 1 - 1 / 3 * sum(x[i, :]) # sum = 2\n            y[\"R\", -4, i] >= 1 - 1 / 2 * sum(x[i, :]) # sum = 1\n            y[\"R\", -5, i] >= 1 - 1 / 1 * sum(x[i, :]) # sum = 0\n            # Columns\n            y[\"C\", 5, i] <= 1 / 5 * sum(x[:, i]) # sum = 5\n            y[\"C\", 4, i] <= 1 / 4 * sum(x[:, i]) # sum = 4\n            y[\"C\", 3, i] <= 1 / 3 * sum(x[:, i]) # sum = 3\n            y[\"C\", -3, i] >= 1 - 1 / 3 * sum(x[:, i]) # sum = 2\n            y[\"C\", -4, i] >= 1 - 1 / 2 * sum(x[:, i]) # sum = 1\n            y[\"C\", -5, i] >= 1 - 1 / 1 * sum(x[:, i]) # sum = 0\n        end)\n    end\n    # Solve it\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 14.0\n    return\nend\n\nexample_urban_plan()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/urban_plan/","page":"The urban planning problem","title":"The urban planning problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"tip: Tip\nA good source of tips is the Mosek Modeling Cookbook.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This tutorial collates some tips and tricks you can use when formulating mixed-integer programs. It uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"using JuMP","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Boolean-Operators-on-Binary-Variables","page":"Tips and tricks","title":"Boolean Operators on Binary Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Binary variables can be used to construct logical operators. Here are some example.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#OR","page":"Tips and tricks","title":"OR","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 lor x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[1] <= x[3]\n    x[2] <= x[3]\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#And","page":"Tips and tricks","title":"And","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_3 = x_1 land x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraints(model, begin\n    x[3] <= x[1]\n    x[3] <= x[2]\n    x[3] >= x[1] + x[2] - 1\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Not","page":"Tips and tricks","title":"Not","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 neg x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] == 1 - x[2])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Implies","page":"Tips and tricks","title":"Implies","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"x_1 implies x_2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2], Bin)\n@constraint(model, x[1] <= x[2])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Big-M-Disjunctive-Constraints-(OR)","page":"Tips and tricks","title":"Big-M Disjunctive Constraints (OR)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Problem Suppose that we have two constraints a^top x leq b and c^top x leq d, and we want at least one to hold.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Trick Introduce a \"big-M\" multiplied by a binary variable to relax one of the constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example Either x_1 leq 1 and/or x_2 leq 2.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, y, Bin)\nM = 100\n@constraint(model, x[1] <= 1 + M * y)\n@constraint(model, x[2] <= 2 + M * (1 - y))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"warning: Warning\nIf M is too small, the solution may be suboptimal. If M is too big, the solver may encounter numerical issues. Try to use domain knowledge to choose an M that is just right. Gurobi has a good documentation section on this topic.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Indicator-Constraints-(\\implies)","page":"Tips and tricks","title":"Indicator Constraints (implies)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Problem","page":"Tips and tricks","title":"Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Suppose we want to model that a certain linear inequality must be satisfied when some other event occurs, i.e., for a binary variable z, we want to model the implication:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"z = 1 implies a^Tx leq b","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Trick-1","page":"Tips and tricks","title":"Trick 1","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Some solvers have native support for indicator constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\n@constraint(model, !z => {sum(x) <= 1})","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Trick-2","page":"Tips and tricks","title":"Trick 2","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the solver doesn't support indicator constraints, you an use the big-M trick.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <=  1 + M * (1 - z))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x_1 + x_2 leq 1 if z = 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:2])\n@variable(model, z, Bin)\nM = 100\n@constraint(model, sum(x) <=  1 + M * z)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Semi-Continuous-Variables","page":"Tips and tricks","title":"Semi-Continuous Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-continuous variable is a continuous variable between bounds lu that also can assume the value zero. ie. x in 0 cup lu","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Example x in 0cup 1 2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semicontinuous(1.0, 2.0))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Semi-Integer-Variables","page":"Tips and tricks","title":"Semi-Integer Variables","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A semi-integer variable is a variable which assumes integer values between bounds lu and can also assume the value zero: x in 0 cup l u cap mathbbZ","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x in MOI.Semiinteger(5.0, 10.0))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Special-Ordered-Sets-of-Type-I-(SOS1)","page":"Tips and tricks","title":"Special Ordered Sets of Type I (SOS1)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of Type I is a set of variables, at most one of which can take a non-zero value, all others being at 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"They most frequently apply where a set of variables are actually binary variables. In other words, we have to choose at most one from a set of possibilities.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3], Bin)\n@constraint(model, x in SOS1())","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"You can optionally pass SOS1 a weight vector like","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"@constraint(model, x in SOS1([0.2, 0.5, 0.3]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"If the decision variables are related and have a physical ordering, then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#tip_sos2","page":"Tips and tricks","title":"Special Ordered Sets of Type II (SOS2)","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"A Special Ordered Set of type 2 is a set of non-negative variables, of which at most two can be non-zero, and if two are non-zero these must be consecutive in their ordering.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"model = Model()\n@variable(model, x[1:3])\n@constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"The ordering provided by the weight vector is more important in this case as the variables need to be consecutive according to the ordering. For example, in the above constraint, the possible pairs are:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Consecutive\n(x[1] and x[3]) as they correspond to 3 and 2 resp. and thus can be non-zero\n(x[2] and x[3]) as they correspond to 1 and 2 resp. and thus can be non-zero\nNon-consecutive\n(x[1] and x[2]) as they correspond to 3 and 1 resp. and thus cannot be non-zero","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/#Piecewise-linear-approximations","page":"Tips and tricks","title":"Piecewise linear approximations","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"SOSII constraints are most often used to form piecewise linear approximations of a function.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"Given a set of points for x:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"xÃÇ = -1:0.5:2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"and a set of corresponding points for y:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"yÃÇ = xÃÇ.^2","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"the piecewise linear approximation is constructed by representing x and y as convex combinations of xÃÇ and yÃÇ.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"N = length(xÃÇ)\nmodel = Model()\n@variable(model, -1 <= x <= 2)\n@variable(model, y)\n@variable(model, 0 <= Œª[1:N] <= 1)\n@objective(model, Max, y)\n@constraints(model, begin\n    x == sum(xÃÇ[i] * Œª[i] for i = 1:N)\n    y == sum(yÃÇ[i] * Œª[i] for i = 1:N)\n    sum(Œª) == 1\n    Œª in SOS2()\nend)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/tips_and_tricks/","page":"Tips and tricks","title":"Tips and tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/rosenbrock.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/#The-Rosenbrock-function","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"A nonlinear example of the classical Rosenbrock function.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_rosenbrock()\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y)\n    @NLobjective(model, Min, (1 - x)^2 + 100 * (y - x^2)^2)\n    optimize!(model)\n\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 0.0 atol = 1e-10\n    Test.@test value(x) ‚âà 1.0\n    Test.@test value(y) ‚âà 1.0\n    return\nend\n\nexample_rosenbrock()","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/rosenbrock/","page":"The Rosenbrock function","title":"The Rosenbrock function","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/objective/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"This page describes macros and functions related to linear and quadratic objective functions only, unless otherwise indicated. For nonlinear objective functions, see Nonlinear Modeling.","category":"page"},{"location":"manual/objective/#Set-a-linear-objective","page":"Objectives","title":"Set a linear objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a linear objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Min to create a minimization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use Max to create a maximization objective:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Max, 2x + 1)\n2 x + 1","category":"page"},{"location":"manual/objective/#Set-a-quadratic-objective","page":"Objectives","title":"Set a quadratic objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use the @objective macro to set a quadratic objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use ^2 to have a variable squared:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, x^2 + 2x + 1)\nx¬≤ + 2 x + 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"You can also have bilinear terms between variables:","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @objective(model, Max, x * y + x + y)\nx*y + x + y","category":"page"},{"location":"manual/objective/#Query-the-objective-function","page":"Objectives","title":"Query the objective function","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_function to return the current objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model)\n2 x + 1","category":"page"},{"location":"manual/objective/#Query-the-objective-sense","page":"Objectives","title":"Query the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use objective_sense to return the current objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0","category":"page"},{"location":"manual/objective/#Modify-an-objective","page":"Objectives","title":"Modify an objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"To modify an objective, call @objective with the new objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, -2x)\n-2 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, use set_objective_function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> new_objective = @expression(model, -2 * x)\n-2 x\n\njulia> set_objective_function(model, new_objective)","category":"page"},{"location":"manual/objective/#Modify-an-objective-coefficient","page":"Objectives","title":"Modify an objective coefficient","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_coefficient to modify an objective coefficient.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> set_objective_coefficient(model, x, 3)\n\njulia> objective_function(model)\n3 x","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"info: Info\nThere is no way to modify the coefficient of a quadratic term. Set a new objective instead.","category":"page"},{"location":"manual/objective/#Modify-the-objective-sense","page":"Objectives","title":"Modify the objective sense","text":"","category":"section"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Use set_objective_sense to modify the objective sense.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\njulia> set_objective_sense(model, MOI.MAX_SENSE);\n\njulia> objective_sense(model)\nMAX_SENSE::OptimizationSense = 1","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"Alternatively, call @objective and pass the existing objective function.","category":"page"},{"location":"manual/objective/","page":"Objectives","title":"Objectives","text":"julia> @objective(model, Min, 2x)\n2 x\n\njulia> @objective(model, Max, objective_function(model))\n2 x","category":"page"},{"location":"reference/moi/#MOIAPI","page":"MathOptInterface","title":"MathOptInterface","text":"","category":"section"},{"location":"reference/moi/","page":"MathOptInterface","title":"MathOptInterface","text":"This page contains extracts from the MathOptInterface documentation. More information can be found at in the MathOptInterface documentation.","category":"page"},{"location":"reference/moi/","page":"MathOptInterface","title":"MathOptInterface","text":"MOI.get\nMOI.optimize!\nMOIU.reset_optimizer(::JuMP.Model)\nMOIU.drop_optimizer(::JuMP.Model)\nMOIU.attach_optimizer(::JuMP.Model)","category":"page"},{"location":"reference/moi/#MathOptInterface.get","page":"MathOptInterface","title":"MathOptInterface.get","text":"get(optimizer::AbstractOptimizer, attr::AbstractOptimizerAttribute)\n\nReturn an attribute attr of the optimizer optimizer.\n\nget(model::ModelLike, attr::AbstractModelAttribute)\n\nReturn an attribute attr of the model model.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex)\n\nIf the attribute attr is set for the variable v in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractVariableAttribute, v::Vector{VariableIndex})\n\nReturn a vector of attributes corresponding to each variable in the collection v in the model model.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex)\n\nIf the attribute attr is set for the constraint c in the model model, return its value, return nothing otherwise. If the attribute attr is not supported by model then an error should be thrown instead of returning nothing.\n\nget(model::ModelLike, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})\n\nReturn a vector of attributes corresponding to each constraint in the collection c in the model model.\n\nget(model::ModelLike, ::Type{VariableIndex}, name::String)\n\nIf a variable with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two variables have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex{F,S}}, name::String) where {F<:AbstractFunction,S<:AbstractSet}\n\nIf an F-in-S constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. Errors if two constraints have the same name.\n\nget(model::ModelLike, ::Type{ConstraintIndex}, name::String)\n\nIf any constraint with name name exists in the model model, return the corresponding index, otherwise return nothing. This version is available for convenience but may incur a performance penalty because it is not type stable. Errors if two constraints have the same name.\n\nExamples\n\nget(model, ObjectiveValue())\nget(model, VariablePrimal(), ref)\nget(model, VariablePrimal(5), [ref1, ref2])\nget(model, OtherAttribute(\"something specific to cplex\"))\nget(model, VariableIndex, \"var1\")\nget(model, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, \"con1\")\nget(model, ConstraintIndex, \"con1\")\n\n\n\n\n\n","category":"function"},{"location":"reference/moi/#MathOptInterface.optimize!","page":"MathOptInterface","title":"MathOptInterface.optimize!","text":"optimize!(optimizer::AbstractOptimizer)\n\nStart the solution procedure.\n\n\n\n\n\n","category":"function"},{"location":"reference/moi/#MathOptInterface.Utilities.reset_optimizer-Tuple{Model}","page":"MathOptInterface","title":"MathOptInterface.Utilities.reset_optimizer","text":"MOIU.reset_optimizer(model::Model)\n\nCall MOIU.reset_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/moi/#MathOptInterface.Utilities.drop_optimizer-Tuple{Model}","page":"MathOptInterface","title":"MathOptInterface.Utilities.drop_optimizer","text":"MOIU.drop_optimizer(model::Model)\n\nCall MOIU.drop_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/moi/#MathOptInterface.Utilities.attach_optimizer-Tuple{Model}","page":"MathOptInterface","title":"MathOptInterface.Utilities.attach_optimizer","text":"MOIU.attach_optimizer(model::Model)\n\nCall MOIU.attach_optimizer on the backend of model.\n\nCannot be called in direct mode.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/clnlbeam.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/#The-clnlbeam-problem","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Based on an AMPL model by Hande Y. Benson","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Copyright (C) 2001 Princeton University All Rights Reserved","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that the copyright notice and this permission notice appear in all supporting documentation.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"Source: H. Maurer and H.D. Mittelman, \"The non-linear beam via optimal control with bound state variables\", Optimal Control Applications and Methods 12, pp. 19-31, 1991.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"using JuMP\nimport Ipopt\n\nfunction example_clnlbeam()\n    N = 1000\n    h = 1/N\n    alpha = 350\n    model = Model(Ipopt.Optimizer)\n    @variables(model, begin\n           -1 <= t[1:(N + 1)] <= 1\n        -0.05 <= x[1:(N + 1)] <= 0.05\n                 u[1:(N + 1)]\n    end)\n    @NLobjective(\n        model,\n        Min,\n        sum(\n            0.5 * h * (u[i + 1]^2 + u[i]^2) +\n            0.5 * alpha * h * (cos(t[i + 1]) + cos(t[i]))\n            for i = 1:N\n        ),\n    )\n    @NLconstraint(\n        model,\n        [i = 1:N],\n        x[i + 1] - x[i] - 0.5 * h * (sin(t[i + 1]) + sin(t[i])) == 0,\n    )\n    @constraint(\n        model,\n        [i = 1:N],\n        t[i + 1] - t[i] - 0.5 * h * u[i + 1] - 0.5 * h * u[i] == 0,\n    )\n    optimize!(model)\n    println(\"\"\"\n    termination_status = $(termination_status(model))\n    primal_status      = $(primal_status(model))\n    objective_value    = $(objective_value(model))\n    \"\"\")\n    return\nend\n\nexample_clnlbeam()","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/clnlbeam/","page":"The clnlbeam problem","title":"The clnlbeam problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Optimization concepts/benders_lazy_constraints.jl\"","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#benders_decomposition_lazy","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Originally Contributed by: Mathieu Besan√ßon","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This notebook describes how to implement the Benders decomposition in JuMP using lazy constraints. We keep the same notation and problem form as the first notebook Benders decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"For a detailed explanation on the Benders decomposition algorithm, see the introduction notebook.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Lazy-constraints","page":"Benders Decomposition (Lazy Constraints)","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Some optimization solvers allow users to interact with them during the solution process by providing user-defined functions which are triggered under certain conditions.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"The generic term for these functions is callback.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"In integer optimization, the main callback types are lazy constraints, user-cuts and heuristic solutions. See the Callbacks section for an introduction on how to use them.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Some callbacks define a new constraint which is only activated when necessary, i.e., when a current solution does not respect them. It can avoid building an optimization model with too many constraints up-front.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This is the case for Benders decomposition, since the sub-problem defines an exponential number of primal vertices and therefore dual cuts.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"A detailed explanation on the distinction between user-cuts and lazy constraints is also available on Paul Rubin's blog. He also describes this approach to Benders Decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"We use the data from the original notebook and change the solution algorithm to leverage lazy constraints:","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Step 1 (Initialization)\nStep 2 (defining the subproblem model)\nStep 3 (registering the lazy constraint of the subproblem)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Data-for-the-problem","page":"Benders Decomposition (Lazy Constraints)","title":"Data for the problem","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [1 -3;\n     -1 -3]\nA2 = [1 -2;\n     -1 -1]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Loading-the-necessary-packages","page":"Benders Decomposition (Lazy Constraints)","title":"Loading the necessary packages","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Subproblem creation","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"function build_subproblem()\n    sub_problem_model = Model(GLPK.Optimizer)\n    @variable(sub_problem_model, u[1:dim_u] >= 0)\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    return (sub_problem_model, u)\nend","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#Master-Problem-Description","page":"Benders Decomposition (Lazy Constraints)","title":"Master Problem Description","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"master_problem_model = Model(GLPK.Optimizer);\n\n(sub_problem_model, u) = build_subproblem();\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Variable Definition","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Objective Setting","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"@objective(master_problem_model, Max, t)\n\nprint(master_problem_model)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Track the calls to the callback","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"iter_num = 0","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Define lazy constraints","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"function benders_lazy_constraint_callback(cb_data)\n    global iter_num\n    iter_num += 1\n    println(\"Iteration number = \", iter_num)\n\n    x_current = callback_value.(Ref(cb_data), x)\n    fm_current = callback_value(cb_data, t)\n\n    c_sub = b - A1 * x_current\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n    optimize!(sub_problem_model)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    Œ≥ = b' * u_current\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current  ‚âà  fm_current # we are done\n        @info(\"No additional constraint from the subproblem\")\n    end\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current < fm_current\n        println(\"\\nThere is a suboptimal vertex, add the corresponding constraint\")\n        cv = A1' * u_current - c1\n        new_optimality_cons = @build_constraint(t + cv' * x <= Œ≥)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_optimality_cons,\n        )\n    end\n\n    if t_status_sub == MOI.INFEASIBLE_OR_UNBOUNDED\n        println(\"\\nThere is an  extreme ray, adding the corresponding constraint\")\n        ce = A1' * u_current\n        new_feasibility_cons = @build_constraint(dot(ce, x) <= Œ≥)\n        MOI.submit(\n            master_problem_model,\n            MOI.LazyConstraint(cb_data),\n            new_feasibility_cons,\n        )\n    end\nend\n\nMOI.set(\n    master_problem_model,\n    MOI.LazyConstraintCallback(),\n    benders_lazy_constraint_callback,\n)\n\noptimize!(master_problem_model)\n\nt_status = termination_status(master_problem_model)\np_status = primal_status(master_problem_model)\n\nif p_status == MOI.INFEASIBLE_POINT\n    println(\"The problem is infeasible :-(\")\nend\n\nif t_status == MOI.INFEASIBLE_OR_UNBOUNDED\n    fm_current = M\n    x_current = M * ones(dim_x)\nend\n\nif p_status == MOI.FEASIBLE_POINT\n    fm_current = value(t)\n    x_current = value.(x)\nend\n\nTest.@test value(t) ‚âà -4 #hide\n\nprintln(\"Status of the master problem is \", t_status,\n        \"\\nwith fm_current = \", fm_current,\n        \"\\nx_current = \", x_current)","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/#References","page":"Benders Decomposition (Lazy Constraints)","title":"References","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"View this file on Github.","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"","category":"page"},{"location":"tutorials/Optimization concepts/benders_lazy_constraints/","page":"Benders Decomposition (Lazy Constraints)","title":"Benders Decomposition (Lazy Constraints)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/finance.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Finance","page":"Finance","title":"Finance","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"In this tutorial we will discuss two such examples taken from the book Optimization Methods in Finance.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Short-Term-Financing","page":"Finance","title":"Short Term Financing","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Corporations routinely face the problem of financing short term cash commitments such as the following:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Month Jan Feb Mar Apr May Jun\nNet Cash Flow -150 -100 200 -200 50 300","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Net cash flow requirements are given in thousands of dollars. The company has the following sources of funds:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"A line of credit of up to $100K at an interest rate of 1% per month,\nIn any one of the first three months, it can issue 90-day commercial paper bearing a total interest of 2% for the 3-month period,\nExcess funds can be invested at an interest rate of 0.3% per month.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Our task is to find out the most economical way to use these 3 sources such that we end up with the most amount of money at the end of June.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We model this problem in the following manner:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We will use the following decision variables:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"the amount u_i drawn from the line of credit in month i\nthe amount v_i of commercial paper issued in month i\nthe excess funds w_i in month i","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Here we have three types of constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"for every month, cash inflow = cash outflow for each month\nupper bounds on u_i\nnonnegativity of the decision variables u_i, v_i and w_i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Our objective will be to simply maximize the company's wealth in June, which say we represent with the variable m.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"financing = Model(GLPK.Optimizer)\n\n@variables(financing, begin\n    0 <= u[1:5] <= 100\n    0 <= v[1:3]\n    0 <= w[1:5]\n    m\nend)\n\n@objective(financing, Max, m)\n\n@constraints(financing, begin\n    u[1] + v[1] - w[1] == 150 # January\n    u[2] + v[2] - w[2] - 1.01u[1] + 1.003w[1] == 100 # February\n    u[3] + v[3] - w[3] - 1.01u[2] + 1.003w[2] == -200 # March\n    u[4] - w[4] - 1.02v[1] - 1.01u[3] + 1.003w[3] == 200 # April\n    u[5] - w[5] - 1.02v[2] - 1.01u[4] + 1.003w[4] == -50 # May\n    -m - 1.02v[3] - 1.01u[5] + 1.003w[5] == -300 # June\nend)\n\noptimize!(financing)\n\nobjective_value(financing)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/#Combinatorial-Auctions","page":"Finance","title":"Combinatorial Auctions","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"In many auctions, the value that a bidder has for a set of items may not be the sum of the values that he has for individual items.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Examples are equity trading, electricity markets, pollution right auctions and auctions for airport landing slots.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"To take this into account, combinatorial auctions allow the bidders to submit bids on combinations of items.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Let M=12 ldots m be the set of items that the auctioneer has to sell. A bid is a pair B_j=left(S_j p_jright) where S_j subseteq M is a nonempty set of items and p_j is the price offer for this set.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"Suppose that the auctioneer has received n bids B_1 B_2 ldots B_n The goal of this problem is to help an auctioneer determine the winners in order to maximize his revenue.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"We model this problem by taking a decision variable y_j for every bid. We add a constraint that each item i is sold at most once. This gives us the following model:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"beginaligned\nmax  sum_i=1^n p_j y_j \ntext  st    sum_j  i in S_j y_j leq 1  forall i=12 ldots m \n y_j in01  forall j in12 ldots n\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"bid_values = [6 3 12 12 8 16]\nbid_items = [[1], [2], [3 4], [1 3], [2 4], [1 3 4]]\n\nauction = Model(GLPK.Optimizer)\n@variable(auction, y[1:6], Bin)\n@objective(auction, Max, sum(y' .* bid_values))\nfor i in 1:6\n    @constraint(auction, sum(y[j] for j in 1:6 if i in bid_items[j]) <= 1)\nend\n\noptimize!(auction)\n\nobjective_value(auction)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"value.(y)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/finance/","page":"Finance","title":"Finance","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/prod.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/#The-workforce-scheduling-problem","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This model determines a set of workforce levels that will most economically meet demands and inventory requirements over time. The formulation is motivated by the experiences of a large producer in the United States. The data are for three products and 13 periods.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Problem taken from the Appendix C of the expanded version of Fourer, Gay, and Kernighan, A Modeling Language for Mathematical Programming","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_prod(; verbose = true)\n    # PRODUCTION SETS AND PARAMETERS\n    prd = [\"18REG\"  \"24REG\" \"24PRO\"]\n    # Members of the product group\n    numprd = length(prd)\n    pt =\t[1.194,\t1.509,\t1.509]\n    # Crew-hours to produce 1000 units\n    pc =\t[2304,\t2920,\t2910]\n    # Nominal production cost per 1000, used\n    # to compute inventory and shortage costs\n    #\n    # TIME PERIOD SETS AND PARAMETERS\n    firstperiod = 1\n    # Index of first production period to be modeled\n    lastperiod  = 13\n    # Index of last production period to be modeled\n    numperiods = firstperiod:lastperiod\n    # 'planning horizon' := first..last;\n    # EMPLOYMENT PARAMETERS\n    # Workers per crew\n    cs = 18\n    # Regular-time hours per shift\n    sl =  8\n    # Wage per hour for regular-time labor\n    rtr = 16.00\n    # Wage per hour for overtime labor\n    otr = 43.85\n    # Crews employed at start of first period\n    iw =  8\n    # Regular working days in a production period\n    dpp =\t [19.5,\t19,\t20,\t19,\t19.5,\t19,\t19,\t20,\t19,\t20,\t20,\t18,\t18]\n    # Maximum crew-hours of overtime in a period\n    ol =\t [96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96,\t96]\n    # Lower limit on average employment in a period\n    cmin =\t[0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0]\n    # Upper limit on average employment in a period\n    cmax =\t[8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8,\t8]\n    # Penalty cost of hiring a crew\n    hc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # Penalty cost of laying off a crew\n    lc =\t [7500,\t7500,\t7500,\t7500,\t15000,\t15000,\t15000,\t15000,\t15000,\t15000,\t7500,\t7500,\t7500]\n    # DEMAND PARAMETERS\n    d18REG = [63.8,\t76,\t88.4,\t913.8,\t115,\t133.8,\t79.6,\t111,\t121.6,\t470,\t78.4,\t99.4,\t140.4,\t63.8]\n    d24REG = [1212,\t306.2,\t319,\t208.4,\t298,\t328.2,\t959.6,\t257.6,\t335.6,\t118,\t284.8,\t970,\t343.8,\t1212]\n    d24PRO = [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1102,\t0,\t0,\t0,\t0]\n    # Requirements (in 1000s) to be met from current production and inventory\n    dem = Array[d18REG, d24REG, d24PRO]\n    # true if product will be the subject of a special promotion in the period\n    pro = Array[\n        [0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n        [1,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0,\t0,\t1,\t1],\n        [0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t0,\t1,\t0,\t0,\t0,\t0],\n    ]\n    # INVENTORY AND SHORTAGE PARAMETERS\n    # Proportion of non-promoted demand that must be in inventory the previous\n    # period\n    rir = 0.75\n    # Proportion of promoted demand that must be in inventory the previous\n    # period\n    pir = 0.80\n    # Upper limit on number of periods that any product may sit in inventory\n    life = 2\n    # Inventory cost per 1000 units is cri times nominal production cost\n    cri\t= [0.015,\t0.015,\t0.015]\n    # Shortage cost per 1000 units is crs times nominal production cost\n    crs\t= [1.1,\t1.1,\t1.1]\n    # Inventory at start of first period; age unknown\n    iinv = [82,\t792.2,\t0]\n    # Initial inventory still available for allocation at end of period t\n    iil = [\n        [\n            max(0, iinv[p] - sum(dem[p][v] for v in firstperiod:t))\n            for t in numperiods\n        ]\n        for p in 1:numprd\n    ]\n    # Lower limit on inventory at end of period t\n    function checkpro(\n        product, timeperiod, production, promotionalrate, regularrate\n    )\n        if production[product][timeperiod + 1] == 1\n            return promotionalrate\n        else\n            return regularrate\n        end\n    end\n    minv = [\n        [dem[p][t + 1] * checkpro(p, t, pro, pir, rir) for t in numperiods]\n        for p in 1:numprd\n    ]\n    # DEFINE MODEL\n    prod = Model(GLPK.Optimizer)\n    # VARIABLES\n    # Average number of crews employed in each period\n    @variable(prod, Crews[0:lastperiod] >= 0)\n    # Crews hired from previous to current period\n    @variable(prod, Hire[numperiods] >= 0)\n    # Crews laid off from previous to current period\n    @variable(prod, Layoff[numperiods]>= 0)\n    # Production using regular-time labor, in 1000s\n    @variable(prod, Rprd[1:numprd, numperiods] >= 0)\n    # Production using overtime labor, in 1000s\n    @variable(prod, Oprd[1:numprd, numperiods]>= 0)\n    # a numperiods old -- produced in period (t+1)-a --\n    # and still in storage at the end of period t\n    @variable(prod, Inv[1:numprd, numperiods, 1:life] >= 0)\n    # Accumulated unsatisfied demand at the end of period t\n    @variable(prod, Short[1:numprd, numperiods] >= 0)\n    # CONSTRAINTS\n    # Hours needed to accomplish all regular-time production in a period must\n    # not exceed hours available on all shifts\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Rprd[p, t] for p in 1:numprd) <= sl * dpp[t] * Crews[t]\n    )\n    # Hours needed to accomplish all overtime production in a period must not\n    # exceed the specified overtime limit\n    @constraint(\n        prod,\n        [t = numperiods],\n        sum(pt[p] * Oprd[p, t] for p in 1:numprd)  <= ol[t]\n    )\n    # Use given initial workforce\n    @constraint(prod, Crews[firstperiod - 1] == iw)\n    # Workforce changes by hiring or layoffs\n    @constraint(\n        prod, [t in numperiods], Crews[t] == Crews[t - 1] + Hire[t] - Layoff[t]\n    )\n    # Workforce must remain within specified bounds\n    @constraint(prod, [t in numperiods], cmin[t] <= Crews[t])\n    @constraint(prod, [t in numperiods], Crews[t] <= cmax[t])\n    # 'first demand requirement\n    @constraint(\n        prod,\n        [p in 1:numprd],\n        Rprd[p, firstperiod] + Oprd[p, firstperiod] + Short[p, firstperiod] -\n            Inv[p, firstperiod, 1] == max(0, dem[p][firstperiod] - iinv[p])\n    )\n    # Production plus increase in shortage plus decrease in inventory must\n    # equal demand\n    for t in (firstperiod + 1):lastperiod\n        @constraint(\n            prod,\n            [p in 1:numprd],\n            Rprd[p, t] + Oprd[p, t] + Short[p,t] - Short[p,t-1] +\n                sum(Inv[p, t - 1, a] - Inv[p, t, a] for a in 1:life) ==\n                max(0, dem[p][t] - iil[p][t - 1])\n        )\n    end\n    # Inventory in storage at end of period t must meet specified minimum\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        sum(Inv[p, t, a] + iil[p][t] for a in 1:life) >= minv[p][t]\n    )\n    # In the vth period (starting from first) no inventory may be more than v\n    # numperiods old (initial inventories are handled separately)\n    @constraint(\n        prod,\n        [p in 1:numprd, v in 1:(life - 1), a in (v + 1):life],\n        Inv[p, firstperiod + v - 1, a] == 0\n    )\n    # New inventory cannot exceed production in the most recent period\n    @constraint(\n        prod,\n        [p in 1:numprd, t in numperiods],\n        Inv[p, t, 1] <= Rprd[p, t] + Oprd[p, t]\n    )\n    # Inventory left from period (t+1)-p can only decrease as time goes on\n    secondperiod = firstperiod + 1\n    @constraint(\n        prod,\n        [p in 1:numprd, t in 2:lastperiod, a in 2:life],\n        Inv[p, t, a] <= Inv[p, t - 1, a - 1]\n    )\n    # OBJECTIVE\n    # Full regular wages for all crews employed, plus penalties for hiring and\n    # layoffs, plus wages for any overtime worked, plus inventory and shortage\n    # costs. (All other production costs are assumed to depend on initial\n    # inventory and on demands, and so are not included explicitly.)\n    @objective(\n        prod,\n        Min,\n        sum(\n            rtr * sl * dpp[t] * cs * Crews[t] +\n            hc[t] * Hire[t] +\n            lc[t] * Layoff[t] +\n            sum(\n                otr * cs * pt[p] * Oprd[p, t] +\n                sum(cri[p] * pc[p] * Inv[p, t, a] for a in 1:life) +\n                crs[p] * pc[p] * Short[p, t]\n                for p in 1:numprd\n            )\n           for t in numperiods\n        )\n    )\n    # Obtain solution\n    optimize!(prod)\n    Test.@test termination_status(prod) == MOI.OPTIMAL\n    Test.@test primal_status(prod) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(prod) ‚âà 4_426_822.89 atol = 1e-2\n    if verbose\n        println(\"RESULTS:\")\n        println(\"Crews\")\n        for t = 0:length(Crews.data) - 1\n            print(\" $(value(Crews[t])) \")\n        end\n        println()\n        println(\"Hire\")\n        for t = 1:length(Hire.data)\n            print(\" $(value(Hire[t])) \")\n        end\n        println()\n        println(\"Layoff\")\n        for t = 1:length(Layoff.data)\n            print(\" $(value(Layoff[t])) \")\n        end\n        println()\n    end\n    return\nend\n\nexample_prod()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/prod/","page":"The workforce scheduling problem","title":"The workforce scheduling problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/constraints/#ConstraintAPI","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"More information can be found in the Constraints section of the manual.","category":"page"},{"location":"reference/constraints/#Macros","page":"Constraints","title":"Macros","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"@constraint\n@constraints\n@SDconstraint\n@SDconstraints\nConstraintRef\nAbstractConstraint\nScalarConstraint\nVectorConstraint","category":"page"},{"location":"reference/constraints/#JuMP.@constraint","page":"Constraints","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MOI.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ‚â•, >=, ‚â§ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ‚â§ b ‚â§ c or a ‚â• b ‚â• c (where ‚â§ and <= (resp. ‚â• and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@constraints","page":"Constraints","title":"JuMP.@constraints","text":"@constraints(model, args...)\n\nAdds groups of constraints at once, in the same fashion as the @constraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@constraints(model, begin\n    x >= 1\n    y - w <= 2\n    sum_to_one[i=1:3], z[i] + y == 1\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraint","page":"Constraints","title":"JuMP.@SDconstraint","text":"@SDconstraint(model::Model, expr)\n\nAdd a semidefinite constraint described by the expression expr.\n\n@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of semidefinite constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr needs to be of the form a sign b where sign is ‚™∞, ‚â•, >=, ‚™Ø, ‚â§ or <= and a and b are square matrices. It constrains the square matrix x (or -x if the sign is ‚™Ø, ‚â§ or <=) to be symmetric and positive semidefinite where\n\nx = a, if b is the symbol 0,\nx = -b, if a is the symbol 0,\notherwise, x = a - b.\n\nBy default, we check numerical symmetry of the matrix x, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use Symmetric(x) in PSDCone() with the @constraint macro to skip these checks if you know the matrix must be symmetric; see PSDCone for more information.\n\nExamples\n\nThe following constrains the matrix [x-1 2x-2; -3 x-4] to be symmetric and positive semidefinite, that is, it constrains 2x-2 to be equal to -3 and constrains all eigenvalues of the matrix to be nonnegative.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [x 2x\n            0  x];\n\njulia> b = [1 2\n            3 4];\n\njulia> cref = @SDconstraint(model, a ‚™∞ b)\n[x - 1  2 x - 2;\n -3     x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n -3\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nIn the set PositiveSemidefiniteConeSquare(2) in the last output, Square means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set PositiveSemidefiniteConeTriangle exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see PSDCone to see how to use it.\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.@SDconstraints","page":"Constraints","title":"JuMP.@SDconstraints","text":"@SDconstraints(model, args...)\n\nAdds multiple semi-definite constraints to model at once, in the same fashion as the @SDconstraint macro.\n\nThe model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@SDconstraints(model, begin\n    A * x >= b\n    b - C * y >= 0\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/constraints/#JuMP.ConstraintRef","page":"Constraints","title":"JuMP.ConstraintRef","text":"ConstraintRef\n\nHolds a reference to the model and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.AbstractConstraint","page":"Constraints","title":"JuMP.AbstractConstraint","text":"abstract type AbstractConstraint\n\nAn abstract base type for all constraint types. AbstractConstraints store the function and set directly, unlike ConstraintRefs that are merely references to constraints stored in a model. AbstractConstraints do not need to be attached to a model.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.ScalarConstraint","page":"Constraints","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.VectorConstraint","page":"Constraints","title":"JuMP.VectorConstraint","text":"struct VectorConstraint\n\nThe data for a vector constraint. The func field contains a JuMP object representing the function and the set field contains the MOI set. The shape field contains an AbstractShape matching the form in which the constraint was constructed (e.g., by using matrices or flat vectors). See also the documentation on JuMP's representation of constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Names","page":"Constraints","title":"Names","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"name(::ConstraintRef{Model,<:JuMP._MOICON})\nset_name(::ConstraintRef{Model,<:JuMP._MOICON}, ::String)\nconstraint_by_name","category":"page"},{"location":"reference/constraints/#JuMP.name-Tuple{ConstraintRef{Model,#s938,Shape} where Shape<:AbstractShape where #s938<:MathOptInterface.ConstraintIndex}","page":"Constraints","title":"JuMP.name","text":"name(con_ref::ConstraintRef)\n\nGet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.set_name-Tuple{ConstraintRef{Model,#s938,Shape} where Shape<:AbstractShape where #s938<:MathOptInterface.ConstraintIndex,String}","page":"Constraints","title":"JuMP.set_name","text":"set_name(con_ref::ConstraintRef, s::AbstractString)\n\nSet a constraint's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_by_name","page":"Constraints","title":"JuMP.constraint_by_name","text":"constraint_by_name(model::AbstractModel,\n                   name::String)::Union{ConstraintRef, Nothing}\n\nReturn the reference of the constraint with name attribute name or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(model::AbstractModel,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{ConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set. This method is recommended if you know the type of the function and set since its returned type can be inferred while for the method above (i.e. without F and S), the exact return type of the constraint index cannot be inferred.\n\njulia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x^2 == 1)\ncon : x¬≤ = 1.0\n\njulia> constraint_by_name(model, \"kon\")\n\njulia> constraint_by_name(model, \"con\")\ncon : x¬≤ = 1.0\n\njulia> constraint_by_name(model, \"con\", AffExpr, MOI.EqualTo{Float64})\n\njulia> constraint_by_name(model, \"con\", QuadExpr, MOI.EqualTo{Float64})\ncon : x¬≤ = 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Modification","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"normalized_coefficient\nset_normalized_coefficient\n\nnormalized_rhs\nset_normalized_rhs\n\nadd_to_function_constant","category":"page"},{"location":"reference/constraints/#JuMP.normalized_coefficient","page":"Constraints","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef)\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also set_normalized_coefficient.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_coefficient","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(con_ref::ConstraintRef, variable::VariableRef, value)\n\nSet the coefficient of variable in the constraint constraint to value.\n\nNote that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, con, 2x + 3x <= 2)\nset_normalized_coefficient(con, x, 4)\ncon\n\n# output\n\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.normalized_rhs","page":"Constraints","title":"JuMP.normalized_rhs","text":"normalized_rhs(con_ref::ConstraintRef)\n\nReturn the right-hand side term of con_ref after JuMP has converted the constraint into its normalized form. See also set_normalized_rhs.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.set_normalized_rhs","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(con_ref::ConstraintRef, value)\n\nSet the right-hand side term of constraint to value.\n\nNote that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.add_to_function_constant","page":"Constraints","title":"JuMP.add_to_function_constant","text":"add_to_function_constant(constraint::ConstraintRef, value)\n\nAdd value to the function constant term.\n\nNote that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1.\n\nExamples\n\nFor scalar constraints, the set is translated by -value:\n\njulia> @constraint(model, con, 0 <= 2x - 1 <= 2)\ncon : 2 x ‚àà [1.0, 3.0]\n\njulia> add_to_function_constant(con, 4)\n\njulia> con\ncon : 2 x ‚àà [-3.0, -1.0]\n\nFor vector constraints, the constant is added to the function:\n\njulia> @constraint(model, con, [x + y, x, y] in SecondOrderCone())\ncon : [x + y, x, y] ‚àà MathOptInterface.SecondOrderCone(3)\n\njulia> add_to_function_constant(con, [1, 2, 2])\n\njulia> con\ncon : [x + y + 1, x + 2, y + 2] ‚àà MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Deletion","page":"Constraints","title":"Deletion","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"JuMP.delete\nis_valid\nConstraintNotOwned","category":"page"},{"location":"reference/constraints/#JuMP.delete","page":"Constraints","title":"JuMP.delete","text":"delete(model::Model, con_ref::ConstraintRef)\n\nDelete the constraint associated with constraint_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, con_refs::Vector{<:ConstraintRef})\n\nDelete the constraints associated with con_refs from the model model. Solvers may implement specialized methods for deleting multiple constraints of the same concrete type, i.e., when isconcretetype(eltype(con_refs)). These may be more efficient than repeatedly calling the single constraint delete method.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\nSee also: unregister\n\n\n\n\n\ndelete(model::Model, variable_refs::Vector{VariableRef})\n\nDelete the variables associated with variable_refs from the model model. Solvers may implement methods for deleting multiple variables that are more efficient than repeatedly calling the single variable delete method.\n\nSee also: unregister\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.is_valid","page":"Constraints","title":"JuMP.is_valid","text":"is_valid(model::Model, con_ref::ConstraintRef{<:AbstractModel})\n\nReturn true if constraint_ref refers to a valid constraint in model.\n\n\n\n\n\nis_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.ConstraintNotOwned","page":"Constraints","title":"JuMP.ConstraintNotOwned","text":"struct ConstraintNotOwned{C <: ConstraintRef} <: Exception\n    constraint_ref::C\nend\n\nThe constraint constraint_ref was used in a model different to owner_model(constraint_ref).\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#Query-constraints","page":"Constraints","title":"Query constraints","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"list_of_constraint_types\nall_constraints\nnum_constraints\nindex(::ConstraintRef)\noptimizer_index(::ConstraintRef{Model})\nconstraint_object","category":"page"},{"location":"reference/constraints/#JuMP.list_of_constraint_types","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(model::Model)::Vector{Tuple{DataType, DataType}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(model, F, S) returns a nonempty list.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.ZeroOne)\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.all_constraints","page":"Constraints","title":"JuMP.all_constraints","text":"all_constraints(model::Model, function_type, set_type)::Vector{<:ConstraintRef}\n\nReturn a list of all constraints currently in the model where the function has type function_type and the set has type set_type. The constraints are ordered by creation time.\n\nSee also list_of_constraint_types and num_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x ‚â• 0.0\n\njulia> all_constraints(model, VariableRef, MOI.ZeroOne)\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.ZeroOne},ScalarShape},1}:\n x binary\n\njulia> all_constraints(model, AffExpr, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n 2 x ‚â§ 1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.num_constraints","page":"Constraints","title":"JuMP.num_constraints","text":"num_constraints(model::Model, function_type, set_type)::Int64\n\nReturn the number of constraints currently in the model where the function has type function_type and the set has type set_type.\n\nSee also list_of_constraint_types and all_constraints.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x >= 0, Bin);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, y in MOI.GreaterThan(1.0));\n\njulia> @constraint(model, y <= 1.0);\n\njulia> @constraint(model, 2x <= 1);\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> num_constraints(model, VariableRef, MOI.ZeroOne)\n1\n\njulia> num_constraints(model, AffExpr, MOI.LessThan{Float64})\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.index-Tuple{ConstraintRef}","page":"Constraints","title":"JuMP.index","text":"index(cr::ConstraintRef)::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.optimizer_index-Tuple{ConstraintRef{Model,C,Shape} where Shape<:AbstractShape where C}","page":"Constraints","title":"JuMP.optimizer_index","text":"optimizer_index(cr::ConstraintRef{Model})::MOI.ConstraintIndex\n\nReturn the index of the constraint that corresponds to cr in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached or if the constraint is bridged.\n\n\n\n\n\n","category":"method"},{"location":"reference/constraints/#JuMP.constraint_object","page":"Constraints","title":"JuMP.constraint_object","text":"constraint_object(con_ref::ConstraintRef)\n\nReturn the underlying constraint data for the constraint referenced by ref.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Start-values","page":"Constraints","title":"Start values","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"set_dual_start_value\ndual_start_value","category":"page"},{"location":"reference/constraints/#JuMP.set_dual_start_value","page":"Constraints","title":"JuMP.set_dual_start_value","text":"set_dual_start_value(con_ref::ConstraintRef, value)\n\nSet the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref to value. To remove a dual start value set it to nothing.\n\nSee also dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.dual_start_value","page":"Constraints","title":"JuMP.dual_start_value","text":"dual_start_value(con_ref::ConstraintRef)\n\nReturn the dual start value (MOI attribute ConstraintDualStart) of the constraint con_ref.\n\nNote: If no dual start value has been set, dual_start_value will return nothing.\n\nSee also set_dual_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Special-sets","page":"Constraints","title":"Special sets","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"SecondOrderCone\nRotatedSecondOrderCone\nPSDCone\nSOS1\nSOS2\nSkewSymmetricMatrixSpace\nSkewSymmetricMatrixShape\nmoi_set","category":"page"},{"location":"reference/constraints/#JuMP.SecondOrderCone","page":"Constraints","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MOI.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ‚àà MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.RotatedSecondOrderCone","page":"Constraints","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MOI.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ‚àà MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.PSDCone","page":"Constraints","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ‚™∞ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS1","page":"Constraints","title":"JuMP.SOS1","text":"SOS1\n\nSOS1 (Special Ordered Sets type 1) object than can be used to constrain a vector x to a set where at most 1 variable can take a non-zero value, all others being at 0. The weights, when specified, induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS1 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SOS2","page":"Constraints","title":"JuMP.SOS2","text":"SOS2\n\nSOS1 (Special Ordered Sets type 2) object than can be used to constrain a vector x to a set where at most 2 variables can take a non-zero value, all others being at 0. In addition, if two are non-zero these must be consecutive in their ordering. The weights induce an ordering of the variables; as such, they should be unique values. The kth element in the set corresponds to the kth weight in weights. See here for a description of SOS constraints and their potential uses. This is a shortcut for the MathOptInterface.SOS2 set.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixSpace","page":"Constraints","title":"JuMP.SkewSymmetricMatrixSpace","text":"SkewSymmetricMatrixSpace()\n\nUse in the @variable macro to constrain a matrix of variables to be skew-symmetric.\n\nExamples\n\n@variable(model, Q[1:2, 1:2] in SkewSymmetricMatrixSpace())\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.SkewSymmetricMatrixShape","page":"Constraints","title":"JuMP.SkewSymmetricMatrixShape","text":"SkewSymmetricMatrixShape\n\nShape object for a skew symmetric square matrix of side_dimension rows and columns. The vectorized form contains the entries of the upper-right triangular part of the matrix (without the diagonal) given column by column (or equivalently, the entries of the lower-left triangular part given row by row). The diagonal is zero.\n\n\n\n\n\n","category":"type"},{"location":"reference/constraints/#JuMP.moi_set","page":"Constraints","title":"JuMP.moi_set","text":"moi_set(constraint::AbstractConstraint)\n\nReturn the set of the constraint constraint in the function-in-set form as a MathOptInterface.AbstractSet.\n\nmoi_set(s::AbstractVectorSet, dim::Int)\n\nReturns the MOI set of dimension dim corresponding to the JuMP set s.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#Printing","page":"Constraints","title":"Printing","text":"","category":"section"},{"location":"reference/constraints/","page":"Constraints","title":"Constraints","text":"function_string\nconstraints_string\nin_set_string\nshow_constraints_summary","category":"page"},{"location":"reference/constraints/#JuMP.function_string","page":"Constraints","title":"JuMP.function_string","text":"function_string(print_mode::Type{<:JuMP.PrintMode},\n                func::Union{JuMP.AbstractJuMPScalar,\n                            Vector{<:JuMP.AbstractJuMPScalar}})\n\nReturn a String representing the function func using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.constraints_string","page":"Constraints","title":"JuMP.constraints_string","text":"constraints_string(print_mode, model::AbstractModel)::Vector{String}\n\nReturn a list of Strings describing each constraint of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.in_set_string","page":"Constraints","title":"JuMP.in_set_string","text":"in_set_string(print_mode::Type{<:PrintMode}, set)\n\nReturn a String representing the membership to the set set using print mode print_mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/constraints/#JuMP.show_constraints_summary","page":"Constraints","title":"JuMP.show_constraints_summary","text":"show_constraints_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the number of constraints.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/callbacks.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"This example uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"using JuMP\nimport GLPK\nimport Random","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a lazy constraint callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_lazy_constraint()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        println(\"Called from (x, y) = ($x_val, $y_val)\")\n        status = callback_node_status(cb_data, model)\n        if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n            println(\" - Solution is integer infeasible!\")\n        elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            println(\" - Solution is integer feasible!\")\n        else\n            @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n            println(\" - I don't know if the solution is integer feasible :(\")\n        end\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)\n    optimize!(model)\n    println(\"Optimal solution (x, y) = ($(value(x)), $(value(y)))\")\n    return\nend\n\nexample_lazy_constraint()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#User-cut","page":"Callbacks","title":"User-cut","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a user-cut callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_user_cut_constraint()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        accumulated = sum(item_weights[i] for i = 1:N if x_vals[i] > 1e-4)\n        println(\"Called with accumulated = $(accumulated)\")\n        n_terms = sum(1 for i = 1:N if x_vals[i] > 1e-4)\n        if accumulated > 10\n            con = @build_constraint(\n                sum(x[i] for i = 1:N if x_vals[i] > 0.5) <= n_terms - 1\n            )\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.UserCut(cb_data), con)\n        end\n    end\n    MOI.set(model, MOI.UserCutCallback(), my_callback_function)\n    optimize!(model)\n    @show callback_called\n    return\nend\n\nexample_user_cut_constraint()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#HeuristicCallback","page":"Callbacks","title":"HeuristicCallback","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using a heuristic solution callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_heuristic_solution()\n    Random.seed!(1)\n    N = 30\n    item_weights, item_values = rand(N), rand(N)\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:N], Bin)\n    @constraint(model, sum(item_weights[i] * x[i] for i = 1:N) <= 10)\n    @objective(model, Max, sum(item_values[i] * x[i] for i = 1:N))\n    callback_called = false\n    function my_callback_function(cb_data)\n        callback_called = true\n        x_vals = callback_value.(Ref(cb_data), x)\n        ret = MOI.submit(\n            model, MOI.HeuristicSolution(cb_data), x, floor.(x_vals)\n        )\n        println(\"Heuristic solution status = $(ret)\")\n    end\n    MOI.set(model, MOI.HeuristicCallback(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_heuristic_solution()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/#GLPK-solver-dependent-callback","page":"Callbacks","title":"GLPK solver-dependent callback","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"An example using GLPK's solver-dependent callback.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"function example_solver_dependent_callback()\n    model = Model(GLPK.Optimizer)\n    @variable(model, 0 <= x <= 2.5, Int)\n    @variable(model, 0 <= y <= 2.5, Int)\n    @objective(model, Max, y)\n    lazy_called = false\n    function my_callback_function(cb_data)\n        lazy_called = true\n        reason = GLPK.glp_ios_reason(cb_data.tree)\n        println(\"Called from reason = $(reason)\")\n        if reason != GLPK.GLP_IROWGEN\n            return\n        end\n        x_val = callback_value(cb_data, x)\n        y_val = callback_value(cb_data, y)\n        if y_val - x_val > 1 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        elseif y_val + x_val > 3 + 1e-6\n            con = @build_constraint(y - x <= 1)\n            println(\"Adding $(con)\")\n            MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n        end\n    end\n    MOI.set(model, GLPK.CallbackFunction(), my_callback_function)\n    optimize!(model)\n    return\nend\n\nexample_solver_dependent_callback()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/rocket_control.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Rocket-Control","page":"Rocket Control","title":"Rocket Control","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This tutorial shows how to solve a nonlinear rocketry control problem. The problem was drawn from the COPS3 benchmark.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is to maximize the final altitude of a vertically launched rocket.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Let us consider the basic description of the model (for the full description, including parameters for the rocket, see the COPS3 PDF)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Overview","page":"Rocket Control","title":"Overview","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will use a discretized model of time, with a fixed number of time steps, n.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will make the time step size Delta t, and thus the final time t_f = n cdot Delta t, a variable in the problem. To approximate the derivatives in the problem we will use the trapezoidal rule.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#State-and-Control","page":"Rocket Control","title":"State and Control","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We will have three state variables:","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Velocity, v\nAltitude, h\nMass of rocket and remaining fuel, m","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and a single control variable, thrust T.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Our goal is thus to maximize h(t_f).","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Each of these corresponds to a JuMP variable indexed by the time step.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Dynamics","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"We have three equations that control the dynamics of the rocket:","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: h^prime = v Acceleration: v^prime = fracT - D(hv)m - g(h) Rate of mass loss: m^prime = -fracTc","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"where drag D(hv) is a function of altitude and velocity, and gravity g(h) is a function of altitude.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"These forces are defined as","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"D(hv) = D_c v^2 expleft( -h_c left( frach-h(0)h(0) right) right)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"and g(h) = g_0 left( frach(0)h right)^2","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The three rate equations correspond to JuMP constraints, and for convenience we will represent the forces with nonlinear expressions.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"using JuMP\nimport Ipopt\nimport Plots","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Create JuMP model, using Ipopt as the solver","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"rocket = Model(Ipopt.Optimizer)\nset_silent(rocket)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Constants","page":"Rocket Control","title":"Constants","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Note that all parameters in the model have been normalized to be dimensionless. See the COPS3 paper for more info.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"h_0 = 1    # Initial height\nv_0 = 0    # Initial velocity\nm_0 = 1    # Initial mass\ng_0 = 1    # Gravity at the surface\n\nT_c = 3.5  # Used for thrust\nh_c = 500  # Used for drag\nv_c = 620  # Used for drag\nm_c = 0.6  # Fraction of initial mass left at end\n\nc     = 0.5 * sqrt(g_0 * h_0)  # Thrust-to-fuel mass\nm_f   = m_c * m_0              # Final mass\nD_c   = 0.5 * v_c * m_0 / g_0  # Drag scaling\nT_max = T_c * g_0 * m_0        # Maximum thrust\n\nn = 800    # Time steps","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Decision-variables","page":"Rocket Control","title":"Decision variables","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@variables(rocket, begin\n    Œît ‚â• 0, (start = 1/n) # Time step\n    # State variables\n    v[1:n] ‚â• 0            # Velocity\n    h[1:n] ‚â• h_0          # Height\n    m_f ‚â§ m[1:n] ‚â§ m_0    # Mass\n    # Control variables\n    0 ‚â§ T[1:n] ‚â§ T_max    # Thrust\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Objective","page":"Rocket Control","title":"Objective","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"The objective is to maximize altitude at end of time of flight.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@objective(rocket, Max, h[n])","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Initial-conditions","page":"Rocket Control","title":"Initial conditions","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"fix(v[1], v_0; force = true)\nfix(h[1], h_0; force = true)\nfix(m[1], m_0; force = true)\nfix(m[n], m_f; force = true)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Forces","page":"Rocket Control","title":"Forces","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"@NLexpressions(rocket, begin\n    # Drag(h,v) = Dc v^2 exp( -hc * (h - h0) / h0 )\n    drag[j = 1:n], D_c * (v[j]^2) * exp(-h_c * (h[j] - h_0) / h_0)\n    # Grav(h)   = go * (h0 / h)^2\n    grav[j = 1:n], g_0 * (h_0 / h[j])^2\n    # Time of flight\n    t_f, Œît * n\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Dynamics-2","page":"Rocket Control","title":"Dynamics","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"for j in 2:n\n    # h' = v\n    # Rectangular integration\n    # @NLconstraint(rocket, h[j] == h[j - 1] + Œît * v[j - 1])\n    # Trapezoidal integration\n    @NLconstraint(rocket, h[j] == h[j - 1] + 0.5 * Œît * (v[j] + v[j - 1]))\n    # v' = (T-D(h,v))/m - g(h)\n    # Rectangular integration\n    # @NLconstraint(\n    #     rocket,\n    #     v[j] == v[j - 1] + Œît *((T[j - 1] - drag[j - 1]) / m[j - 1] - grav[j - 1])\n    # )\n    # Trapezoidal integration\n    @NLconstraint(\n        rocket,\n        v[j] == v[j-1] +\n            0.5 * Œît * (\n                (T[j] - drag[j] - m[j] * grav[j]) / m[j] +\n                (T[j - 1] - drag[j - 1] - m[j - 1] * grav[j - 1]) / m[j - 1]\n            )\n    )\n    # m' = -T/c\n    # Rectangular integration\n    # @NLconstraint(rocket, m[j] == m[j - 1] - Œît * T[j - 1] / c)\n    # Trapezoidal integration\n    @NLconstraint(rocket, m[j] == m[j - 1] - 0.5 * Œît * (T[j] + T[j-1]) / c)\nend","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"Solve for the control and state","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Solving...\")\nstatus = optimize!(rocket)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/#Display-results","page":"Rocket Control","title":"Display results","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"println(\"Max height: \", objective_value(rocket))","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"function my_plot(y, ylabel)\n    return Plots.plot(\n        (1:n) * value.(Œît),\n        value.(y)[:];\n        xlabel = \"Time (s)\",\n        ylabel = ylabel,\n    )\nend\n\nPlots.plot(\n    my_plot(h, \"Altitude\"),\n    my_plot(m, \"Mass\"),\n    my_plot(v, \"Velocity\"),\n    my_plot(T, \"Thrust\");\n    layout = (2, 2),\n    legend = false,\n    margin = 1Plots.cm,\n)","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/rocket_control/","page":"Rocket Control","title":"Rocket Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"info: Info\nInstallation troubles? Check the Common installation issues section below.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP is a package for Julia. To use JuMP, first download and install Julia.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nThis version of JuMP is compatible with Julia 1.0 and later.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"From Julia, JuMP is installed using the built-in package manager:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWe recommend you create a Pkg environment for each project you use JuMP for, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"installation/#Installing-a-solver","page":"Installation Guide","title":"Installing a solver","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMP depends on solvers to solve optimization problems, and you will need to install one before you can solve problems with JuMP. The table below lists the currently available solvers.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Install a solver using the Julia package manager, replacing \"Clp\" by the Julia package name as appropriate.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Clp\")","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Once installed, you can use Clp as a solver with JuMP as follows, using set_optimizer_attributes to set solver-specific options:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using JuMP\nusing Clp\nmodel = Model(Clp.Optimizer)\nset_optimizer_attributes(model, \"LogLevel\" => 1, \"PrimalTolerance\" => 1e-7)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nMost packages follow the ModuleName.Optimizer naming convention, but exceptions may exist. See the README of the Julia package's Github repository for more details on how to use a particular solver, including any solver-specific options.","category":"page"},{"location":"installation/#Supported-solvers","page":"Installation Guide","title":"Supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Most solvers are not written in Julia, and some require commercial licenses to use, so installation is often more complex.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If a solver has Manual in the Installation column, the solver requires a manual installation step, such as downloading and installing a binary, or obtaining a commercial license. Consult the README of the relevant Julia package for more information.\nIf the solver has Manual·¥π in the Installation column, the solver requires an installation of MATLAB.\nIf the Installation column is missing an entry, installing the Julia package will download and install any relevant solver binaries automatically, and you shouldn't need to do anything other than Pkg.add.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solvers with a missing entry in the Julia Package column are written in Julia. The link in the Solver column is the corresponding Julia package.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Solver Julia Package Installation License Supports\nAlpine.jl   Triad NS (MI)NLP\nArtelys Knitro KNITRO.jl Manual Comm. (MI)LP, (MI)SOCP, (MI)NLP\nBARON BARON.jl Manual Comm. (MI)NLP\nCbc Cbc.jl  EPL (MI)LP\nCDCS CDCS.jl Manual·¥π GPL LP, SOCP, SDP\nCDD CDDLib.jl  GPL LP\nClp Clp.jl  EPL LP\nCOSMO.jl   Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Manual Comm. (MI)LP, (MI)SOCP\nCSDP CSDP.jl  EPL LP, SDP\nEAGO.jl   MIT NLP\nECOS ECOS.jl  GPL LP, SOCP\nFICO Xpress Xpress.jl Manual Comm. (MI)LP, (MI)SOCP\nGLPK GLPK.jl  GPL (MI)LP\nGurobi Gurobi.jl Manual Comm. (MI)LP, (MI)SOCP\nHiGHS HiGHS.jl  MIT LP\nHypatia.jl   MIT LP, SOCP, SDP\nIpopt Ipopt.jl  EPL LP, QP, NLP\nJuniper.jl   MIT (MI)SOCP, (MI)NLP\nMOSEK MosekTools.jl Manual Comm. (MI)LP, (MI)SOCP, SDP\nNLopt NLopt.jl  GPL LP, QP, NLP\nOSQP OSQP.jl  Apache LP, QP\nPATH PATHSolver.jl  MIT MCP\nPavito.jl   MPL-2 (MI)NLP\nProxSDP.jl   MIT LP, SOCP, SDP\nSCIP SCIP.jl  ZIB (MI)LP, (MI)NLP\nSCS SCS.jl  MIT LP, SOCP, SDP\nSDPA SDPA.jl, SDPAFamily.jl  GPL LP, SDP\nSDPNAL SDPNAL.jl Manual·¥π CC BY-SA LP, SDP\nSDPT3 SDPT3.jl Manual·¥π GPL LP, SOCP, SDP\nSeDuMi SeDuMi.jl Manual·¥π GPL LP, SOCP, SDP\nTulip.jl   MPL-2 LP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Where:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex quadratic constraints and/or objective)\nMCP = Mixed-complementarity programming\nNLP = Nonlinear programming\nSDP = Semidefinite programming\n(MI)XXX = Mixed-integer equivalent of problem type XXX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloped a solver or solver wrapper? This table is open for new contributions! Start by making a pull request to edit the installation.md file.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nDeveloping a solver or solver wrapper? See Models and the MathOptInterface docs for more details on how JuMP interacts with solvers. Please get in touch via the Developer Chatroom with any questions about connecting new solvers with JuMP.","category":"page"},{"location":"installation/#Solver-specific-notes","page":"Installation Guide","title":"Solver-specific notes","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Artelys Knitro","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"BARON","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license. A trial version is available for small problem instances.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CDD can solve the problem both using Float64 and Rational{BigInt} arithmetics. The arithmetic used the type T given in CDDLib.Optimizer{T}. Only CDDLib.Optimizer{Float64} can be used with JuMP as JuMP inputs the problem in Float64 arithmetics. Use MOI directly for CDDLib.Optimizer{Rational{BigInt}}.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COIN-OR Cbc","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Cbc supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"COSMO can solve LPs, QPs, SOCPs and SDPs. It can handle SDPs with quadratic objective functions and supports chordal decomposition of large structured PSD constraints. COSMO is a first order method that performs well on large problems but has a low accuracy by default (10^4). See the COSMO.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"CPLEX","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of CPLEX with a license (free for faculty members and graduate teaching assistants). CPLEX supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ECOS can be used by JuMP to solve LPs and SOCPs. ECOS does not support general quadratic objectives or constraints, only second-order conic constraints specified by using the SecondOrderCone set.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Gurobi","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Gurobi with an activated license (free for academic use). Gurobi supports \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"FICO Xpress","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a working installation of Xpress with an active license (it is possible to get a license for academic use, see FICO Academic Partner Program). Supports SOCP and \"SOS\" constraints.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"MOSEK","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Requires a license (free for academic use). The Mosek interface is maintained by the Mosek team. (Thanks!) Note that even if the package implementing MathOptInterface is MosekTools, for consistency the MOI optimizer is called Mosek.Optimizer so do the following to create a model with the Mosek solver:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"using MosekTools\nmodel = Model(Mosek.Optimizer)","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"ProxSDP solves general SDP problems by means of a first order proximal algorithm based on the primal-dual hybrid gradient, also known as Chambolle-Pock method. The main advantage of ProxSDP over other state-of-the-art solvers is the ability to exploit the low-rank property inherent to several SDP problems. ProxSDP is a first order solver and has low accuracy. See the ProxSDP.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SCS can be used by JuMP to solve LPs and SOCPs, and SDPs. SCS is a first order solver and has low accuracy (10^4) by default; see the SCS.jl documentation for more information.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"SDPA is a second order solver which comes in several variants. The main version has a C++ interface which SDPA.jl uses for efficiently communicating the problem instance to the solver. The three high-precision variants, SDPA-GMP (arbitrary precision), SDPA-QD (\"quad-double\" precision) and SDPA-DD (\"double-double\" precision) do not expose a library interface, but can used via SDPAFamily.jl, which writes and reads files to interact with the solver binary.","category":"page"},{"location":"installation/#AMPL-and-GAMS","page":"Installation Guide","title":"AMPL and GAMS","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Use GAMS.jl to access solvers available through GAMS. Such solvers include: AlphaECP, Antigone, BARON, CONOPT, Couenne, LocalSolver, PATHNLP, SHOT, SNOPT, SoPlex. See a complete list here.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"note: Note\nGAMS.jl requires an installation of the commercial software GAMS for which a free community license exists.","category":"page"},{"location":"installation/#Previously-supported-solvers","page":"Installation Guide","title":"Previously supported solvers","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The following solvers were compatible with JuMP up to release 0.18 but are not yet compatible with the latest version because they do not implement the new MathOptInterface API:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Pajarito","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Please join the Developer Chatroom if you have interest in reviving a previously supported solver.","category":"page"},{"location":"installation/#Common-installation-issues","page":"Installation Guide","title":"Common installation issues","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nWhen in doubt, run import Pkg; Pkg.update() to see if updating your packages fixes the issue. Remember you will need to exit Julia and start a new session for the changes to take effect.","category":"page"},{"location":"installation/#Check-the-version-of-your-packages","page":"Installation Guide","title":"Check the version of your packages","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Each package is versioned with a three-part number of the form vX.Y.Z. You can check which versions you have installed with import Pkg; Pkg.status().","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This should almost always be the most-recent release. You can check the releases of a package by going to the relevant Github page, and navigating to the \"releases\" page. For example, the list of JuMP releases is available at: https://github.com/jump-dev/JuMP.jl/releases.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"If you post on the community forum, please include the output of Pkg.status()!","category":"page"},{"location":"installation/#Unsatisfiable-requirements-detected","page":"Installation Guide","title":"Unsatisfiable requirements detected","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Did you get an error like Unsatisfiable requirements detected for package JuMP? The Pkg documentation has a section on how to understand and manage these conflicts.","category":"page"},{"location":"installation/#Installing-new-packages-can-make-JuMP-downgrade-to-an-earlier-version","page":"Installation Guide","title":"Installing new packages can make JuMP downgrade to an earlier version","text":"","category":"section"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"Another common complaint is that after adding a new package, code that previously worked no longer works.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"This usually happens because the new package is not compatible with the latest version of JuMP. Therefore, the package manager rolls-back JuMP to an earlier version! Here's an example.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"First, we add JuMP:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMP\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] + JuMP v0.21.5\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"The + JuMP v0.21.5 line indicates that JuMP has been added at version 0.21.5. However, watch what happens when we add JuMPeR:","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"(jump_example) pkg> add JuMPeR\n  Resolving package versions...\nUpdating `~/jump_example/Project.toml`\n  [4076af6c] ‚Üì JuMP v0.21.5 ‚áí v0.18.6\n  [707a9f91] + JuMPeR v0.6.0\nUpdating `~/jump_example/Manifest.toml`\n  ... lines omitted ...","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"JuMPeR gets added at version 0.6.0 (+ JuMPeR v0.6.0), but JuMP gets downgraded from 0.21.5 to 0.18.6 (‚Üì JuMP v0.21.5 ‚áí v0.18.6)! The reason for this is that JuMPeR doesn't support a version of JuMP newer than 0.18.6.","category":"page"},{"location":"installation/","page":"Installation Guide","title":"Installation Guide","text":"tip: Tip\nPay careful attention to the output of the package manager when adding new packages, especially when you see a package being downgraded!","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Conic programs/logistic_regression.jl\"","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Logistic-Regression","page":"Logistic Regression","title":"Logistic Regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Originally Contributed by: Fran√ßois Pacaud","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"This tutorial shows how to solve a logistic regression problem with JuMP. Logistic regression is a well known method in machine learning, useful when we want to classify binary variables with the help of a given set of features. To this goal, we find the optimal combination of features maximizing the (log)-likelihood onto a training set. From a modern optimization glance, the resulting problem is convex and differentiable. On a modern optimization glance, it is even conic representable.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Formulating-the-logistic-regression-problem","page":"Logistic Regression","title":"Formulating the logistic regression problem","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Suppose we have a set of training data-point i = 1 cdots n, where for each i we have a vector of features x_i in mathbbR^p and a categorical observation y_i in -1 1.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"The log-likelihood is given by","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"l(theta) = sum_i=1^n log(dfrac11 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"and the optimal theta minimizes the logistic loss function:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i))","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Most of the time, instead of solving directly the previous optimization problem, we prefer to add a regularization term:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"min_theta sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta ","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"with lambda in mathbbR_+ a penalty and  a norm function. By adding such a regularization term, we avoid overfitting on the training set and usually achieve a greater score in cross-validation.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Reformulation-as-a-conic-optimization-problem","page":"Logistic Regression","title":"Reformulation as a conic optimization problem","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"By introducing auxiliary variables t_1 cdots t_n and r, the optimization problem is equivalent to","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_t r theta  sum_i=1^n t_i + lambda r \ntextsubject to   quad t_i geq log(1 + exp(- y_i theta^top x_i)) \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Now, the trick is to reformulate the constraints t_i geq log(1 + exp(- y_i theta^top x_i)) with the help of the exponential cone","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"K_exp =  (x y z) in mathbbR^3   y exp(x  y) leq z  ","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Indeed, by passing to the exponential, we see that for all i=1 cdots n, the constraint t_i geq log(1 + exp(- y_i theta^top x_i)) is equivalent to","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"exp(-t_i) + exp(u_i - t_i) leq 1","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"with u_i = -y_i theta^top x_i. Then, by adding two auxiliary variables z_i1 and z_i2 such that z_i1 geq exp(u_i-t_i) and z_i2 geq exp(-t_i), we get the equivalent formulation","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"left\nbeginaligned\n(u_i -t_i  1 z_i1)  in  K_exp  \n(-t_i  1 z_i2)  in  K_exp  \nz_i1 + z_i2  leq  1\nendaligned\nright","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"In this setting, the conic version of the logistic regression problems writes out","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_t z r theta   sum_i=1^n t_i + lambda r \ntextsubject to   quad  (u_i -t_i  1 z_i1)  in  K_exp  \n                    quad  (-t_i  1 z_i2)  in  K_exp  \n                    quad  z_i1 + z_i2  leq  1 \n                    quad u_i = -y_i x_i^top theta \n                    quad r geq theta\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"and thus encompasses 3n + p + 1 variables and 3n + 1 constraints (u_i = -y_i theta^top x_i is only a virtual constraint used to clarify the notation). Thus, if n gg 1, we get a large number of variables and constraints.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Fitting-logistic-regression-with-a-conic-solver","page":"Logistic Regression","title":"Fitting logistic regression with a conic solver","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"It is now time to pass to the implementation. We choose SCS as a conic solver.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"using JuMP\nimport Random\nimport SCS\n\nRandom.seed!(2713);\nnothing #hide","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We start by implementing a function to generate a fake dataset, and where we could tune the correlation between the feature variables. The function is a direct transcription of the one used in this blog post.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function generate_dataset(n_samples=100, n_features=10; shift=0.0)\n    X = randn(n_samples, n_features)\n    w = randn(n_features)\n    y = sign.(X * w)\n    X .+= 0.8 * randn(n_samples, n_features) # add noise\n    X .+= shift # shift the points in the feature space\n    X = hcat(X, ones(n_samples, 1))\n    return X, y\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We write a softplus function to formulate each constraint t geq log(1 + exp(u)) with two exponential cones.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function softplus(model, t, u)\n    z = @variable(model, [1:2], lower_bound=0.0)\n    @constraint(model, sum(z) <= 1.0)\n    @constraint(model, [u - t, 1, z[1]] in MOI.ExponentialCone())\n    @constraint(model, [-t, 1, z[2]] in MOI.ExponentialCone())\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#\\ell_2-regularized-logistic-regression","page":"Logistic Regression","title":"ell_2 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Then, with the help of the softplus function, we could write our optimization model. In the ell_2 regularization case, the constraint r geq theta_2 rewrites as a second order cone constraint.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function build_logit_model(X, y, Œª)\n    n, p = size(X)\n    model = Model()\n    @variable(model, Œ∏[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = - (X[i, :]' * Œ∏) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ‚Ñì2 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; Œ∏] in MOI.SecondOrderCone(p+1))\n    # Define objective\n    @objective(model, Min, sum(t) + Œª * reg)\n    return model\nend","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We generate the dataset.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"warning: Warning\nBe careful here, for large n and p SCS could fail to converge!","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"n, p = 200, 10\nX, y = generate_dataset(n, p, shift=10.0);\n\n# We could now solve the logistic regression problem\nŒª = 10.0\nmodel = build_logit_model(X, y, Œª)\nset_optimizer(model, SCS.Optimizer)\nJuMP.optimize!(model)","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Œ∏‚ôØ = JuMP.value.(model[:Œ∏])","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"It appears that the speed of convergence is not that impacted by the correlation of the dataset, nor by the penalty lambda.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#\\ell_1-regularized-logistic-regression","page":"Logistic Regression","title":"ell_1 regularized logistic regression","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"We now formulate the logistic problem with a ell_1 regularization term. The ell_1 regularization ensures sparsity in the optimal solution of the resulting optimization problem. Luckily, the ell_1 norm is implemented as a set in MathOptInterface. Thus, we could easily formulate the sparse logistic regression problem with the help of a MOI.NormOneCone set.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"function build_sparse_logit_model(X, y, Œª)\n    n, p = size(X)\n    model = Model()\n    @variable(model, Œ∏[1:p])\n    @variable(model, t[1:n])\n    for i in 1:n\n        u = - (X[i, :]' * Œ∏) * y[i]\n        softplus(model, t[i], u)\n    end\n    # Add ‚Ñì1 regularization\n    @variable(model, 0.0 <= reg)\n    @constraint(model, [reg; Œ∏] in MOI.NormOneCone(p+1))\n    # Define objective\n    @objective(model, Min, sum(t) + Œª * reg)\n    return model\nend\n\n# Auxiliary function to count non-null components:\ncount_nonzero(v::Vector; tol=1e-6) = sum(abs.(v) .>= tol)\n\n# We solve the sparse logistic regression problem on the same dataset as before.\nŒª = 10.0\nsparse_model = build_sparse_logit_model(X, y, Œª)\nset_optimizer(sparse_model, SCS.Optimizer)\nJuMP.optimize!(sparse_model)","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"Œ∏‚ôØ = JuMP.value.(sparse_model[:Œ∏])\nprintln(\"Number of non-zero components: \", count_nonzero(Œ∏‚ôØ),\n        \" (out of \", p, \" features)\")","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/#Extensions","page":"Logistic Regression","title":"Extensions","text":"","category":"section"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"A direct extension would be to consider the sparse logistic regression with hard thresholding, which, on contrary to the soft version using a ell_1 regularization, adds an explicit cardinality constraint in its formulation:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"beginaligned\nmin_theta   sum_i=1^n log(1 + exp(-y_i theta^top x_i)) + lambda  theta _2^2 \ntextsubject to   quad  theta _0 = k\nendaligned","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"where k is the maximum number of non-zero components in the vector theta, and _0 is the ell_0 pseudo-norm:","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":" x_0 = i   x_i neq 0","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"The cardinality constraint theta_0 leq k could be reformulated with binary variables. Thus the hard sparse regression problem could be solved by any solver supporting mixed integer conic problems.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"View this file on Github.","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"","category":"page"},{"location":"tutorials/Conic programs/logistic_regression/","page":"Logistic Regression","title":"Logistic Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/n-queens.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/#N-Queens","page":"N-Queens","title":"N-Queens","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Originally Contributed by: Matthew Helm (with help from @mtanneau on Julia Discourse)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"The N-Queens problem involves placing N queens on an N x N chessboard such that none of the queens attacks another. In chess, a queen can move vertically, horizontally, and diagonally so there cannot be more than one queen on any given row, column, or diagonal.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Note that none of the queens above are able to attack any other as a result of their careful placement.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"N-Queens","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"N = 8\n\nmodel = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Next, let's create an N x N chessboard of binary values. 0 will represent an empty space on the board and 1 will represent a space occupied by one of our queens:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"@variable(model, x[1:N, 1:N], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"Now we can add our constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"There must be exactly one queen in a given row/column","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i = 1:N\n    @constraint(model, sum(x[i, :]) == 1)\n    @constraint(model, sum(x[:, i]) == 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"There can only be one queen on any given diagonal","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"for i in -(N-1):(N-1)\n    @constraint(model, sum(LinearAlgebra.diag(x, i)) <= 1)\n    @constraint(model, sum(LinearAlgebra.diag(reverse(x, dims=1), i)) <= 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"That's it! We are ready to put our model to work and see if it is able to find a feasible solution:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"optimize!(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"We can now review the solution that our model found:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"solution = convert.(Int, value.(x))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"(Image: Four Queens)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/n-queens/","page":"N-Queens","title":"N-Queens","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/solutions/#SolutionAPI","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"More information can be found in the Solutions section of the manual.","category":"page"},{"location":"reference/solutions/#Basic-utilities","page":"Solutions","title":"Basic utilities","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"JuMP.optimize!\nNoOptimizer\nOptimizeNotCalled\nsolution_summary","category":"page"},{"location":"reference/solutions/#JuMP.optimize!","page":"Solutions","title":"JuMP.optimize!","text":"optimize!(model::Model;\n          ignore_optimize_hook=(model.optimize_hook === nothing),\n          kwargs...)\n\nOptimize the model. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nKeyword arguments kwargs are passed to the optimize_hook. An error is thrown if optimize_hook is nothing and keyword arguments are provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.NoOptimizer","page":"Solutions","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided to the Model constructor or by calling set_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.OptimizeNotCalled","page":"Solutions","title":"JuMP.OptimizeNotCalled","text":"struct OptimizeNotCalled <: Exception end\n\nA result attribute cannot be queried before optimize! is called.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.solution_summary","page":"Solutions","title":"JuMP.solution_summary","text":"solution_summary(model::Model; verbose::Bool = false)\n\nReturn a struct that can be used print a summary of the solution.\n\nIf verbose=true, write out the primal solution for every variable and the dual solution for every constraint, excluding those with empty names.\n\nExamples\n\nWhen called at the REPL, the summary is automatically printed:\n\njulia> solution_summary(model)\n[...]\n\nUse print to force the printing of the summary from inside a function:\n\nfunction foo(model)\n    print(solution_summary(model))\n    return\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Termination-status","page":"Solutions","title":"Termination status","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"termination_status\nMOI.TerminationStatusCode\nraw_status\nresult_count","category":"page"},{"location":"reference/solutions/#JuMP.termination_status","page":"Solutions","title":"JuMP.termination_status","text":"termination_status(model::Model)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.TerminationStatusCode","page":"Solutions","title":"MathOptInterface.TerminationStatusCode","text":"TerminationStatusCode\n\nAn Enum of possible values for the TerminationStatus attribute. This attribute is meant to explain the reason why the optimizer stopped executing in the most recent call to optimize!.\n\nIf no call has been made to optimize!, then the TerminationStatus is:\n\nOPTIMIZE_NOT_CALLED: The algorithm has not started.\n\nOK\n\nThese are generally OK statuses, i.e., the algorithm ran to completion normally.\n\nOPTIMAL: The algorithm found a globally optimal solution.\nINFEASIBLE: The algorithm concluded that no feasible solution exists.\nDUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem. If, additionally, a feasible (primal) solution is known to exist, this status typically implies that the problem is unbounded, with some technical exceptions.\nLOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, could not find directions for improvement, or otherwise completed its search without global guarantees.\nLOCALLY_INFEASIBLE: The algorithm converged to an infeasible point or otherwise completed its search without finding a feasible solution, without guarantees that no feasible solution exists.\nINFEASIBLE_OR_UNBOUNDED: The algorithm stopped because it decided that the problem is infeasible or unbounded; this occasionally happens during MIP presolve.\n\nSolved to relaxed tolerances\n\nALMOST_OPTIMAL: The algorithm found a globally optimal solution to relaxed tolerances.\nALMOST_INFEASIBLE: The algorithm concluded that no feasible solution exists within relaxed tolerances.\nALMOST_DUAL_INFEASIBLE: The algorithm concluded that no dual bound exists for the problem within relaxed tolerances.\nALMOST_LOCALLY_SOLVED: The algorithm converged to a stationary point, local optimal solution, or could not find directions for improvement within relaxed tolerances.\n\nLimits\n\nThe optimizer stopped because of some user-defined limit.\n\nITERATION_LIMIT: An iterative algorithm stopped after conducting the maximum number of iterations.\nTIME_LIMIT: The algorithm stopped after a user-specified computation time.\nNODE_LIMIT: A branch-and-bound algorithm stopped because it explored a maximum number of nodes in the branch-and-bound tree.\nSOLUTION_LIMIT: The algorithm stopped because it found the required number of solutions. This is often used in MIPs to get the solver to return the first feasible solution it encounters.\nMEMORY_LIMIT: The algorithm stopped because it ran out of memory.\nOBJECTIVE_LIMIT: The algorithm stopped because it found a solution better than a minimum limit set by the user.\nNORM_LIMIT: The algorithm stopped because the norm of an iterate became too large.\nOTHER_LIMIT: The algorithm stopped due to a limit not covered by one of the above.\n\nProblematic\n\nThis group of statuses means that something unexpected or problematic happened.\n\nSLOW_PROGRESS: The algorithm stopped because it was unable to continue making progress towards the solution.\nNUMERICAL_ERROR: The algorithm stopped because it encountered unrecoverable numerical error.\nINVALID_MODEL: The algorithm stopped because the model is invalid.\nINVALID_OPTION: The algorithm stopped because it was provided an invalid option.\nINTERRUPTED: The algorithm stopped because of an interrupt signal.\nOTHER_ERROR: The algorithm stopped because of an error not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.raw_status","page":"Solutions","title":"JuMP.raw_status","text":"raw_status(model::Model)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.result_count","page":"Solutions","title":"JuMP.result_count","text":"result_count(model::Model)\n\nReturn the number of results available to query after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_status\nhas_values\nvalue\nMOI.ResultStatusCode","category":"page"},{"location":"reference/solutions/#JuMP.primal_status","page":"Solutions","title":"JuMP.primal_status","text":"primal_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_values","page":"Solutions","title":"JuMP.has_values","text":"has_values(model::Model; result::Int = 1)\n\nReturn true if the solver has a primal solution in result index result available to query, otherwise return false.\n\nSee also value and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.value","page":"Solutions","title":"JuMP.value","text":"value(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the primal value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nThat is, if con_ref is the reference of a constraint func-in-set, it returns the value of func evaluated at the value of the variables (given by value(::VariableRef)).\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\nNote\n\nFor scalar constraints, the constant is moved to the set so it is not taken into account in the primal value of the constraint. For instance, the constraint @constraint(model, 2x + 3y + 1 == 5) is transformed into 2x + 3y-in-MOI.EqualTo(4) so the value returned by this function is the evaluation of 2x + 3y. ```\n\n\n\n\n\nvalue(con_ref::ConstraintRef, var_value::Function)\n\nEvaluate the primal value of the constraint con_ref using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::VariableRef; result = 1)\n\nReturn the value of variable v associated with result index result of the most-recent returned by the solver.\n\nUse has_values to check if a result exists before asking for values.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::VariableRef, var_value::Function)\n\nEvaluate the value of the variable v as var_value(v).\n\n\n\n\n\nvalue(ex::GenericAffExpr, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(v::GenericAffExpr; result::Int = 1)\n\nReturn the value of the GenericAffExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(v::GenericQuadExpr; result::Int = 1)\n\nReturn the value of the GenericQuadExpr v associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\nvalue(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\nvalue(ex::NonlinearExpression, var_value::Function)\n\nEvaluate ex using var_value(v) as the value for each variable v.\n\n\n\n\n\nvalue(ex::NonlinearExpression; result::Int = 1)\n\nReturn the value of the NonlinearExpression ex associated with result index result of the most-recent solution returned by the solver.\n\nReplaces getvalue for most use cases.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.ResultStatusCode","page":"Solutions","title":"MathOptInterface.ResultStatusCode","text":"ResultStatusCode\n\nAn Enum of possible values for the PrimalStatus and DualStatus attributes. The values indicate how to interpret the result vector.\n\nNO_SOLUTION: the result vector is empty.\nFEASIBLE_POINT: the result vector is a feasible point.\nNEARLY_FEASIBLE_POINT: the result vector is feasible if some constraint tolerances are relaxed.\nINFEASIBLE_POINT: the result vector is an infeasible point.\nINFEASIBILITY_CERTIFICATE: the result vector is an infeasibility certificate. If the PrimalStatus is INFEASIBILITY_CERTIFICATE, then the primal result vector is a certificate of dual infeasibility. If the DualStatus is INFEASIBILITY_CERTIFICATE, then the dual result vector is a proof of primal infeasibility.\nNEARLY_INFEASIBILITY_CERTIFICATE: the result satisfies a relaxed criterion for a certificate of infeasibility.\nREDUCTION_CERTIFICATE: the result vector is an ill-posed certificate; see this article for details. If the PrimalStatus is REDUCTION_CERTIFICATE, then the primal result vector is a proof that the dual problem is ill-posed. If the DualStatus is REDUCTION_CERTIFICATE, then the dual result vector is a proof that the primal is ill-posed.\nNEARLY_REDUCTION_CERTIFICATE: the result satisfies a relaxed criterion for an ill-posed certificate.\nUNKNOWN_RESULT_STATUS: the result vector contains a solution with an unknown interpretation.\nOTHER_RESULT_STATUS: the result vector contains a solution with an interpretation not covered by one of the statuses defined above.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"dual_status\nhas_duals\ndual\nshadow_price\nreduced_cost","category":"page"},{"location":"reference/solutions/#JuMP.dual_status","page":"Solutions","title":"JuMP.dual_status","text":"dual_status(model::Model; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus) associated with the result index result.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.has_duals","page":"Solutions","title":"JuMP.has_duals","text":"has_duals(model::Model; result::Int = 1)\n\nReturn true if the solver has a dual solution in result index result available to query, otherwise return false.\n\nSee also dual, shadow_price, and result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual","page":"Solutions","title":"JuMP.dual","text":"dual(con_ref::ConstraintRef; result::Int = 1)\n\nReturn the dual value of constraint con_ref associated with result index result of the most-recent solution returned by the solver.\n\nUse has_dual to check if a result exists before asking for values.\n\nSee also: result_count, shadow_price.\n\n\n\n\n\ndual(c::ConstraintRef{Model,NonlinearConstraintIndex})\n\nReturn the dual of the nonlinear constraint c.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.shadow_price","page":"Solutions","title":"JuMP.shadow_price","text":"shadow_price(con_ref::ConstraintRef)\n\nReturn the change in the objective from an infinitesimal relaxation of the constraint.\n\nThis value is computed from dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\nSee also reduced_cost.\n\nNotes\n\nThe function simply translates signs from dual and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.\nThe computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.\nRelaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.reduced_cost","page":"Solutions","title":"JuMP.reduced_cost","text":"reduced_cost(x::VariableRef)::Float64\n\nReturn the reduced cost associated with variable x.\n\nEquivalent to querying the shadow price of the active variable bound (if one exists and is active).\n\nSee also: shadow_price.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Basic-attributes","page":"Solutions","title":"Basic attributes","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"objective_value\nobjective_bound\ndual_objective_value\nsolve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"reference/solutions/#JuMP.objective_value","page":"Solutions","title":"JuMP.objective_value","text":"objective_value(model::Model; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution returned by the solver.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.objective_bound","page":"Solutions","title":"JuMP.objective_bound","text":"objective_bound(model::Model)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.dual_objective_value","page":"Solutions","title":"JuMP.dual_objective_value","text":"dual_objective_value(model::Model; result::Int = 1)\n\nReturn the value of the objective of the dual problem associated with result index result of the most-recent solution returned by the solver.\n\nThrows MOI.UnsupportedAttribute{MOI.DualObjectiveValue} if the solver does not support this attribute.\n\nSee also: result_count.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.solve_time","page":"Solutions","title":"JuMP.solve_time","text":"solve_time(model::Model)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.relative_gap","page":"Solutions","title":"JuMP.relative_gap","text":"relative_gap(model::Model)\n\nReturn the final relative optimality gap after a call to optimize!(model). Exact value depends upon implementation of MathOptInterface.RelativeGap() by the particular solver used for optimization.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.simplex_iterations","page":"Solutions","title":"JuMP.simplex_iterations","text":"simplex_iterations(model::Model)\n\nGets the cumulative number of simplex iterations during the most-recent optimization.\n\nSolvers must implement MOI.SimplexIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.barrier_iterations","page":"Solutions","title":"JuMP.barrier_iterations","text":"barrier_iterations(model::Model)\n\nGets the cumulative number of barrier iterations during the most recent optimization.\n\nSolvers must implement MOI.BarrierIterations() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.node_count","page":"Solutions","title":"JuMP.node_count","text":"node_count(model::Model)\n\nGets the total number of branch-and-bound nodes explored during the most recent optimization in a Mixed Integer Program.\n\nSolvers must implement MOI.NodeCount() to use this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#ref_conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"JuMP.compute_conflict!\nMOI.compute_conflict!\nMOI.ConflictStatus\nMOI.ConflictStatusCode\nMOI.ConstraintConflictStatus\nMOI.ConflictParticipationStatusCode\nJuMP.copy_conflict","category":"page"},{"location":"reference/solutions/#JuMP.compute_conflict!","page":"Solutions","title":"JuMP.compute_conflict!","text":"compute_conflict!(model::Model)\n\nCompute a conflict if the model is infeasible. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nThe status of the conflict can be checked with the MOI.ConflictStatus model attribute. Then, the status for each constraint can be queried with the MOI.ConstraintConflictStatus attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.compute_conflict!","page":"Solutions","title":"MathOptInterface.compute_conflict!","text":"compute_conflict!(optimizer::AbstractOptimizer)\n\nComputes a minimal subset of constraints such that the model with the other constraint removed is still infeasible.\n\nSome solvers call a set of conflicting constraints an Irreducible Inconsistent Subsystem (IIS).\n\nSee also ConflictStatus and ConstraintConflictStatus.\n\nNote\n\nIf the model is modified after a call to compute_conflict!, the implementor is not obliged to purge the conflict. Any calls to the above attributes may return values for the original conflict without a warning. Similarly, when modifying the model, the conflict can be discarded.\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#MathOptInterface.ConflictStatus","page":"Solutions","title":"MathOptInterface.ConflictStatus","text":"ConflictStatus()\n\nA model attribute for the ConflictStatusCode explaining why the conflict refiner stopped when computing the conflict.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConflictStatusCode","page":"Solutions","title":"MathOptInterface.ConflictStatusCode","text":"ConflictStatusCode\n\nAn Enum of possible values for the ConflictStatus attribute. This attribute is meant to explain the reason why the conflict finder stopped executing in the most recent call to compute_conflict!.\n\nPossible values are:\n\nCOMPUTE_CONFLICT_NOT_CALLED: the function compute_conflict! has not yet been called\nNO_CONFLICT_EXISTS: there is no conflict because the problem is feasible\nNO_CONFLICT_FOUND: the solver could not find a conflict\nCONFLICT_FOUND: at least one conflict could be found\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConstraintConflictStatus","page":"Solutions","title":"MathOptInterface.ConstraintConflictStatus","text":"ConstraintConflictStatus()\n\nA constraint attribute indicating whether the constraint participates in the conflict. Its type is ConflictParticipationStatusCode.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#MathOptInterface.ConflictParticipationStatusCode","page":"Solutions","title":"MathOptInterface.ConflictParticipationStatusCode","text":"ConflictParticipationStatusCode\n\nAn Enum of possible values for the ConstraintConflictStatus attribute. This attribute is meant to indicate whether a given constraint participates or not in the last computed conflict.\n\nPossible values are:\n\nNOT_IN_CONFLICT: the constraint does not participate in the conflict\nIN_CONFLICT: the constraint participates in the conflict\nMAYBE_IN_CONFLICT: the constraint may participate in the conflict, the solver was not able to prove that the constraint can be excluded from the conflict\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.copy_conflict","page":"Solutions","title":"JuMP.copy_conflict","text":"copy_conflict(model::Model)\n\nReturn a copy of the current conflict for the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference.\n\nThis is a convenience function that provides a filtering function for copy_model.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and two constraints cref and cref2. This model has no solution, as the two constraints are mutually exclusive. The solver is asked to compute a conflict with compute_conflict!. The parts of model participating in the conflict are then copied into a model new_model.\n\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n@variable(model, x)\n@constraint(model, cref, x >= 2)\n@constraint(model, cref2, x <= 1)\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\nnew_model, reference_map = copy_conflict(model)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Sensitivity","page":"Solutions","title":"Sensitivity","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"lp_sensitivity_report\nSensitivityReport\nlp_objective_perturbation_range\nlp_rhs_perturbation_range","category":"page"},{"location":"reference/solutions/#JuMP.lp_sensitivity_report","page":"Solutions","title":"JuMP.lp_sensitivity_report","text":"lp_sensitivity_report(model::Model; atol::Float64 = 1e-8)::SensitivityReport\n\nGiven a linear program model with a current optimal basis, return a SensitivityReport object, which maps:\n\nEvery variable reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the objective coefficient of the corresponding variable can change by, such that the original basis remains optimal.\nEvery constraint reference to a tuple (d_lo, d_hi)::Tuple{Float64,Float64}, explaining how much the right-hand side of the corresponding constraint can change by, such that the basis remains optimal.\n\nBoth tuples are relative, rather than absolute. So given a objective coefficient of 1.0 and a tuple (-0.5, 0.5), the objective coefficient can range between 1.0 - 0.5 an 1.0 + 0.5.\n\natol is the primal/dual optimality tolerance, and should match the tolerance of the solver used to compute the basis.\n\nNote: interval constraints are NOT supported.\n\nExample\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, -1 <= x <= 2)\n@objective(model, Min, x)\noptimize!(model)\nreport = lp_sensitivity_report(model; atol = 1e-7)\ndx_lo, dx_hi = report[x]\nprintln(\n    \"The objective coefficient of `x` can decrease by $dx_lo or \" *\n    \"increase by $dx_hi.\"\n)\nc = LowerBoundRef(x)\ndRHS_lo, dRHS_hi = report[c]\nprintln(\n    \"The lower bound of `x` can decrease by $dRHS_lo or increase \" *\n    \"by $dRHS_hi.\"\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.SensitivityReport","page":"Solutions","title":"JuMP.SensitivityReport","text":"SensitivityReport\n\nSee lp_sensitivity_report.\n\n\n\n\n\n","category":"type"},{"location":"reference/solutions/#JuMP.lp_objective_perturbation_range","page":"Solutions","title":"JuMP.lp_objective_perturbation_range","text":"lp_objective_perturbation_range(var::VariableRef;\n                                optimality_tolerance::Float64)\n                                ::Tuple{Float64, Float64}\n\nGives the range by which the cost coefficient can change and the current LP basis remains optimal, i.e., the reduced costs remain valid.\n\nNotes\n\nThe range denotes valid changes, Œî ‚àà [l, u], for which cost[var] += Œî do not violate the current optimality conditions.\noptimality_tolerance is the dual feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by Istv√°n Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#JuMP.lp_rhs_perturbation_range","page":"Solutions","title":"JuMP.lp_rhs_perturbation_range","text":"lp_rhs_perturbation_range(constraint::ConstraintRef;\n                          feasibility_tolerance::Float64)\n                          ::Tuple{Float64, Float64}\n\nGives the range by which the rhs coefficient can change and the current LP basis remains feasible, i.e., where the shadow prices apply.\n\nNotes\n\nThe rhs coefficient is the value right of the relation, i.e., b for the constraint when of the form a*x ‚ñ° b, where ‚ñ° is ‚â§, =, or ‚â•.\nThe range denotes valid changes, e.g., for a*x <= b + Œî, the LP basis remains feasible for all Œî ‚àà [l, u].\nfeasibility_tolerance is the primal feasibility tolerance, this should preferably match the tolerance used by the solver. The default tolerance should however apply in most situations (c.f. \"Computational Techniques of the Simplex Method\" by Istv√°n Maros, section 9.3.4).\n\n\n\n\n\n","category":"function"},{"location":"reference/solutions/#Feasibility","page":"Solutions","title":"Feasibility","text":"","category":"section"},{"location":"reference/solutions/","page":"Solutions","title":"Solutions","text":"primal_feasibility_report","category":"page"},{"location":"reference/solutions/#JuMP.primal_feasibility_report","page":"Solutions","title":"JuMP.primal_feasibility_report","text":"primal_feasibility_report(\n    model::Model,\n    point::AbstractDict{VariableRef,Float64} = _last_primal_solution(model),\n    atol::Float64 = 0.0,\n    skip_missing::Bool = false,\n)::Dict{Any,Float64}\n\nGiven a dictionary point, which maps variables to primal values, return a dictionary whose keys are the constraints with an infeasibility greater than the supplied tolerance atol. The value corresponding to each key is the respective infeasibility. Infeasibility is defined as the distance between the primal value of the constraint (see MOI.ConstraintPrimal) and the nearest point by Euclidean distance in the corresponding set.\n\nNotes\n\nIf skip_missing = true, constraints containing variables that are not in point will be ignored.\nIf skip_missing = false and a partial primal solution is provided, an error will be thrown.\nIf no point is provided, the primal solution from the last time the model was solved is used.\n\nExamples\n\njulia> model = Model();\n\njulia> @variable(model, 0.5 <= x <= 1);\n\njulia> primal_feasibility_report(model, Dict(x => 0.2))\nDict{Any,Float64} with 1 entry:\n  x ‚â• 0.5 => 0.3\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/multi.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/#The-multi-commodity-flow-problem","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"JuMP implementation of the multicommodity transportation model AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan 4-1.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"Originally contributed by Louis Luangkesorn, February 26, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_multi(; verbose = true)\n    orig = [\"GARY\", \"CLEV\", \"PITT\"]\n    dest = [\"FRA\", \"DET\", \"LAN\", \"WIN\", \"STL\", \"FRE\", \"LAF\"]\n    prod = [\"bands\", \"coils\", \"plate\"]\n    numorig = length(orig)\n    numdest = length(dest)\n    numprod = length(prod)\n    # supply(prod, orig) amounts available at origins\n    supply = [\n        400    700    800;\n        800   1600   1800;\n        200    300    300\n    ]\n    # demand(prod, dest) amounts required at destinations\n    demand = [\n        300   300   100    75   650   225   250;\n        500   750   400   250   950   850   500;\n        100   100     0    50   200   100   250\n    ]\n    # limit(orig, dest) of total units from any origin to destination\n    limit = [625.0 for j in 1:numorig, i in 1:numdest]\n    # cost(dest, orig, prod) Shipment cost per unit\n    cost = reshape([\n        [\n            [  30,   10,    8,   10,   11,   71,    6];\n            [  22,    7,   10,    7,   21,   82,   13];\n            [  19,   11,   12,   10,   25,   83,   15]\n        ];\n        [\n            [  39,   14,   11,   14,   16,   82,    8];\n            [  27,    9,   12,    9,   26,   95,   17];\n            [  24,   14,   17,   13,   28,   99,   20]\n        ];\n        [\n            [  41,   15,   12,   16,   17,   86,    8];\n            [  29,    9,   13,    9,   28,   99,   18];\n            [  26,   14,   17,   13,   31,  104,   20]\n        ]\n    ], 7, 3, 3)\n    # DECLARE MODEL\n    multi = Model(GLPK.Optimizer)\n    # VARIABLES\n    @variable(multi, trans[1:numorig, 1:numdest, 1:numprod] >= 0)\n    # OBJECTIVE\n    @objective(\n        multi,\n        Max,\n        sum(\n            cost[j, i, p] * trans[i, j, p]\n            for i in 1:numorig, j in 1:numdest, p in 1:numprod\n        )\n    )\n    # CONSTRAINTS\n    # Supply constraint\n    @constraint(\n        multi,\n        supply_con[i in 1:numorig, p in 1:numprod],\n        sum(trans[i, j, p] for j in 1:numdest) == supply[p, i]\n    )\n    # Demand constraint\n    @constraint(\n        multi,\n        demand_con[j in 1:numdest, p in 1:numprod],\n        sum(trans[i, j, p] for i in 1:numorig) == demand[p, j]\n    )\n    # Total shipment constraint\n    @constraint(\n        multi,\n        total_con[i in 1:numorig, j in 1:numdest],\n        sum(trans[i, j, p] for p in 1:numprod) - limit[i, j] <= 0\n    )\n    optimize!(multi)\n    Test.@test termination_status(multi) == MOI.OPTIMAL\n    Test.@test primal_status(multi) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(multi) == 225_700.0\n    if verbose\n        println(\"RESULTS:\")\n        for i in 1:length(orig)\n            for j in 1:length(dest)\n                for p in 1:length(prod)\n                    print(\" $(prod[p]) $(orig[i]) $(dest[j]) = $(value(trans[i, j, p]))\\t\")\n                end\n                println()\n            end\n        end\n    end\n    return\nend\n\n\nexample_multi()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/multi/","page":"The multi-commodity flow problem","title":"The multi-commodity flow problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/getting_started_with_JuMP.jl\"","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Getting-started-with-JuMP","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This tutorial is aimed at providing a quick introduction to writing JuMP code. If you're new to Julia, you should start with Getting started with Julia.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#What-is-JuMP?","page":"Getting started with JuMP","title":"What is JuMP?","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP (\"Julia for Mathematical Programming\") is an open-source modeling language that is embedded in Julia. It allows users to users formulate various classes of optimization problems (linear, mixed-integer, quadratic, conic quadratic, semidefinite, and nonlinear) with easy-to-read code. These problems can then be solved using state-of-the-art open-source and commercial solvers.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP also makes advanced optimization techniques easily accessible from a high-level language.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Installation","page":"Getting started with JuMP","title":"Installation","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"JuMP is a package for Julia. From Julia, JuMP is installed by using the built-in package manager.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"You also need to include a Julia package which provides an appropriate solver. One such solver is GLPK.Optimizer, which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"import Pkg\nPkg.add(\"GLPK\")","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"See Installation Guide for a list of other solvers you can use.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#An-example","page":"Getting started with JuMP","title":"An example","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Let's try to solve the following linear programming problem by using JuMP and GLPK. We will first look at the complete code to solve the problem and then go through it step by step.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"beginaligned\n min  12x + 20y \n textst  6x + 8y geq 100 \n  7x + 12y geq 120 \n  x geq 0 \n  y in 0 3 \nendaligned","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP\nusing GLPK\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, 0 <= y <= 3)\n@objective(model, Min, 12x + 20y)\n@constraint(model, c1, 6x + 8y >= 100)\n@constraint(model, c2, 7x + 12y >= 120)\nprint(model)\noptimize!(model)\n@show termination_status(model)\n@show primal_status(model)\n@show dual_status(model)\n@show objective_value(model)\n@show value(x)\n@show value(y)\n@show shadow_price(c1)\n@show shadow_price(c2)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/#Step-by-step","page":"Getting started with JuMP","title":"Step-by-step","text":"","category":"section"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Once JuMP is installed, to use JuMP in your programs, we just need to write:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using JuMP","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"We also need to include a Julia package which provides an appropriate solver. We want to use GLPK.Optimizer here which is provided by the GLPK.jl package.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"using GLPK","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"A model object is a container for variables, constraints, solver options, etc. Models are created with the Model function. The model can be created with an optimizer attached with default arguments by calling the constructor with the optimizer type, as follows:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"model = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Variables are modeled using @variable:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, x >= 0)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"They can have lower and upper bounds.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@variable(model, 0 <= y <= 30)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The objective is set using @objective:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@objective(model, Min, 12x + 20y)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Constraints are modeled using @constraint. Here c1 and c2 are the names of our constraint.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c1, 6x + 8y >= 100)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"@constraint(model, c2, 7x + 12y >= 120)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"print(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"To solve the optimization problem, call the [optimize!] function.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"optimize!(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"info: Info\nThe ! after optimize is just part of the name. It's nothing special. Julia has a convention that functions which mutate their arguments should end in !. A common example is push!.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now let's see what information we can query about the solution.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status tells us why the solver stopped:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"termination_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"In this case, the solver found an optimal solution. We should also check primal_status to see if the solver found a primal feasible point:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"primal_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and dual_status to see if the solver found a dual feasible point:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"dual_status(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Now we know that our solver found an optimal solution, and has a primal and a dual solution to query.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"Query the objective value using objective_value:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"objective_value(model)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"The primal solution using value:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(x)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"value(y)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"and the dual solution using shadow_price:","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c1)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"shadow_price(c2)","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"","category":"page"},{"location":"tutorials/Getting started/getting_started_with_JuMP/","page":"Getting started with JuMP","title":"Getting started with JuMP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/callbacks/#callbacks_manual","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"lazy constraints\nuser-cuts\nheuristic solutions","category":"page"},{"location":"manual/callbacks/#Available-solvers","page":"Callbacks","title":"Available solvers","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callback support is limited to a few solvers. This includes CPLEX, GLPK, and Gurobi.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nWhile JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.","category":"page"},{"location":"manual/callbacks/#Things-you-can-and-cannot-do-during-callbacks","page":"Callbacks","title":"Things you can and cannot do during callbacks","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"There is a very limited range of things you can do during a callback. Only use the functions and macros explicitly stated in this page of the documentation, or in the Callbacks example.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Using any other part of the JuMP API (e.g., adding a constraint with @constraint or modifying a variable bound with set_lower_bound) is undefined behavior, and your solver may throw an error, return an incorrect solution, or result in a segfault that aborts Julia.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"In each of the three solver-independent callbacks, there are two things you may query:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status returns an MOI.CallbackNodeStatusCode enum indicating if the current primal solution is integer feasible.\ncallback_value returns the current primal solution of a variable.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"If you need to query any other information, use a solver-dependent callback instead. Each solver supporting a solver-dependent callback has information on how to use it in the README of their Github repository.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"If you want to modify the problem in a callback, you must use a lazy constraint.","category":"page"},{"location":"manual/callbacks/#Lazy-constraints","page":"Callbacks","title":"Lazy constraints","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by Paul Rubin.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A lazy constraint callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    status = callback_node_status(cb_data, model)\n    if status == MOI.CALLBACK_NODE_STATUS_FRACTIONAL\n        # `callback_value(cb_data, x)` is not integer (to some tolerance).\n        # If, for example, your lazy constraint generator requires an\n        # integer-feasible primal solution, you can add a `return` here.\n        return\n    elseif status == MOI.CALLBACK_NODE_STATUS_INTEGER\n        # `callback_value(cb_data, x)` is integer (to some tolerance).\n    else\n        @assert status == MOI.CALLBACK_NODE_STATUS_UNKNOWN\n        # `callback_value(cb_data, x)` might be fractional or integer.\n    end\n    x_val = callback_value(cb_data, x)\n    if x_val > 2 + 1e-6\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe lazy constraint callback may be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every primal solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nOnly add a lazy constraint if your primal solution violates the constraint. Adding the lazy constraint irrespective of feasibility may result in the solver returning an incorrect solution, or lead to a large number of constraints being added, slowing down the solution process.model = Model(GLPK.Optimizer)\n@variable(model, x <= 10, Int)\n@objective(model, Max, x)\nfunction bad_callback_function(cb_data)\n    # Don't do this!\n    con = @build_constraint(x <= 2)\n    MOI.submit(model, MOI.LazyConstraint(cb_data), con)\nend\nfunction good_callback_function(cb_data)\n    if callback_value(x) > 2\n        con = @build_constraint(x <= 2)\n        MOI.submit(model, MOI.LazyConstraint(cb_data), con)\n    end\nend\nMOI.set(model, MOI.LazyConstraintCallback(), good_callback_function)","category":"page"},{"location":"manual/callbacks/#User-cuts","page":"Callbacks","title":"User cuts","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned blog post.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A user-cut callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    con = @build_constraint(x <= floor(x_val))\n    MOI.submit(model, MOI.UserCut(cb_data), con)\nend\nMOI.set(model, MOI.UserCutCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nYour user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe user-cut callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/callbacks/#Heuristic-solutions","page":"Callbacks","title":"Heuristic solutions","text":"","category":"section"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"Some heuristics take integer solutions and explore their \"local neighborhood\" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"A heuristic solution callback can be set using the following syntax:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = Model(GLPK.Optimizer)\n@variable(model, x <= 10.5, Int)\n@objective(model, Max, x)\nfunction my_callback_function(cb_data)\n    x_val = callback_value(cb_data, x)\n    status = MOI.submit(\n        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]\n    )\n    println(\"I submitted a heuristic solution, and the status was: \", status)\nend\nMOI.set(model, MOI.HeuristicCallback(), my_callback_function)","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"The third argument to submit should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.submit returns an enum that depends on whether the solver accepted the solution. The possible return codes are:","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"MOI.HEURISTIC_SOLUTION_ACCEPTED\nMOI.HEURISTIC_SOLUTION_REJECTED\nMOI.HEURISTIC_SOLUTION_UNKNOWN","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"warning: Warning\nSome solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.","category":"page"},{"location":"manual/callbacks/","page":"Callbacks","title":"Callbacks","text":"info: Info\nThe heuristic solution callback may be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at every fractional primal solution.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/expressions/#Expressions","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"JuMP has three types of expressions: affine, quadratic, and nonlinear. These expressions can be inserted into constraints or into the objective. This is particularly useful if an expression is used in multiple places in the model.","category":"page"},{"location":"manual/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"There are four ways of constructing an affine expression in JuMP: with the @expression macro, with operator overloading, with the AffExpr constructor, and with add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The recommended way to create an affine expression is via the @expression macro.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, 2x + y - 1)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"This expression can be used in the objective or added to a constraint. For example:","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"@objective(model, Min, 2 * ex - 1)\nobjective_function(model)\n\n# output\n\n4 x + 2 y - 3","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Just like variables and constraints, named expressions can also be created. For example","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x[i = 1:3])\n@expression(model, expr[i = 1:3], i * sum(x[j] for j in i:3))\nexpr\n\n# output\n\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x[1] + x[2] + x[3]\n 2 x[2] + 2 x[3]\n 3 x[3]","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/expressions/#Operator-overloading","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Expressions can also be created without macros. However, note that in some cases, this can be much slower that constructing an expression using macros.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = 2x + y - 1\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"A third way to create an affine expression is by the AffExpr constructor. The first argument is the constant term, and the remaining arguments are variable-coefficient pairs.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0, x => 2.0, y => 1.0)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The fourth way to create an affine expression is by using add_to_expression!. Compared to the operator overloading method, this approach is faster because it avoids constructing temporary objects. The @expression macro uses add_to_expression! behind-the-scenes.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = AffExpr(-1.0)\nadd_to_expression!(ex, 2.0, x)\nadd_to_expression!(ex, 1.0, y)\n\n# output\n\n2 x + y - 1","category":"page"},{"location":"manual/expressions/#Removing-zero-terms","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from an affine expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x + 1 - x)\n0 x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\n1","category":"page"},{"location":"manual/expressions/#Coefficients","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a variable in an affine expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2x + 1)\n2 x + 1\n\njulia> coefficient(ex, x)\n2.0\n\njulia> coefficient(ex, y)\n0.0","category":"page"},{"location":"manual/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Like affine expressions, there are four ways of constructing a quadratic expression in JuMP: macros, operator overloading, constructors, and add_to_expression!.","category":"page"},{"location":"manual/expressions/#Macros-2","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"The @expression macro can be used to create quadratic expressions by including quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = @expression(model, x^2 + 2 * x * y + y^2 + x + y - 1)\n\n# output\n\nx¬≤ + 2 y*x + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Operator-overloading-2","page":"Expressions","title":"Operator overloading","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Operator overloading can also be used to create quadratic expressions. The same performance warning (discussed in the affine expression section) applies.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = x^2 + 2 * x * y + y^2 + x + y - 1\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Constructors-2","page":"Expressions","title":"Constructors","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Quadratic expressions can also be created using the QuadExpr constructor. The first argument is an affine expression, and the remaining arguments are pairs, where the first term is a JuMP.UnorderedPair and the second term is the coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\naff_expr = AffExpr(-1.0, x => 1.0, y => 1.0)\nquad_expr = QuadExpr(aff_expr, UnorderedPair(x, x) => 1.0,\n                     UnorderedPair(x, y) => 2.0, UnorderedPair(y, y) => 1.0)\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#add_to_expression!-2","page":"Expressions","title":"add_to_expression!","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Finally, add_to_expression! can also be used to add quadratic terms.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\nex = QuadExpr(x + y - 1.0)\nadd_to_expression!(ex, 1.0, x, x)\nadd_to_expression!(ex, 2.0, x, y)\nadd_to_expression!(ex, 1.0, y, y)\n\n# output\n\nx¬≤ + 2 x*y + y¬≤ + x + y - 1","category":"page"},{"location":"manual/expressions/#Removing-zero-terms-2","page":"Expressions","title":"Removing zero terms","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use drop_zeros! to remove terms from a quadratic expression with a 0 coefficient.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @expression(model, ex, x^2 + x + 1 - x^2)\n0 x¬≤ + x + 1\n\njulia> drop_zeros!(ex)\n\njulia> ex\nx + 1","category":"page"},{"location":"manual/expressions/#Coefficients-2","page":"Expressions","title":"Coefficients","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Use coefficient to return the coefficient associated with a pair of variables in a quadratic expression.","category":"page"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @expression(model, ex, 2*x*y + 3*x)\n2 x*y + 3 x\n\njulia> coefficient(ex, x, y)\n2.0\n\njulia> coefficient(ex, x, x)\n0.0\n\njulia> coefficient(ex, y, x)\n2.0\n\njulia> coefficient(ex, x)\n3.0","category":"page"},{"location":"manual/expressions/#Nonlinear-expressions","page":"Expressions","title":"Nonlinear expressions","text":"","category":"section"},{"location":"manual/expressions/","page":"Expressions","title":"Expressions","text":"Nonlinear expressions can be constructed only using the @NLexpression macro and can be used only in @NLobjective, @NLconstraint, and other @NLexpressions. Moreover, quadratic and affine expressions cannot be used in the nonlinear macros. For more details, see the Nonlinear Modeling section.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/variables_constraints_objective.jl\"","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variables,-constraints,-and-objective-functions","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While the last tutorial introduced you to basics of of JuMP code, this tutorial will go in depth focusing on how to work with different parts of a JuMP program.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"using JuMP\nmodel = Model();\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-basics","page":"Variables, constraints, and objective functions","title":"Variable basics","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-bounds","page":"Variables, constraints, and objective functions","title":"Variable bounds","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"All of the variables we have created till now have had a bound. We can also create a free variable.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, free_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While creating a variable, instead of using the <= and >= syntax, we can also use the lower_bound and upper_bound keyword arguments.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, keyword_x, lower_bound = 1, upper_bound = 2)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can query whether a variable has a bound using the has_lower_bound and has_upper_bound functions. The values of the bound can be obtained using the lower_bound and upper_bound functions.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"has_upper_bound(keyword_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"upper_bound(keyword_x)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Note querying the value of a bound that does not exist will result in an error.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"try #hide\nlower_bound(free_x)\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP also allows us to change the bounds on variable. We will learn this in the problem modification tutorial.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#tutorial_variable_container","page":"Variables, constraints, and objective functions","title":"Containers","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We have already seen how to add a single variable to a model using the @variable macro. Let's now look at more ways to add variables to a JuMP model.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP provides data structures for adding collections of variables to a model. These data structures are referred to as Containers and are of three types: Arrays, DenseAxisArrays, and SparseAxisArrays.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Arrays","page":"Variables, constraints, and objective functions","title":"Arrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP arrays are created in a similar syntax to Julia arrays with the addition of specifying that the indices start with 1. If we do not tell JuMP that the indices start at 1, it will create a DenseAxisArray instead.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, a[1:2, 1:2])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"An n-dimensional variable x in R^n having a bound l preceq x preceq u (l u in R^n) is added in the following manner.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"n = 10\nl = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\nu = [10; 11; 12; 13; 14; 15; 16; 17; 18; 19]\n\n@variable(model, l[i] <= x[i = 1:n] <= u[i])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Note that while working with Containers, we can also create variable bounds depending upon the indices:","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, y[i = 1:2, j = 1:2] >= 2i + j)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#DenseAxisArrays","page":"Variables, constraints, and objective functions","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"DenseAxisArrays are used when the required indices are not one-based integer ranges. The syntax is similar except with an arbitrary vector as an index as opposed to a one-based range.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"An example where the indices are integers but do not start with one.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, z[i = 2:3, j = 1:2:3] >= 0)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Another example where the indices are an arbitrary vector.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, w[1:5,[\"red\", \"blue\"]] <= 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#SparseAxisArrays","page":"Variables, constraints, and objective functions","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"SparseAxisArrays are created when the indices do not form a rectangular set. For example, this applies when indices have a dependence upon previous indices (called triangular indexing).","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, u[i = 1:3, j = i:5])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also conditionally create variables by adding a comparison check that depends upon the named indices and is separated from the indices by a semi-colon (;).","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, v[i = 1:9; mod(i, 3) == 0])","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Variable-types","page":"Variables, constraints, and objective functions","title":"Variable types","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"The last argument to the @variable macro is usually the variable type. Here we'll look at how to specify the variable type.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Integer-variables","page":"Variables, constraints, and objective functions","title":"Integer variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Integer optimization variables are constrained to the set x in Z","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, integer_x, Int)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, integer_z, integer = true)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Binary-variables","page":"Variables, constraints, and objective functions","title":"Binary variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Binary optimization variables are constrained to the set x in 0 1.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, binary_x, Bin)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, binary_z, binary = true)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Semidefinite-variables","page":"Variables, constraints, and objective functions","title":"Semidefinite variables","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"JuMP also supports modeling with semidefinite variables. A square symmetric matrix X is positive semidefinite if all eigenvalues are nonnegative.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, psd_x[1:2, 1:2], PSD)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also impose a weaker constraint that the square matrix is only symmetric (instead of positive semidefinite) as follows:","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@variable(model, sym_x[1:2, 1:2], Symmetric)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraint-basics","page":"Variables, constraints, and objective functions","title":"Constraint basics","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"model = Model()\n@variable(model, x)\n@variable(model, y)\n@variable(model, z[1:10]);\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraint-references","page":"Variables, constraints, and objective functions","title":"Constraint references","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While calling the @constraint macro, we can also set up a constraint reference. Such a reference is useful for obtaining additional information about the constraint, such as its dual solution.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, con, x <= 4)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#tutorial_constraint_container","page":"Variables, constraints, and objective functions","title":"Containers","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"Just as we had containers for variables, JuMP also provides Arrays, DenseAxisArrays, and SparseAxisArrays for storing collections of constraints. Examples for each container type are given below.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Arrays-2","page":"Variables, constraints, and objective functions","title":"Arrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:3], i * x <= i + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#DenseAxisArrays-2","page":"Variables, constraints, and objective functions","title":"DenseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:2, j = 2:3], i * x <= j + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#SparseAxisArrays-2","page":"Variables, constraints, and objective functions","title":"SparseAxisArrays","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i = 1:2, j = 1:2; i != j], i * x <= j + 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Constraints-in-a-loop","page":"Variables, constraints, and objective functions","title":"Constraints in a loop","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can add constraints using regular Julia loops","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"for i in 1:3\n    @constraint(model, 6x + 4y >= 5i)\nend","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"or use for each loops inside the @constraint macro.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, [i in 1:3], 6x + 4y >= 5i)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also create constraints such as sum _i = 1^10 z_i leq 1","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"@constraint(model, sum(z[i] for i in 1:10) <= 1)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Objective-functions","page":"Variables, constraints, and objective functions","title":"Objective functions","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"While the recommended way to set the objective is with the @objective macro, the functions set_objective_sense and set_objective_function provide an equivalent lower-level interface.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"using GLPK\n\nmodel = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\nset_objective_sense(model, MOI.MIN_SENSE)\nset_objective_function(model, x + y)\n\noptimize!(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_value(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"To query the objective function from a model, we use the objective_sense, objective_function, and objective_function_type functions.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_sense(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_function(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_function_type(model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/#Vectorized-syntax","page":"Variables, constraints, and objective functions","title":"Vectorized syntax","text":"","category":"section"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"We can also add constraints and an objective to JuMP using vectorized linear algebra. We'll illustrate this by solving an LP in standard form i.e.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"beginaligned\n min  c^T x \n textst  A x = b \n  x succeq 0 \n  x in mathbbR^n\nendaligned","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"vector_model = Model(GLPK.Optimizer)\n\nA= [ 1 1 9  5;\n     3 5 0  8;\n     2 0 6 13]\n\nb = [7; 3; 5]\n\nc = [1; 3; 5; 2]\n\n@variable(vector_model, x[1:4] >= 0)\n@constraint(vector_model, A * x .== b)\n@objective(vector_model, Min, c' * x)\n\noptimize!(vector_model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"objective_value(vector_model)","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"","category":"page"},{"location":"tutorials/Getting started/variables_constraints_objective/","page":"Variables, constraints, and objective functions","title":"Variables, constraints, and objective functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"background/algebraic_modeling_languages/#algebraic-modeling-language","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/#What-is-an-algebraic-modeling-language?","page":"Algebraic modeling languages","title":"What is an algebraic modeling language?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"If you have taken a class in mixed-integer linear programming, you will have seen a formulation like:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       c^top x \ntextst  A x = b  \n             x ge 0  \n             x_i in mathbbZ quad forall i in mathcalI\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"where c, A, and b are appropriately sized vectors and matrices of data, and mathcalI denotes the set of variables that are integer.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Solvers expect problems in a standard form like this because it limits the types of constraints that they need to consider. This makes writing a solver much easier.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: What is a solver?\nA solver is a software package that computes solutions to one or more classes of problems.For example, GLPK is a solver for linear programming (LP) and mixed integer programming (MIP) problems. It incorporates algorithms such as the simplex method and the interior-point method.JuMP currently supports a number of open-source and commercial solvers, which can be viewed in the Supported-solvers table.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, you probably formulated problems algebraically like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       sumlimits_i = 1^n c_i x_i                   \ntextst  sumlimits_i = 1^n w_i x_i le b             \n             x_i ge 0 quad forall i = 1ldotsn          \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"info: Info\nDo you recognize this formulation? It's the knapsack problem.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Users prefer to write problems in algebraic form because it is more convenient. For example, we just used le b, even though the standard form only supported constraints of the form Ax = b.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"We could convert our knapsack problem into the standard form by adding a new slack variable x_0 like so:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"beginaligned\nmin       sumlimits_i = 1^n c_i x_i            \ntextst  x_0 + sumlimits_i = 1^n w_i x_i = b  \n             x_i ge 0 quad forall i = 0ldotsn   \n             x_i in mathbbZ quad forall i = 1ldotsn\nendaligned","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"However, as models get more complicated, this manual conversion becomes more and more error-prone.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"An algebraic modeling language is a tool that simplifies the translation between the algebraic form of the modeler, and the standard form of the solver.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Each algebraic modeling language has two main parts:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A domain specific language for the user to write down problems in algebraic form.\nA converter from the algebraic form into a standard form supported by the solver (and back again).","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-I:-writing-in-algebraic-form","page":"Algebraic modeling languages","title":"Part I: writing in algebraic form","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP provides the first part of an algebraic modeling language using the @variable, @objective, and @constraint macros.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"For example, here's how we would write the knapsack problem in JuMP:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> function algebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model()\n           @variable(model, x[1:n] >= 0, Int)\n           @objective(model, Min, sum(c[i] * x[i] for i = 1:n))\n           @constraint(model, sum(w[i] * x[i] for i = 1:n) <= b)\n           return print(model)\n       end\nalgebraic_knapsack (generic function with 1 method)\n\njulia> algebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\nMin x[1] + 2 x[2]\nSubject to\n 0.5 x[1] + 0.5 x[2] ‚â§ 1.25\n x[1] ‚â• 0.0\n x[2] ‚â• 0.0\n x[1] integer\n x[2] integer","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This formulation is compact, and it closely matches the algebraic formulation of the model we wrote out above.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Here's what the JuMP code would look like if we didn't use macros:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"julia> function nonalgebraic_knapsack(c, w, b)\n           n = length(c)\n           model = Model()\n           x = [VariableRef(model) for i = 1:n]\n           for i = 1:n\n               set_lower_bound(x[i], 0)\n               set_integer(x[i])\n               set_name(x[i], \"x[$i]\")\n           end\n           obj = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(obj, c[i], x[i])\n           end\n           set_objective(model, MOI.MIN_SENSE, obj)\n           lhs = AffExpr(0.0)\n           for i = 1:n\n               add_to_expression!(lhs, w[i], x[i])\n           end\n           con = build_constraint(error, lhs, MOI.LessThan(b))\n           add_constraint(model, con)\n           return print(model)\n       end\nnonalgebraic_knapsack (generic function with 1 method)\n\njulia> nonalgebraic_knapsack([1, 2], [0.5, 0.5], 1.25)\nMin x[1] + 2 x[2]\nSubject to\n 0.5 x[1] + 0.5 x[2] ‚â§ 1.25\n x[1] ‚â• 0.0\n x[2] ‚â• 0.0\n x[1] integer\n x[2] integer","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Hopefully you agree that the macro version is much easier to read!","category":"page"},{"location":"background/algebraic_modeling_languages/#Part-II:-talking-to-solvers","page":"Algebraic modeling languages","title":"Part II: talking to solvers","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"Now that we have the algebraic problem from the user, we need a way of communicating the problem to the solver, and a way of returning the solution from the solver back to the user.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"This is less trivial than it might seem, because each solver has a unique application programming interface (API) and data structures for representing optimization models and obtaining results.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"JuMP uses the MathOptInterface.jl package to abstract these differences between solvers.","category":"page"},{"location":"background/algebraic_modeling_languages/#What-is-MathOptInterface?","page":"Algebraic modeling languages","title":"What is MathOptInterface?","text":"","category":"section"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"MathOptInterface (MOI) is an abstraction layer designed to provide an interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like JuMP.","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"There are three main parts to MathOptInterface:","category":"page"},{"location":"background/algebraic_modeling_languages/","page":"Algebraic modeling languages","title":"Algebraic modeling languages","text":"A solver-independent API that abstracts concepts such as adding and deleting variables and constraints, setting and getting parameters, and querying results. For more information on the MathOptInterface API, read the documentation\nAn automatic rewriting system based on equivalent formulations of a constraint. For more information on this rewriting system, read the LazyBridgeOptimizer section of the manual, and our paper on arXiv.\nUtilities for managing how and when models are copied to solvers. For more information on this, read the CachingOptimizer section of the manual.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/space_shuttle_reentry_trajectory.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Space-Shuttle-Reentry-Trajectory","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"Originally Contributed by: Henrique Ferrolho","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"This tutorial demonstrates how to compute a reentry trajectory for the Space Shuttle, by formulating and solving a nonlinear programming problem. The problem was drawn from Chapter 6 of \"Practical Methods for Optimal Control and Estimation Using Nonlinear Programming\", by John T. Betts.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"tip: Tip\nThis tutorial is a more-complicated version of the Rocket Control example. If you are new to solving nonlinear programs in JuMP, you may want to start there instead.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The motion of the vehicle is defined by the following set of DAEs:","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\ndoth  = v sin gamma  \ndotphi  = fracvr cos gamma sin psi  cos theta  \ndottheta  = fracvr cos gamma cos psi  \ndotv  = -fracDm - g sin gamma  \ndotgamma  = fracLm v cos(beta) + cos gamma left ( fracvr - fracgv right )  \ndotpsi  = frac1m v cos gamma L sin(beta) + fracvr cos theta cos gamma sin psi sin theta  \nq  le q_U  \nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"where the aerodynamic heating on the vehicle wing leading edge is q = q_a q_r and the dynamic variables are","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n     h  quad textaltitude (ft)     qquad   gamma quad textflight path angle (rad) \n  phi  quad textlongitude (rad)   qquad   psi   quad textazimuth (rad)           \ntheta  quad textlatitude (rad)    qquad   alpha quad textangle of attack (rad)   \n     v  quad textvelocity (ftsec) qquad   beta  quad textbank angle (rad)\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The aerodynamic and atmospheric forces on the vehicle are specified by the following quantities (English units):","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n           D  = frac12 c_D S rho v^2                  qquad  a_0  = -020704 \n           L  = frac12 c_L S rho v^2                  qquad  a_1  =  0029244 \n           g  = mu  r^2                                   qquad  mu  =  014076539 times 10^17 \n           r  = R_e + h                                     qquad  b_0  =  007854 \n        rho  = rho_0 exp-hh_r                         qquad  b_1  = -061592  times 10^-2 \n      rho_0  = 0002378                                    qquad  b_2  =  0621408 times 10^-3 \n         h_r  = 23800                                       qquad  q_r  =  17700 sqrtrho (00001 v)^307 \n         c_L  = a_0 + a_1 hatalpha                      qquad  q_a  =  c_0 + c_1 hatalpha + c_2 hatalpha^2 + c_3 hatalpha^3 \n         c_D  = b_0 + b_1 hatalpha + b_2 hatalpha^2 qquad  c_0  =  10672181 \nhatalpha  = 180 alpha  pi                            qquad  c_1  = -019213774 times 10^-1 \n         R_e  = 20902900                                    qquad  c_2  =  021286289 times 10^-3 \n           S  = 2690                                        qquad  c_3  = -010117249 times 10^-5\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The reentry trajectory begins at an altitude where the aerodynamic forces are quite small with a weight of w = 203000 (lb) and mass m = w  g_0 (slug), where g_0 = 32174 (ft/sec^2). The initial conditions are as follows:","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"beginaligned\n     h  = 260000 text ft  qquad  v       = 25600 text ftsec \n  phi  = 0      text deg qquad  gamma  = -1    text deg    \ntheta  = 0      text deg qquad  psi    = 90    text deg\nendaligned","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"The final point on the reentry trajectory occurs at the unknown (free) time t_F, at the so-called terminal area energy management (TAEM) interface, which is defined by the conditions","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"h = 80000 text ft qquad v = 2500 text ftsec qquad gamma = -5 text deg","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"As explained in the book, our goal is to maximize the final crossrange, which is equivalent to maximizing the final latitude of the vehicle, i.e., J = theta(t_F).","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"(Image: Max crossrange shuttle reentry)","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Approach","page":"Space Shuttle Reentry Trajectory","title":"Approach","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"We will use a discretized model of time, with a fixed number of discretized points, n. The decision variables at each point are going to be the state of the vehicle and the controls commanded to it. In addition, we will also make each time step size Delta t a decision variable; that way, we can either fix the time step size easily, or allow the solver to fine-tune the duration between each adjacent pair of points. Finally, in order to approximate the derivatives of the problem dynamics, we will use either rectangular or trapezoidal integration.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"DisclaimerDo not try to actually land a Space Shuttle using this notebook! üòõ There's no mesh refinement going on, which can lead to unrealistic trajectories having position and velocity errors with orders of magnitude 10^4 ft and 10^2 ft/sec, respectively.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"using JuMP\nimport Interpolations\nimport Ipopt\n\n# Global variables\nconst w  = 203000.0  # weight (lb)\nconst g‚ÇÄ = 32.174    # acceleration (ft/sec^2)\nconst m  = w / g‚ÇÄ    # mass (slug)\n\n# Aerodynamic and atmospheric forces on the vehicle\nconst œÅ‚ÇÄ =  0.002378\nconst h·µ£ =  23800.0\nconst R‚Çë =  20902900.0\nconst Œº  =  0.14076539e17\nconst S  =  2690.0\nconst a‚ÇÄ = -0.20704\nconst a‚ÇÅ =  0.029244\nconst b‚ÇÄ =  0.07854\nconst b‚ÇÅ = -0.61592e-2\nconst b‚ÇÇ =  0.621408e-3\nconst c‚ÇÄ =  1.0672181\nconst c‚ÇÅ = -0.19213774e-1\nconst c‚ÇÇ =  0.21286289e-3\nconst c‚ÇÉ = -0.10117249e-5\n\n# Initial conditions\nconst h_s = 2.6          # altitude (ft) / 1e5\nconst œï_s = deg2rad(0)   # longitude (rad)\nconst Œ∏_s = deg2rad(0)   # latitude (rad)\nconst v_s = 2.56         # velocity (ft/sec) / 1e4\nconst Œ≥_s = deg2rad(-1)  # flight path angle (rad)\nconst œà_s = deg2rad(90)  # azimuth (rad)\nconst Œ±_s = deg2rad(0)   # angle of attack (rad)\nconst Œ≤_s = deg2rad(0)   # bank angle (rad)\nconst t_s = 1.00         # time step (sec)\n\n# Final conditions, the so-called Terminal Area Energy Management (TAEM)\nconst h_t = 0.8          # altitude (ft) / 1e5\nconst v_t = 0.25         # velocity (ft/sec) / 1e4\nconst Œ≥_t = deg2rad(-5)  # flight path angle (rad)\n\n# Number of mesh points (knots) to be used\nconst n = 503\n\n# Integration scheme to be used for the dynamics\nconst integration_rule = \"rectangular\"\nnothing #hide","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximize the performance of nonlinear solvers. For the best results, it is advised to experiment different linear solvers.For example, the linear solver MA27 is outdated and can be quite slow. MA57 is a much better alternative, especially for highly-sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"# Uncomment the lines below to pass user options to the solver\nuser_options = (\n    # \"mu_strategy\" => \"monotone\",\n    # \"linear_solver\" => \"ma27\",\n)\n\n# Create JuMP model, using Ipopt as the solver\nmodel = Model(optimizer_with_attributes(Ipopt.Optimizer, user_options...))\n\n@variables(model, begin\n               0 ‚â§ scaled_h[1:n]                # altitude (ft) / 1e5\n                          œï[1:n]                # longitude (rad)\n    deg2rad(-89) ‚â§        Œ∏[1:n] ‚â§ deg2rad(89)  # latitude (rad)\n            1e-4 ‚â§ scaled_v[1:n]                # velocity (ft/sec) / 1e4\n    deg2rad(-89) ‚â§        Œ≥[1:n] ‚â§ deg2rad(89)  # flight path angle (rad)\n                          œà[1:n]                # azimuth (rad)\n    deg2rad(-90) ‚â§        Œ±[1:n] ‚â§ deg2rad(90)  # angle of attack (rad)\n    deg2rad(-89) ‚â§        Œ≤[1:n] ‚â§ deg2rad( 1)  # bank angle (rad)\n    #        3.5 ‚â§       Œît[1:n] ‚â§ 4.5          # time step (sec)\n                         Œît[1:n] == 4.0         # time step (sec)\nend)","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"info: Info\nAbove you can find two alternatives for the Œît variables.The first one, 3.5 ‚â§ Œît[1:n] ‚â§ 4.5 (currently commented), allows some wiggle room for the solver to adjust the time step size between pairs of mesh points. This is neat because it allows the solver to figure out which parts of the flight require more dense discretization than others. (Remember, the number of discretized points is fixed, and this example does not implement mesh refinement.) However, this makes the problem more complex to solve, and therefore leads to a longer computation time.The second line, Œît[1:n] == 4.0, fixes the duration of every time step to exactly 4.0 seconds. This allows the problem to be solved faster. However, to do this we need to know beforehand that the close-to-optimal total duration of the flight is ~2009 seconds. Therefore, if we split the total duration in slices of 4.0 seconds, we know that we require n = 503 knots to discretize the whole trajectory.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"# Fix initial conditions\nfix(scaled_h[1], h_s; force=true)\nfix(       œï[1], œï_s; force=true)\nfix(       Œ∏[1], Œ∏_s; force=true)\nfix(scaled_v[1], v_s; force=true)\nfix(       Œ≥[1], Œ≥_s; force=true)\nfix(       œà[1], œà_s; force=true)\n\n# Fix final conditions\nfix(scaled_h[n], h_t; force=true)\nfix(scaled_v[n], v_t; force=true)\nfix(       Œ≥[n], Œ≥_t; force=true)\n\n# Initial guess: linear interpolation between boundary conditions\nx_s = [h_s, œï_s, Œ∏_s, v_s, Œ≥_s, œà_s, Œ±_s, Œ≤_s, t_s]\nx_t = [h_t, œï_s, Œ∏_s, v_t, Œ≥_t, œà_s, Œ±_s, Œ≤_s, t_s]\ninterp_linear = Interpolations.LinearInterpolation([1, n], [x_s, x_t])\ninitial_guess = mapreduce(transpose, vcat, interp_linear.(1:n))\nset_start_value.(all_variables(model), vec(initial_guess))\n\n# Functions to restore `h` and `v` to their true scale\n@NLexpression(model, h[j = 1:n], scaled_h[j] * 1e5)\n@NLexpression(model, v[j = 1:n], scaled_v[j] * 1e4)\n\n# Helper functions\n@NLexpression(model, c_L[j = 1:n], a‚ÇÄ + a‚ÇÅ * rad2deg(Œ±[j]))\n@NLexpression(model, c_D[j = 1:n], b‚ÇÄ + b‚ÇÅ * rad2deg(Œ±[j]) + b‚ÇÇ * rad2deg(Œ±[j])^2)\n@NLexpression(model,   œÅ[j = 1:n], œÅ‚ÇÄ * exp(-h[j] / h·µ£))\n@NLexpression(model,   D[j = 1:n], 0.5 * c_D[j] * S * œÅ[j] * v[j]^2)\n@NLexpression(model,   L[j = 1:n], 0.5 * c_L[j] * S * œÅ[j] * v[j]^2)\n@NLexpression(model,   r[j = 1:n], R‚Çë + h[j])\n@NLexpression(model,   g[j = 1:n], Œº / r[j]^2)\n\n# Motion of the vehicle as a differential-algebraic system of equations (DAEs)\n@NLexpression(model, Œ¥h[j = 1:n], v[j] * sin(Œ≥[j]))\n@NLexpression(model, Œ¥œï[j = 1:n], (v[j] / r[j]) * cos(Œ≥[j]) * sin(œà[j]) / cos(Œ∏[j]))\n@NLexpression(model, Œ¥Œ∏[j = 1:n], (v[j] / r[j]) * cos(Œ≥[j]) * cos(œà[j]))\n@NLexpression(model, Œ¥v[j = 1:n], -(D[j] / m) - g[j] * sin(Œ≥[j]))\n@NLexpression(model, Œ¥Œ≥[j = 1:n], (L[j] / (m * v[j])) * cos(Œ≤[j]) + cos(Œ≥[j]) * ((v[j] / r[j]) - (g[j] / v[j])))\n@NLexpression(model, Œ¥œà[j = 1:n], (1 / (m * v[j] * cos(Œ≥[j]))) * L[j] * sin(Œ≤[j]) + (v[j] / (r[j] * cos(Œ∏[j]))) * cos(Œ≥[j]) * sin(œà[j]) * sin(Œ∏[j]))\n\n# System dynamics\nfor j in 2:n\n    i = j - 1  # index of previous knot\n\n    if integration_rule == \"rectangular\"\n        # Rectangular integration\n        @NLconstraint(model, h[j] == h[i] + Œît[i] * Œ¥h[i])\n        @NLconstraint(model, œï[j] == œï[i] + Œît[i] * Œ¥œï[i])\n        @NLconstraint(model, Œ∏[j] == Œ∏[i] + Œît[i] * Œ¥Œ∏[i])\n        @NLconstraint(model, v[j] == v[i] + Œît[i] * Œ¥v[i])\n        @NLconstraint(model, Œ≥[j] == Œ≥[i] + Œît[i] * Œ¥Œ≥[i])\n        @NLconstraint(model, œà[j] == œà[i] + Œît[i] * Œ¥œà[i])\n    elseif integration_rule == \"trapezoidal\"\n        # Trapezoidal integration\n        @NLconstraint(model, h[j] == h[i] + 0.5 * Œît[i] * (Œ¥h[j] + Œ¥h[i]))\n        @NLconstraint(model, œï[j] == œï[i] + 0.5 * Œît[i] * (Œ¥œï[j] + Œ¥œï[i]))\n        @NLconstraint(model, Œ∏[j] == Œ∏[i] + 0.5 * Œît[i] * (Œ¥Œ∏[j] + Œ¥Œ∏[i]))\n        @NLconstraint(model, v[j] == v[i] + 0.5 * Œît[i] * (Œ¥v[j] + Œ¥v[i]))\n        @NLconstraint(model, Œ≥[j] == Œ≥[i] + 0.5 * Œît[i] * (Œ¥Œ≥[j] + Œ¥Œ≥[i]))\n        @NLconstraint(model, œà[j] == œà[i] + 0.5 * Œît[i] * (Œ¥œà[j] + Œ¥œà[i]))\n    else\n        @error \"Unexpected integration rule '$(integration_rule)'\"\n    end\nend\n\n# Objective: Maximize crossrange\n@objective(model, Max, Œ∏[n])\n\nset_silent(model)  # Hide solver's verbose output\noptimize!(model)  # Solve for the control and state\n@assert termination_status(model) == MOI.LOCALLY_SOLVED\n\n# Show final crossrange of the solution\nprintln(\"Final latitude Œ∏ = \", round(objective_value(model) |> rad2deg, digits = 2), \"¬∞\")","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/#Plotting-the-results","page":"Space Shuttle Reentry Trajectory","title":"Plotting the results","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"using Plots","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"ts = cumsum([0; value.(Œît)])[1:end-1]\nnothing #hide","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"plt_altitude = plot(ts, value.(scaled_h), legend = nothing, title = \"Altitude (100,000 ft)\")\nplt_longitude = plot(ts, rad2deg.(value.(œï)), legend = nothing, title = \"Longitude (deg)\")\nplt_latitude = plot(ts, rad2deg.(value.(Œ∏)), legend = nothing, title = \"Latitude (deg)\")\nplt_velocity = plot(ts, value.(scaled_v), legend = nothing, title = \"Velocity (1000 ft/sec)\")\nplt_flight_path = plot(ts, rad2deg.(value.(Œ≥)), legend = nothing, title = \"Flight Path (deg)\")\nplt_azimuth = plot(ts, rad2deg.(value.(œà)), legend = nothing, title = \"Azimuth (deg)\")\n\nplt = plot(plt_altitude,  plt_velocity, plt_longitude, plt_flight_path, plt_latitude,\n           plt_azimuth, layout=grid(3, 2), linewidth=2, size=(700, 700))","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"function q(h, v, a)\n    œÅ(h) = œÅ‚ÇÄ * exp(-h / h·µ£)\n    q·µ£(h, v) = 17700 * ‚àöœÅ(h) * (0.0001 * v)^3.07\n    q‚Çê(a) = c‚ÇÄ + c‚ÇÅ * rad2deg(a) + c‚ÇÇ * rad2deg(a)^2 + c‚ÇÉ * rad2deg(a)^3\n    # Aerodynamic heating on the vehicle wing leading edge\n    q‚Çê(a) * q·µ£(h, v)\nend\n\nplt_attack_angle = plot(ts[1:end-1], rad2deg.(value.(Œ±)[1:end-1]), legend=nothing, title=\"Angle of Attack (deg)\")\nplt_bank_angle = plot(ts[1:end-1], rad2deg.(value.(Œ≤)[1:end-1]), legend=nothing, title=\"Bank Angle (deg)\")\nplt_heating = plot(ts, q.(value.(scaled_h)*1e5, value.(scaled_v)*1e4, value.(Œ±)), legend=nothing, title=\"Heating (BTU/ft/ft/sec)\")\n\nplt = plot(plt_attack_angle, plt_bank_angle, plt_heating, layout=grid(3, 1), linewidth=2, size=(700, 700))","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"plt = plot(rad2deg.(value.(œï)), rad2deg.(value.(Œ∏)), value.(scaled_h),\n           linewidth=2, legend=nothing, title=\"Space Shuttle Reentry Trajectory\",\n           xlabel=\"Longitude (deg)\", ylabel=\"Latitude (deg)\", zlabel=\"Altitude (100,000 ft)\")","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/space_shuttle_reentry_trajectory/","page":"Space Shuttle Reentry Trajectory","title":"Space Shuttle Reentry Trajectory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/callbacks/#CallbackAPI","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"More information can be found in the Callbacks section of the manual.","category":"page"},{"location":"reference/callbacks/#Macros","page":"Callbacks","title":"Macros","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"@build_constraint","category":"page"},{"location":"reference/callbacks/#JuMP.@build_constraint","page":"Callbacks","title":"JuMP.@build_constraint","text":"@build_constraint(constraint_expr)\n\nConstructs a ScalarConstraint or VectorConstraint using the same machinery as @constraint but without adding the constraint to a model.\n\nConstraints using broadcast operators like x .<= 1 are also supported and will create arrays of ScalarConstraint or VectorConstraint.\n\nExamples\n\nmodel = Model();\n@variable(model, x);\n@build_constraint(2x >= 1)\n\n# output\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.GreaterThan{Float64}}(2 x, MathOptInterface.GreaterThan{Float64}(1.0))\n\n\n\n\n\n","category":"macro"},{"location":"reference/callbacks/#Callback-variable-primal","page":"Callbacks","title":"Callback variable primal","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_value\nMOI.CallbackVariablePrimal","category":"page"},{"location":"reference/callbacks/#JuMP.callback_value","page":"Callbacks","title":"JuMP.callback_value","text":"callback_value(cb_data, x::VariableRef)\n\nReturn the primal solution of a variable inside a callback.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\ncallback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})\n\nReturn the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.\n\ncb_data is the argument to the callback function, and the type is dependent on the solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/callbacks/#MathOptInterface.CallbackVariablePrimal","page":"Callbacks","title":"MathOptInterface.CallbackVariablePrimal","text":"CallbackVariablePrimal(callback_data)\n\nA variable attribute for the assignment to some primal variable's value during the callback identified by callback_data.\n\n\n\n\n\n","category":"type"},{"location":"reference/callbacks/#Callback-node-status","page":"Callbacks","title":"Callback node status","text":"","category":"section"},{"location":"reference/callbacks/","page":"Callbacks","title":"Callbacks","text":"callback_node_status\nMOI.CallbackNodeStatus\nMOI.CallbackNodeStatusCode","category":"page"},{"location":"reference/callbacks/#JuMP.callback_node_status","page":"Callbacks","title":"JuMP.callback_node_status","text":"callback_node_status(cb_data, model::Model)\n\nReturn an MOI.CallbackNodeStatusCode enum, indicating if the current primal solution available from callback_value is integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"reference/callbacks/#MathOptInterface.CallbackNodeStatus","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatus","text":"CallbackNodeStatus(callback_data)\n\nAn optimizer attribute describing the (in)feasibility of the primal solution available from CallbackVariablePrimal during a callback identified by callback_data.\n\nReturns a CallbackNodeStatusCode Enum.\n\n\n\n\n\n","category":"type"},{"location":"reference/callbacks/#MathOptInterface.CallbackNodeStatusCode","page":"Callbacks","title":"MathOptInterface.CallbackNodeStatusCode","text":"CallbackNodeStatusCode\n\nAn Enum of possible return values from calling get with CallbackNodeStatus.\n\nPossible values are:\n\nCALLBACK_NODE_STATUS_INTEGER: the primal solution available from CallbackVariablePrimal is integer feasible.\nCALLBACK_NODE_STATUS_FRACTIONAL: the primal solution available from CallbackVariablePrimal is integer infeasible.\nCALLBACK_NODE_STATUS_UNKNOWN: the primal solution available from CallbackVariablePrimal might be integer feasible or infeasible.\n\n\n\n\n\n","category":"type"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This page explains how to write various types of constraints in JuMP. Before reading further, please make sure you are familiar with JuMP models, and JuMP Variables. For nonlinear constraints, see Nonlinear Modeling instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP is based on the MathOptInterface (MOI) API. Because of this, JuMP thinks of a constraint as the restriction that the output of a function belongs to a set. For example, instead of representing a constraint a^top x le b as a less-than-or-equal-to constraint, JuMP models this as the scalar affine function a^top x belonging to the less-than set (-infty b. Thus, instead of a less-than-or-equal-to constraint, we consider this constraint to be a scalar affine -in- less than constraint. More generally, we use the shorthand function-in-set to refer to constraints composed of different types of functions and sets. In the rest of this page, we will introduce the different types of functions and sets that JuMP knows about as needed. You can read more details about this function-in-set concept in the MOI documentation.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nThe examples use MOI as an alias for the MathOptInterface module. This alias is defined by using JuMP. You may also define it in your code byimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"manual/constraints/#The-@constraint-macro","page":"Constraints","title":"The @constraint macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints are added to a JuMP model using the @constraint macro. Here is an example of how to add the constraint 2x le 1 to a JuMP model:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Wasn't that easy! Let's unpack what happened, because just like @variable there are a few subtle things going on.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The mathematical constraint 2x le 1 was added to the model.\nA Julia variable called con was created that is a reference to the constraint.\nThis Julia variable was stored in model and can be accessed by model[:con].\nJuMP set the name attribute (the one that is shown when printing) of the constraint to \"con\".","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like the Julia variables created in @variable, con can be bound to a different value. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con\ncon : 2 x <= 1.0\n\njulia> con = 1\n1\n\njulia> con\n1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"However, the reference can be retrieved by querying the model using the symbolic name:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = model[:con]\ncon : 2 x <= 1.0\n\njulia> con\ncon : 2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because the named variables and constraints are stored in the same namespace, creating a constraint with the same name as a variable or an existing constraint will result in an error. To overcome this limitation, it is possible to create anonymous constraints, just like it is possible to create Anonymous JuMP variables. This is done by dropping the second argument to @constraint:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con = @constraint(model, 2x <= 1)\n2 x <= 1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"It is also possible use different comparison operators (e.g., >= and ==) to create the following types of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x >= 1)\n2 x >= 1.0\n\njulia> @constraint(model, 2x == 1)\n2 x = 1.0\n\njulia> @constraint(model, 1 <= 2x <= 3)\n2 x ‚àà [1.0, 3.0]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that JuMP normalizes the constraints by moving all of the terms containing variables to the left-hand side, and all of the constant terms to the right-hand side. Thus, we get:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, 2x + 1 <= 4x + 4)\n-2 x <= 3.0","category":"page"},{"location":"manual/constraints/#The-@constraints-macro","page":"Constraints","title":"The @constraints macro","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Like @variables, there is a \"plural\" version of the @constraint macro:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraints(model, begin\n           2x <=  1\n            x >= -1\n       end)\n\njulia> print(model)\nFeasibility\nSubject to\n x ‚â• -1.0\n 2 x ‚â§ 1.0","category":"page"},{"location":"manual/constraints/#constraint_duality","page":"Constraints","title":"Duality","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP adopts the notion of conic duality from MOI. For linear programs, a feasible dual on a >= constraint is nonnegative and a feasible dual on a <= constraint is nonpositive. If the constraint is an equality constraint, it depends on which direction is binding.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The dual value associated with a constraint in the most recent solution can be accessed using the dual function. You can use the has_duals function to check whether the model has a dual solution available to query. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x <= 1)\ncon : x <= 1.0\n\njulia> has_duals(model)\nfalse","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\n    model = Model(() -> MOIU.MockOptimizer(\n                            MOIU.Model{Float64}(),\n                            eval_objective_value = false,\n                            eval_variable_constraint_dual = false));\n    @variable(model, x);\n    @constraint(model, con, x <= 1);\n    @objective(model, Max, -2x);\n    optimize!(model);\n    mock = backend(model).optimizer.model;\n    MOI.set(mock, MOI.TerminationStatus(), MOI.OPTIMAL)\n    MOI.set(mock, MOI.DualStatus(), MOI.FEASIBLE_POINT)\n    MOI.set(mock, MOI.ConstraintDual(), optimizer_index(con), -2.0)\nend","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @objective(model, Min, -2x)\n-2 x\n\njulia> optimize!(model)\n\njulia> has_duals(model)\ntrue\n\njulia> dual(con)\n-2.0\n\njulia> @objective(model, Max, 2x)\n2 x\n\njulia> optimize!(model)\n\njulia> dual(con)\n-2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To help users who may be less familiar with conic duality, JuMP provides the shadow_price function which returns a value that can be interpreted as the improvement in the objective in response to an infinitesimal relaxation (on the scale of one unit) in the right-hand side of the constraint. shadow_price can be used only on linear constraints with a <=, >=, or == comparison operator.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the example above, dual(con) returned -2.0 regardless of the optimization sense. However, in the second case when the optimization sense is Max, shadow_price returns:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> shadow_price(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To query the dual variables associated with a variable bound, first obtain a constraint reference using one of UpperBoundRef, LowerBoundRef, or FixRef, and then call dual on the returned constraint reference. The reduced_cost function may simplify this process as it returns the shadow price of an active bound of a variable (or zero, if no active bound exists).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/constraints/#Constraint-names","page":"Constraints","title":"Constraint names","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The name, i.e. the value of the MOI.ConstraintName attribute, of a constraint can be obtained by name(::JuMP.ConstraintRef) and set by set_name(::JuMP.ConstraintRef, ::String).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint can also be retrieved from its name using constraint_by_name.","category":"page"},{"location":"manual/constraints/#Start-Values","page":"Constraints","title":"Start Values","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Provide a starting value (also called warmstart) for a constraint's dual using set_dual_start_value.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The start value of a constraint's dual can be queried using dual_start_value. If no start value has been set, dual_start_value will return nothing.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @constraint(model, con, x >= 10)\ncon : x ‚â• 10.0\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, 2)\n\njulia> dual_start_value(con)\n2.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A vector constraint will require a vector warmstart:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, con, x in SecondOrderCone())\ncon : [x[1], x[2], x[3]] in MathOptInterface.SecondOrderCone(3)\n\njulia> dual_start_value(con)\n\njulia> set_dual_start_value(con, [1.0, 2.0, 3.0])\n\njulia> dual_start_value(con)\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To take the dual solution from the last solve and use it as the starting point for a new solve, use:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"for (F, S) in list_of_constraint_types(model)\n    for con in all_constraints(model, F, S)\n        set_dual_start_value(con, dual(con))\n    end\nend","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nSome constraints might not have well defined duals, hence one might need to filter (F, S) pairs.","category":"page"},{"location":"manual/constraints/#Constraint-containers","page":"Constraints","title":"Constraint containers","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"So far, we've added constraints one-by-one. However, just like Variable containers, JuMP provides a mechanism for building groups of constraints compactly. References to these groups of constraints are returned in containers. Three types of constraint containers are supported: Arrays, DenseAxisArrays, and SparseAxisArrays. We explain each of these in the following.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"tip: Tip\nYou can read more about containers in the Containers section.","category":"page"},{"location":"manual/constraints/#constraint_arrays","page":"Constraints","title":"Arrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"One way of adding a group of constraints compactly is the following:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:3], i * x <= i + 1)\n3-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[1] : x <= 2.0\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP returns references to the three constraints in an Array that is bound to the Julia variable con. This array can be accessed and sliced as you would with any Julia array:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> con[1]\ncon[1] : x <= 2.0\n\njulia> con[2:3]\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n con[2] : 2 x <= 3.0\n con[3] : 3 x <= 4.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Anonymous containers can also be constructed by dropping the name (e.g. con) before the square brackets:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [i = 1:2], i * x <= i + 1)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x <= 2.0\n 2 x <= 3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Just like @variable, JuMP will form an Array of constraints when it can determine at parse time that the indices are one-based integer ranges. Therefore con[1:b] will create an Array, but con[a:b] will not. A special case is con[Base.OneTo(n)] which will produce an Array. If JuMP cannot determine that the indices are one-based integer ranges (e.g., in the case of con[a:b]), JuMP will create a DenseAxisArray instead.","category":"page"},{"location":"manual/constraints/#DenseAxisArrays","page":"Constraints","title":"DenseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a DenseAxisArray of constraints is very similar to the syntax for constructing a DenseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 2:3], i * x <= j + 1)\n2-dimensional DenseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, 2:3\nAnd data, a 2√ó2 Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2}:\n con[1,2] : x <= 3.0    con[1,3] : x <= 4.0\n con[2,2] : 2 x <= 3.0  con[2,3] : 2 x <= 4.0","category":"page"},{"location":"manual/constraints/#SparseAxisArrays","page":"Constraints","title":"SparseAxisArrays","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The syntax for constructing a SparseAxisArray of constraints is very similar to the syntax for constructing a SparseAxisArray of variables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con[i = 1:2, j = 1:2; i != j], i * x <= j + 1)\nJuMP.Containers.SparseAxisArray{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  con[1,2] : x <= 3.0\n  [2, 1]  =  con[2,1] : 2 x <= 2.0","category":"page"},{"location":"manual/constraints/#Forcing-the-container-type","page":"Constraints","title":"Forcing the container type","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"When creating a container of constraints, JuMP will attempt to choose the tightest container type that can store the constraints. However, because this happens at parse time, it does not always make the best choice. Just like in @variable, we can force the type of container using the container keyword. For syntax and the reason behind this, take a look at the variable docs.","category":"page"},{"location":"manual/constraints/#Vectorized-constraints","page":"Constraints","title":"Vectorized constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"We can also add constraints to JuMP using vectorized linear algebra. For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> A = [1 2; 3 4]\n2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, con, A * x .== b)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.EqualTo{Float64}},ScalarShape},1}:\n x[1] + 2 x[2] == 5.0\n 3 x[1] + 4 x[2] == 6.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nMake sure to use Julia's dot syntax in front of the comparison operators (e.g. .==, .>=, and .<=). If you use a comparison without the dot, an error will be thrown.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Instead of adding an array of ScalarAffineFunction-in-EqualTo constraints, we can instead construct a VectorAffineFunction-in-Nonnegatives constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, A * x - b in MOI.Nonnegatives(2))\n[x[1] + 2 x[2] - 5, 3 x[1] + 4 x[2] - 6] in MathOptInterface.Nonnegatives(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the Nonnegatives set, MOI defines a number of other vector-valued sets such as Nonpositives. See the MOI documentation for more information.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note also that for the first time we have used an explicit function-in-set description of the constraint. Read more about this representation for constraints in the MOI documentation.","category":"page"},{"location":"manual/constraints/#Constraints-on-a-single-variable","page":"Constraints","title":"Constraints on a single variable","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In Variables, we saw how to modify the variable bounds, as well as add binary and integer restrictions to the domain of each variable. This can also be achieved using the @constraint macro. For example, MOI.ZeroOne() restricts the domain to 0 1:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.ZeroOne())\nx binary","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"and MOI.Integer() restricts to the domain to the integers mathbbZ:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Integer())\nx integer","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports modeling semi-continuous variables, whose domain is 0  l u, using the MOI.Semicontinuous set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semicontinuous(1.5, 3.5))\nx in MathOptInterface.Semicontinuous{Float64}(1.5, 3.5)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"as well as semi-integer variables, whose domain is 0  l l+1 dots u, using the MOI.Semiinteger set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.Semiinteger(1.0, 3.0))\nx in MathOptInterface.Semiinteger{Float64}(1.0, 3.0)","category":"page"},{"location":"manual/constraints/#Quadratic-constraints","page":"Constraints","title":"Quadratic constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to affine functions, JuMP also supports constraints with quadratic terms. (For more general nonlinear functions, see Nonlinear Modeling.) For example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[i=1:2])\n2-element Array{VariableRef,1}:\n x[1]\n x[2]\n\njulia> @variable(model, t >= 0)\nt\n\njulia> @constraint(model, x[1]^2 + x[2]^2 <= t^2)\nx[1]¬≤ + x[2]¬≤ - t¬≤ <= 0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that this quadratic constraint (including the lower bound on t) is equivalent to a second order cone constraint where ||x[1]^2 + x[2]^2||\\_2 ‚â§ t and t ‚â• 0. Instead of writing out the quadratic expansion, we can pass JuMP the constraint in function-in-set form. To do so, we need to define the function and the set.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The function is a vector of variables:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> [t, x[1], x[2]]\n3-element Array{VariableRef,1}:\n t\n x[1]\n x[2]","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the variable t comes first, followed by the x arguments. The set is an instance of SecondOrderCone: SecondOrderCone(). Thus, we can add the second order cone constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, [t, x[1], x[2]] in SecondOrderCone())\n[t, x[1], x[2]] in MathOptInterface.SecondOrderCone(3)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP also supports the RotatedSecondOrderCone which requires the addition of a perspective variable u. The rotated second order cone constraints the variables t, u, and x such that: ||x[1]^2 + x[2]^2||\\_2 ‚â§ t √ó u and t, u ‚â• 0. It can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, u)\nu\n\njulia> @constraint(model, [t, u, x[1], x[2]] in RotatedSecondOrderCone())\n[t, u, x[1], x[2]] in MathOptInterface.RotatedSecondOrderCone(4)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the second order cone and rotated second order cone, MOI defines a number of other conic sets such as the exponential and power cones. See the MathOptInterface documentation for more information.","category":"page"},{"location":"manual/constraints/#Constraints-on-a-collection-of-variables","page":"Constraints","title":"Constraints on a collection of variables","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In addition to constraining the domain of a single variable, JuMP supports placing constraints of a subset of the variables. We already saw an example of this in the Quadratic constraints section when we constrained a vector of variables to belong to the second order cone.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In a special ordered set of type I (often denoted SOS-I), at most one variable can take a non-zero value. We can construct SOS-I constraints using the MOI.SOS1 set:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in MOI.SOS1([1.0, 2.0, 3.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS1{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that we have to pass MOI.SOS1 a weight vector. This vector implies an ordering on the variables. If the decision variables are related and have a physical ordering (e.g., they correspond to the size of a factory to be built, and the SOS-I constraint enforces that only one factory can be built), then the weight vector, although not used directly in the constraint, can help the solver make a better decision in the solution process.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This ordering is more important in a special ordered set of type II (SOS-II), in which at most two values can be non-zero, and if there are two non-zeros, they must be consecutive according to the ordering. For example, in the following constraint, the possible non-zero pairs are (x[1] and x[3]) and (x[2] and x[3]):","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, x in MOI.SOS2([3.0, 1.0, 2.0]))\n[x[1], x[2], x[3]] in MathOptInterface.SOS2{Float64}([3.0, 1.0, 2.0])","category":"page"},{"location":"manual/constraints/#Indicator-constraints","page":"Constraints","title":"Indicator constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for creating indicator constraints, that is, enforce a constraint to hold depending on the value of a binary variable. In order to constrain the constraint x + y <= 1 to hold when a binary variable a is one, use the following syntax:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @variable(model, y)\ny\n\njulia> @variable(model, a, Bin)\na\n\njulia> @constraint(model, a => {x + y <= 1})\na => {x + y ‚â§ 1.0}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If instead the constraint should hold when a is zero, simply add a ! or ¬¨ before the binary variable.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, !a => {x + y <= 1})\n!a => {x + y ‚â§ 1.0}","category":"page"},{"location":"manual/constraints/#Semidefinite-constraints","page":"Constraints","title":"Semidefinite constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP provides a special syntax for constraining a matrix to be symmetric positive semidefinite (PSD) with the @SDconstraint macro. In the context of this macro, the inequality A >= B between two square matrices A and B is understood as constraining A - B to be symmetric positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x)\nx\n\njulia> @SDconstraint(model, [x 2x; 3x 4x] >= ones(2, 2))\n[x - 1    2 x - 1;\n 3 x - 1  4 x - 1] ‚àà PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Solvers supporting such constraints usually expect to be given a matrix that is symbolically symmetric, that is, for which the expression in corresponding off-diagonal entries are the same. In our example, the expressions of entries (1, 2) and (2, 1) are respectively 2x - 1 and 3x - 1 which are different. To bridge the gap between the constraint modeled and what the solver expects, JuMP creates an equality constraint 3x - 1 == 2x - 1 and constrains the symmetric matrix [x - 1, 2 x - 1, 2 x - 1, 4 x - 1] to be positive semidefinite.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nIf the matrix provided is already symbolically symmetric, the equality constrains are equivalent to 0 = 0 and are not added. In practice, if all coefficients are smaller than 1e-10, the constraint is ignored, if all coefficients are smaller than 1e-8 but some are larger than 1e-10, it is ignored but a warning is displayed, otherwise if at least one coefficient is larger than 1e-8, the constraint is added.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If the matrix is known to be symmetric, the PSD constraint can be added as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> using LinearAlgebra\n\njulia> @constraint(model, Symmetric([x 2x; 2x 4x] - ones(2, 2)) in PSDCone())\n[x - 1    2 x - 1;\n 2 x - 1  4 x - 1] ‚àà PSDCone()","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that the lower triangular entries are silently ignored even if they are different so use it with caution:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> cref = @constraint(model, Symmetric([x 2x; 3x 4x]) in PSDCone())\n[x    2 x;\n 2 x  4 x] ‚àà PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x\n 2 x\n 4 x\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Note that as @SDconstraint(model, A >= B) constrains A - B to be symmetric positive semidefinite, even if A is a matrix of variables and B is a matrix of zeros, A - B will be a matrix of affine expressions. For instance, in the example below, the function is VectorAffineFunction instead of VectorOfVariables.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Moreover, the Symmetric structure can be lost in the operation A - B. For instance, in the example below, the set is PositiveSemidefiniteConeSquare instead of PositiveSemidefiniteConeTriangle.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, Symmetric([x x; x x]) >= zeros(2, 2)))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorAffineFunction{Float64},MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To create a constraint on the vector of variables with the @SDconstraint macro, use the 0 symbol. The following three syntax are equivalent:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@SDconstraint(model, A >= 0),\n@SDconstraint(model, 0 <= A) and\n@constraint(model, A in PSDCone()).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> typeof(@SDconstraint(model, [x x; x x] >= 0))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeSquare},SquareMatrixShape}\n\njulia> typeof(@SDconstraint(model, 0 <= Symmetric([x x; x x])))\nConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.VectorOfVariables,MathOptInterface.PositiveSemidefiniteConeTriangle},SymmetricMatrixShape}","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"As the syntax is recognized at parse time, using a variable with value zero does not work:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> a = 0\n0\n\njulia> @SDconstraint(model, [x x; x x] >= a)\nERROR: Operation `-` between `Array{VariableRef,2}` and `Int64` is not allowed. You should use broadcast.\n[...]","category":"page"},{"location":"manual/constraints/#Modify-a-constraint","page":"Constraints","title":"Modify a constraint","text":"","category":"section"},{"location":"manual/constraints/#Modifying-a-constant-term-(Option-1)","page":"Constraints","title":"Modifying a constant term (Option 1)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use set_normalized_rhs to modify the right-hand side (constant) term of a constraint. Use normalized_rhs to query the right-hand side term.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 3)\n\njulia> con\ncon : 2 x <= 3.0\n\njulia> normalized_rhs(con)\n3.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all constant terms onto the right-hand side of the constraint.@constraint(model, 2x - 1 <= 2)will be normalized to@constraint(model, 2x <= 3)set_normalized_rhs sets the right-hand side term of the normalized constraint.","category":"page"},{"location":"manual/constraints/#Modifying-a-constant-term-(Option-2)","page":"Constraints","title":"Modifying a constant term (Option 2)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If constraints are complicated, e.g., they are composed of a number of components, each of which has a constant term, then it may be difficult to calculate what the right-hand side term should be in the standard form.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For this situation, JuMP includes the ability to fix variables to a value using the fix function. Fixing a variable sets its lower and upper bound to the same value. Thus, changes in a constant term can be simulated by adding a dummy variable and fixing it to different values. Here is an example:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, const_term)\nconst_term\n\njulia> @constraint(model, con, 2x <= const_term + 1)\ncon : 2 x - const_term <= 1.0\n\njulia> fix(const_term, 1.0)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The constraint con is now equivalent to 2x <= 2.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nEven though const_term is fixed, it is still a decision variable. Thus, const_term * x is bilinear. Fixed variables are not replaced with constants when communicating the problem to a solver.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Another option is to use add_to_function_constant. The constant given is added to the function of a func-in-set constraint. In the following example, adding 2 to the function has the effect of removing 2 to the right-hand side:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> add_to_function_constant(con, 2)\n\njulia> con\ncon : 2 x <= -1.0\n\njulia> normalized_rhs(con)\n-1.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case of interval constraints, the constant is removed in each bounds.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 0 <= 2x + 1 <= 2)\ncon : 2 x ‚àà [-1.0, 1.0]\n\njulia> add_to_function_constant(con, 3)\n\njulia> con\ncon : 2 x ‚àà [-4.0, -2.0]","category":"page"},{"location":"manual/constraints/#Modifying-a-variable-coefficient","page":"Constraints","title":"Modifying a variable coefficient","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"To modify the coefficients for a linear term in a constraint (but notably not yet the coefficients on a quadratic term), use set_normalized_coefficient. To query the current coefficient, use normalized_coefficient.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x[1] + x[2] <= 1)\ncon : 2 x[1] + x[2] ‚â§ 1.0\n\njulia> set_normalized_coefficient(con, x[2], 0)\n\njulia> con\ncon : 2 x[1] ‚â§ 1.0\n\njulia> normalized_coefficient(con, x[2])\n0.0","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"note: Note\nJuMP normalizes constraints into a standard form by moving all terms involving variables onto the left-hand side of the constraint.@constraint(model, 2x <= 1 - x)will be normalized to@constraint(model, 3x <= 1)set_normalized_coefficient sets the coefficient of the normalized constraint.","category":"page"},{"location":"manual/constraints/#Deleting-constraints","page":"Constraints","title":"Deleting constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints can be deleted from a model using delete.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Check if a constraint reference is valid using is_valid.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, con, 2x <= 1)\ncon : 2 x <= 1.0\n\njulia> is_valid(model, con)\ntrue\n\njulia> delete(model, con)\n\njulia> is_valid(model, con)\nfalse","category":"page"},{"location":"manual/constraints/#Accessing-constraints-from-a-model","page":"Constraints","title":"Accessing constraints from a model","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can query the types of constraints currently present in the model by calling list_of_constraint_types. Then, given a function and set type, use num_constraints to access the number of constraints of this type and all_constraints to access a list of their references. Then use constraint_object to get an instance of an AbstractConstraint object, either ScalarConstraint or VectorConstraint, that stores the constraint data.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2] >= i, Int);\n\njulia> @constraint(model, x[1] + x[2] <= 1);\n\njulia> list_of_constraint_types(model)\n3-element Array{Tuple{DataType,DataType},1}:\n (GenericAffExpr{Float64,VariableRef}, MathOptInterface.LessThan{Float64})\n (VariableRef, MathOptInterface.GreaterThan{Float64})\n (VariableRef, MathOptInterface.Integer)\n\njulia> num_constraints(model, VariableRef, MOI.Integer)\n2\n\njulia> all_constraints(model, VariableRef, MOI.Integer)\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.Integer},ScalarShape},1}:\n x[1] integer\n x[2] integer\n\njulia> num_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2\n\njulia> all_constraints(model, VariableRef, MOI.GreaterThan{Float64})\n2-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.SingleVariable,MathOptInterface.GreaterThan{Float64}},ScalarShape},1}:\n x[1] ‚â• 1.0\n x[2] ‚â• 2.0\n\njulia> num_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1\n\njulia> less_than_constraints = all_constraints(model, GenericAffExpr{Float64,VariableRef}, MOI.LessThan{Float64})\n1-element Array{ConstraintRef{Model,MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.LessThan{Float64}},ScalarShape},1}:\n x[1] + x[2] ‚â§ 1.0\n\njulia> con = constraint_object(less_than_constraints[1])\nScalarConstraint{GenericAffExpr{Float64,VariableRef},MathOptInterface.LessThan{Float64}}(x[1] + x[2], MathOptInterface.LessThan{Float64}(1.0))\n\njulia> con.func\nx[1] + x[2]\n\njulia> con.set\nMathOptInterface.LessThan{Float64}(1.0)","category":"page"},{"location":"manual/constraints/#Complementarity-constraints","page":"Constraints","title":"Complementarity constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A mixed complementarity constraint F(x) ‚üÇ x consists of finding x in the interval [lb, ub], such that the following holds:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"F(x) == 0 if lb < x < ub\nF(x) >= 0 if lb == x\nF(x) <= 0 if x == ub","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For more information, see the MOI.Complements documentation.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"JuMP supports mixed complementarity constraints via complements(F(x), x) or F(x) ‚üÇ x in the @constraint macro. The interval set [lb, ub] is obtained from the variable bounds on x.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"For example, to define the problem 2x - 1 ‚üÇ x with x ‚àà [0, ‚àû), do:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x >= 0)\nx\n\njulia> @constraint(model, 2x - 1 ‚üÇ x)\n[2 x - 1, x] ‚àà MathOptInterface.Complements(1)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This problem has a unique solution at x = 0.5.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"The perp operator ‚üÇ can be entered in most editors (and the Julia REPL) by typing \\perp<tab>.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"An alternative approach that does not require the ‚üÇ symbol uses the complements function as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @constraint(model, complements(2x - 1, x))\n[2 x - 1, x] ‚àà MathOptInterface.Complements(1)","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In both cases, the mapping F(x) is supplied as the first argument, and the matching variable x is supplied as the second.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Vector-valued complementarity constraints are also supported:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, -2 <= y[1:2] <= 2)\n2-element Array{VariableRef,1}:\n y[1]\n y[2]\n\njulia> M = [1 2; 3 4]\n2√ó2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> q = [5, 6]\n2-element Array{Int64,1}:\n 5\n 6\n\njulia> @constraint(model, M * y + q ‚üÇ y)\n[y[1] + 2 y[2] + 5, 3 y[1] + 4 y[2] + 6, y[1], y[2]] ‚àà MathOptInterface.Complements(2)","category":"page"},{"location":"manual/constraints/#Special-Ordered-Sets-(SOS1-and-SOS2)","page":"Constraints","title":"Special Ordered Sets (SOS1 and SOS2)","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A Special Ordered Set (SOS) is an ordered set of variables with the following characteristics.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type I (SOS1), then at most one element of x can take a non-zero value, and all other elements must be zero.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Although not required for feasibility, solvers can benefit from an ordering of the variables (e.g., the variables represent different factories to build, at most one factory can be built, and the factories can be ordered according to cost). To induce an ordering, weights can be provided; as such, they should be unique values. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SOS1 constraint is equivalent to:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0 for some i\nx[j] == 0 for all j != i","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"If a vector of variables x is in a Special Ordered Set of Type II (SOS2), then at most two elements can be non-zero, and if two elements are non-zero, they must be adjacent.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Because of the adjacency requirement, you should supply a weight vector (with unique elements) to induce an ordering of the variables. The kth element in the ordered set corresponds to the kth weight in weights when the weights are sorted.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"A SOS2 constraint is equivalent to:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"x[i] >= 0, x[i+1] >= 0  for some i\nx[j] == 0 for all j != i, j != i+1","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Create an SOS constraint as follows:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2([3,5,2]))\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SOS2{Float64}([3.0, 5.0, 2.0])","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"In the case above, x[3] is the first variable and x[2] the last variable under the induced ordering. When no ordering vector is provided, JuMP induces an ordering from 1:length(x).","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"julia> @variable(model, x[1:3])\n3-element Array{VariableRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @constraint(model, x in SOS2())\n[x[1], x[2], x[3]] ‚àà MathOptInterface.SOS2{Float64}([1.0, 2.0, 3.0])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/power_systems.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Power-Systems","page":"Power Systems","title":"Power Systems","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Originally Contributed by: Yury Dvorkin and Miles Lubin","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This tutorial demonstrates how to formulate basic power systems engineering models in JuMP using a 3 bus example.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"We will consider basic \"economic dispatch\" and \"unit commitment\" models without taking into account transmission constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Illustrative-example","page":"Power Systems","title":"Illustrative example","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following notes for the sake of simplicity, we are going to use a three bus example mirroring the interface between Western and Eastern Texas. This example is taken from R. Baldick, \"Wind and Energy Markets: A Case Study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"(Image: Power Systems)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For this example, we set the following characteristics of generators, transmission lines, wind farms and demands:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Generator 1 Generator 2\ng_min, MW 0 300\ng_max, MW 1000 1000\nc^g, $/MWh 50 100\nc^g0, $/MWh 1000 0","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Line 1 Line 2\nf^max, MW 100 1000\nx, p.u. 0.001 0.001","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Wind farm 1 Wind farm 2\nw^f, MW 150 50\nc^w, $/MWh 50 50","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Quantity Bus 1 Bus 2 Bus 3\nd, MW 0 0 15000","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Economic-dispatch","page":"Power Systems","title":"Economic dispatch","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Economic dispatch (ED) is an optimization problem that minimizes the cost of supplying energy demand subject to operational constraints on power system assets. In its simplest modification, ED is an LP problem solved for an aggregated load and wind forecast and for a single infinitesimal moment.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Mathematically, the ED problem can be written as follows:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"min sum_i in I c^g_i cdot g_i + c^w cdot w","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"where c_i and g_i are the incremental cost ($/MWh) and power output (MW) of the i^th generator, respectively, and c^w and w are the incremental cost ($/MWh) and wind power injection (MW), respectively.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Subject to the constraints:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Minimum (g^min) and maximum (g^max) limits on power outputs of generators: g^min_i leq g_i leq g^max_i\nConstraint on the wind power injection: 0 leq w leq w^f where w and w^f are the wind power injection and wind power forecast, respectively.\nPower balance constraint: sum_i in I g_i + w = d^f where d^f is the demand forecast.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Further reading on ED models can be found in A. J. Wood, B. F. Wollenberg, and G. B. Shebl√©, \"Power Generation, Operation and Control\", Wiley, 2013.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#JuMP-Implementation-of-Economic-Dispatch","page":"Power Systems","title":"JuMP Implementation of Economic Dispatch","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"using JuMP\nimport DataFrames\nimport GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Define some input data about the test system.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"# Maximum power output of generators\ng_max = [1000, 1000]\n# Minimum power output of generators\ng_min = [0, 300]\n# Incremental cost of generators\nc_g = [50, 100]\n# Fixed cost of generators\nc_g0 = [1000, 0]\n# Incremental cost of wind generators\nc_w = 50\n# Total demand\nd = 1500\n# Wind forecast\nw_f = 200\nnothing #hide","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Create a function solve_ed, which solves the economic dispatch problem for a given set of input parameters.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed(g_max, g_min, c_g, c_w, d, w_f)\n    # Define the economic dispatch (ED) model\n    ed = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(ed, 0 <= g[i = 1:2] <= g_max[i]) ## power output of generators\n    @variable(ed, 0 <= w <= w_f) ## wind power injection\n    # Define the objective function\n    @objective(ed, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each\n    # generator\n    @constraint(ed, [i = 1:2], g[i] <= g_max[i]) ## maximum\n    @constraint(ed, [i = 1:2], g[i] >= g_min[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(ed, w <= w_f)\n    # Define the power balance constraint\n    @constraint(ed, sum(g) + w == d)\n    # Solve statement\n    optimize!(ed)\n    # return the optimal value of the objective function and its minimizers\n    return value.(g), value(w), w_f - value(w), objective_value(ed)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"(g_opt, w_opt, ws_opt, obj) = solve_ed(g_max, g_min, c_g, c_w, d, w_f);\n\nprintln(\"Dispatch of Generators: \", g_opt, \" MW\")\nprintln(\"Dispatch of Wind: \", w_opt, \" MW\")\nprintln(\"Wind spillage: \", w_f - w_opt, \" MW\")\nprintln(\"\\n\")\nprintln(\"Total cost: \", obj, \"\\$\")","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Economic-dispatch-with-adjustable-incremental-costs","page":"Power Systems","title":"Economic dispatch with adjustable incremental costs","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following exercise we adjust the incremental cost of generator G1 and observe its impact on the total cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"c_g_scale_df = DataFrames.DataFrame(\n    Symbol(\"Dispatch of Generator 1(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\nfor c_g1_scale = 0.5:0.1:3.0\n    # Update the incremental cost of the first generator at every iteration.\n    c_g_scale = [c_g[1] * c_g1_scale, c_g[2]]\n    # Solve the ed problem with the updated incremental cost\n    g_opt, w_opt, ws_opt, obj = solve_ed(g_max, g_min, c_g_scale, c_w, d, w_f)\n    push!(c_g_scale_df, (g_opt[1], g_opt[2], w_opt, ws_opt, obj))\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"ENV[\"COLUMNS\"]=250 #hide\n\nc_g_scale_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Modifying-the-JuMP-model-in-place","page":"Power Systems","title":"Modifying the JuMP model in place","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Note that in the previous exercise we entirely rebuilt the optimization model at every iteration of the internal loop, which incurs an additional computational burden. This burden can be alleviated if instead of re-building the entire model, we modify a specific constraint(s) or the objective function, as it shown in the example below.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Compare the computing time in case of the above and below models.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_ed_inplace(c_w_scale)\n    start = time()\n    obj_out = Float64[]\n    w_out = Float64[]\n    g1_out = Float64[]\n    g2_out = Float64[]\n    ed = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(ed, 0 <= g[i = 1:2] <= g_max[i]) ## power output of generators\n    @variable(ed, 0 <= w <= w_f ) ## wind power injection\n    # Define the objective function\n    @objective(ed, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each generator\n    @constraint(ed, [i = 1:2], g[i] <= g_max[i]) ## maximum\n    @constraint(ed, [i = 1:2], g[i] >= g_min[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(ed, w <= w_f)\n    # Define the power balance constraint\n    @constraint(ed, sum(g) + w == d)\n    optimize!(ed)\n    for c_g1_scale = 0.5:0.01:3.0\n        @objective(\n            ed,\n            Min,\n            c_g1_scale * c_g[1] * g[1] + c_g[2] * g[2] + c_w_scale * c_w * w,\n        )\n        optimize!(ed)\n        push!(obj_out, objective_value(ed))\n        push!(w_out, value(w))\n        push!(g1_out, value(g[1]))\n        push!(g2_out, value(g[2]))\n    end\n    elapsed = time() - start\n    print(string(\"elapsed time: \", elapsed, \" seconds\"))\n    return obj_out, w_out, g1_out, g2_out\nend\n\nsolve_ed_inplace(2.0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Adjusting specific constraints and/or the objective function is faster than re-building the entire model.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#A-few-practical-limitations-of-the-economic-dispatch-model","page":"Power Systems","title":"A few practical limitations of the economic dispatch model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Inefficient-usage-of-wind-generators","page":"Power Systems","title":"Inefficient usage of wind generators","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The economic dispatch problem does not perform commitment decisions and, thus, assumes that all generators must be dispatched at least at their minimum power output limit. This approach is not cost efficient and may lead to absurd decisions. For example, if $ d = \\sum{i \\in I} g^{\\min}{i}$, the wind power injection must be zero, i.e. all available wind generation is spilled, to meet the minimum power output constraints on generators.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example, we adjust the total demand and observed how it affects wind spillage.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"demandscale_df = DataFrames.DataFrame(\n    Symbol(\"Dispatch of Generators(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\n\nfor demandscale = 0.2:0.1:1.5\n    g_opt,w_opt,ws_opt,obj = solve_ed(g_max, g_min, c_g, c_w, demandscale*d, w_f)\n    push!(demandscale_df, (g_opt[1], g_opt[2], w_opt, ws_opt, obj))\nend\n\ndemandscale_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This particular drawback can be overcome by introducing binary decisions on the \"on/off\" status of generators. This model is called unit commitment and considered later in these notes.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the interplay between wind generation and the minimum power output constraints of generators, we refer interested readers to R. Baldick, \"Wind and Energy Markets: A Case Study of Texas,\" IEEE Systems Journal, vol. 6, pp. 27-34, 2012.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Transmission-infeasible-solution","page":"Power Systems","title":"Transmission-infeasible solution","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The ED solution is entirely market-based and disrespects limitations of the transmission network. Indeed, the flows in transmission lines would attain the following values:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"f_1-2 = 150 MW leq f_1-2^max = 100 MW","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"f_2-3 = 1200 MW leq f_2-3^max = 1000 MW","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Thus, if this ED solution was enforced in practice, the power flow limits on both lines would be violated. Therefore, in the following section we consider the optimal power flow model, which amends the ED model with network constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The importance of the transmission-aware decisions is emphasized in E. Lannoye, D. Flynn, and M. O'Malley, \"Transmission, Variable Generation, and Power System Flexibility,\" IEEE Transactions on Power Systems, vol. 30, pp. 57-66, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Unit-Commitment-model","page":"Power Systems","title":"Unit Commitment model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"The Unit Commitment (UC) model can be obtained from ED model by introducing binary variable associated with each generator. This binary variable can attain two values: if it is \"1\", the generator is synchronized and, thus, can be dispatched, otherwise, i.e. if the binary variable is \"0\", that generator is not synchronized and its power output is set to 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"To obtain the mathematical formulation of the UC model, we will modify the constraints of the ED model as follows:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"g^min_i cdot u_ti leq g_i leq g^max_i cdot u_ti","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"where u_i in 01 In this constraint, if u_i = 0, then g_i  = 0. On the other hand, if u_i = 1, then g^max_i leq g_i leq g^min_i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"For further reading on the UC problem we refer interested readers to G. Morales-Espana, J. M. Latorre, and A. Ramos, \"Tight and Compact MILP Formulation for the Thermal Unit Commitment Problem,\" IEEE Transactions on Power Systems, vol. 28, pp. 4897-4908, 2013.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"In the following example we convert the ED model explained above to the UC model.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"function solve_uc(g_max, g_min, c_g, c_w, d, w_f)\n    # Define the unit commitment (UC) model\n    uc = Model(GLPK.Optimizer)\n    # Define decision variables\n    @variable(uc, 0 <= g[i=1:2] <= g_max[i]) ## power output of generators\n    @variable(uc, u[i = 1:2], Bin) ## Binary status of generators\n    @variable(uc, 0 <= w <= w_f) ## wind power injection\n    # Define the objective function\n    @objective(uc, Min, c_g' * g + c_w * w)\n    # Define the constraint on the maximum and minimum power output of each\n    # generator.\n    @constraint(uc, [i = 1:2], g[i] <= g_max[i] * u[i]) ## maximum\n    @constraint(uc, [i = 1:2], g[i] >= g_min[i] * u[i]) ## minimum\n    # Define the constraint on the wind power injection\n    @constraint(uc, w <= w_f)\n    # Define the power balance constraint\n    @constraint(uc, sum(g) + w == d)\n    # Solve statement\n    optimize!(uc)\n    status = termination_status(uc)\n    if status != MOI.OPTIMAL\n        return status, zeros(length(g)), 0.0, 0.0, zeros(length(u)), Inf\n    end\n    return status, value.(g), value(w), w_f - value(w), value.(u), objective_value(uc)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"Solve the economic dispatch problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"status, g_opt, w_opt, ws_opt, u_opt, obj =\n    solve_uc(g_max, g_min, c_g, c_w, d, w_f)\n\nprintln(\"Dispatch of Generators: \", g_opt[:], \" MW\")\nprintln(\"Commitments of Generators: \", u_opt[:])\nprintln(\"Dispatch of Wind: \", w_opt, \" MW\")\nprintln(\"Wind spillage: \", w_f - w_opt, \" MW\")\nprintln(\"\\n\")\nprintln(\"Total cost: \", obj, \"\\$\")","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/#Unit-Commitment-as-a-function-of-demand","page":"Power Systems","title":"Unit Commitment as a function of demand","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"After implementing the UC model, we can now assess the interplay between the minimum power output constraints on generators and wind generation.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df = DataFrames.DataFrame(\n    Symbol(\"Commitment of Generator 1(MW)\") => Float64[],\n    Symbol(\"Commitment of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 1(MW)\") => Float64[],\n    Symbol(\"Dispatch of Generator 2(MW)\") => Float64[],\n    Symbol(\"Dispatch of Wind(MW)\") => Float64[],\n    Symbol(\"Spillage of Wind(MW)\") => Float64[],\n    Symbol(\"Total cost(\\$)\") => Float64[],\n)\n\nfor demandscale = 0.2:0.1:1.5\n    status, g_opt, w_opt, ws_opt, u_opt, obj =\n        solve_uc(g_max, g_min, c_g, c_w, demandscale*d, w_f)\n    if status == MOI.OPTIMAL\n        push!(uc_df, (u_opt[1], u_opt[2], g_opt[1], g_opt[2], w_opt, ws_opt, obj))\n    else\n        println(\"Status: $status for demandscale = $demandscale \\n\")\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"uc_df","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/power_systems/","page":"Power Systems","title":"Power Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Quadratic programs/qcp.jl\"","category":"page"},{"location":"tutorials/Quadratic programs/qcp/#Quadratically-constrained-programs","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"section"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"A simple quadratically constrained program based on an example from Gurobi.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"using JuMP\nimport Ipopt\nimport Test\n\nfunction example_qcp(; verbose = true)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, x)\n    @variable(model, y >= 0)\n    @variable(model, z >= 0)\n    @objective(model, Max, x)\n    @constraint(model, x + y + z == 1)\n    @constraint(model, x * x + y * y - z * z <= 0)\n    @constraint(model, x * x - y * z <= 0)\n    optimize!(model)\n    if verbose\n        print(model)\n        println(\"Objective value: \", objective_value(model))\n        println(\"x = \", value(x))\n        println(\"y = \", value(y))\n    end\n    Test.@test termination_status(model) == MOI.LOCALLY_SOLVED\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 0.32699 atol = 1e-5\n    Test.@test value(x) ‚âà 0.32699 atol = 1e-5\n    Test.@test value(y) ‚âà 0.25707 atol = 1e-5\n    return\nend\n\nexample_qcp()","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"View this file on Github.","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"","category":"page"},{"location":"tutorials/Quadratic programs/qcp/","page":"Quadratically constrained programs","title":"Quadratically constrained programs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#![JuMP-logo](assets/jump-logo-with-text.svg)","page":"Introduction","title":"(Image: JuMP logo)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Powered by NumFOCUS)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# These comments do not display in the HTML output.\n# See https://github.com/JuliaDocs/Documenter.jl/issues/674.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nBetween versions 0.18 and 0.19, JuMP underwent a major transition in its underlying solver abstraction API, from MathProgBase to MathOptInterface. See NEWS.md for a comprehensive list of changes between the two versions, many of which are breaking. This documentation is for JuMP/MathOptInterface. For the documentation of JuMP 0.18, see here.","category":"page"},{"location":"#What-is-JuMP?","page":"Introduction","title":"What is JuMP?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a domain-specific modeling language for mathematical optimization embedded in Julia. It currently supports a number of open-source and commercial solvers for a variety of problem classes, including linear, mixed-integer, second-order conic, semidefinite, and nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nIf you aren't sure if you should use JuMP, read Should I use JuMP?.","category":"page"},{"location":"#Resources-for-getting-started","page":"Introduction","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Read the Installation Guide.\nRead the introductory tutorials Getting started with Julia and Getting started with JuMP.\nBrowse some of our modeling tutorials, including classics such as The diet problem, or the Maximum likelihood estimation problem using nonlinear programming.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nNeed help? Join the community forum to search for questions to commonly asked questions.Before asking a question, make sure to read the post make it easier to help you, which contains a number of tips on how to ask a good question.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Introduction","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Having a high-level overview of how this documentation is structured will help you know where to look for certain things. There are four main parts:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tutorials contain worked examples of solving problems with JuMP. Start here if you are new to JuMP, or you have a particular problem class you want to model.\nThe Manual contains short code-snippets that explain how to achieve specific tasks in JuMP. Look here if you want to know how to achieve a particular task, such as how to delete a variable or how to modify an objective coefficient.\nThe API Reference contains a complete list of the functions you can use in JuMP. Look here if you want to know how to use a particular function.\nThe Background information section contains background reading material to provide context to JuMP. Look here if you want an understanding of what JuMP is and why we created it, rather than how to use it.","category":"page"},{"location":"#Citing-JuMP","page":"Introduction","title":"Citing JuMP","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find JuMP useful in your work, we kindly request that you cite the following paper (pdf):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{DunningHuchetteLubin2017,\nauthor = {Iain Dunning and Joey Huchette and Miles Lubin},\ntitle = {JuMP: A Modeling Language for Mathematical Optimization},\njournal = {SIAM Review},\nvolume = {59},\nnumber = {2},\npages = {295-320},\nyear = {2017},\ndoi = {10.1137/15M1020575},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For an earlier work where we presented a prototype implementation of JuMP, see here:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{LubinDunningIJOC,\nauthor = {Miles Lubin and Iain Dunning},\ntitle = {Computing in Operations Research Using Julia},\njournal = {INFORMS Journal on Computing},\nvolume = {27},\nnumber = {2},\npages = {238-248},\nyear = {2015},\ndoi = {10.1287/ijoc.2014.0623},\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A preprint of this paper is freely available.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: NumFOCUS logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides JuMP with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can support JuMP by donating.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Donations to JuMP are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP's largest expense is the annual JuMP-dev workshop. Donations will help us provide travel support for JuMP-dev attendees and take advantage of other opportunities that arise to support JuMP development.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"developers/extensions/#extensions_manual","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"JuMP provides a variety of ways to extend the basic modeling functionality.","category":"page"},{"location":"developers/extensions/#Define-a-new-set","page":"Extensions","title":"Define a new set","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"To define a new set for JuMP, subtype MOI.AbstractScalarSet or MOI.AbstractVectorSet and implement Base.copy for the set. That's it!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct _NewVectorSet <: MOI.AbstractVectorSet\n    dimension::Int\nend\nBase.copy(x::_NewVectorSet) = x\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in _NewVectorSet(2))\n\n# output\n\n[x[1], x[2]] ‚àà _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"However, for vector-sets, this requires the user to specify the dimension argument to their set, even though we could infer it from the length of x!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"You can make a more user-friendly set by subtyping AbstractVectorSet and implementing moi_set.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"struct NewVectorSet <: JuMP.AbstractVectorSet end\nJuMP.moi_set(::NewVectorSet, dim::Int) = _NewVectorSet(dim)\n\nmodel = Model()\n@variable(model, x[1:2])\n@constraint(model, x in NewVectorSet())\n\n# output\n\n[x[1], x[2]] ‚àà _NewVectorSet(2)","category":"page"},{"location":"developers/extensions/#Extend-[@variable](@ref)","page":"Extensions","title":"Extend @variable","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Just as Bin and Int create binary and integer variables, you can extend the @variable macro to create new types of variables. Here is an explanation by example, where we create a AddTwice type, that creates a tuple of two JuMP variables instead of a single variable.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"First, create a new struct. This can be anything. Our struct holds a VariableInfo object that stores bound information, and whether the variable is binary or integer.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> struct AddTwice\n           info::JuMP.VariableInfo\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Second, implement build_variable, which takes ::Type{AddTwice} as an argument, and returns an instance of AddTwice. Note that you can also receive keyword arguments.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.build_variable(\n           _err::Function,\n           info::JuMP.VariableInfo,\n           ::Type{AddTwice};\n           kwargs...\n       )\n           println(\"Can also use $kwargs here.\")\n           return AddTwice(info)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Third, implement add_variable, which takes the instance of AddTwice from the previous step, and returns something. Typically, you will want to call add_variable here. For example, our AddTwice call is going to add two JuMP variables.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> function JuMP.add_variable(\n           model::JuMP.Model,\n           duplicate::AddTwice,\n           name::String,\n       )\n           a = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_a\",\n            )\n           b = JuMP.add_variable(\n               model,\n               JuMP.ScalarVariable(duplicate.info),\n               name * \"_b\",\n            )\n           return (a, b)\n       end","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Now AddTwice can be passed to @variable just like Bin or Int. However, now it adds two variables instead of one!","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"julia> model = Model();\n\njulia> @variable(model, x[i=1:2], AddTwice, kw=i)\nCan also use Base.Iterators.Pairs(:kw=>1) here.\nCan also use Base.Iterators.Pairs(:kw=>2) here.\n2-element Array{Tuple{VariableRef,VariableRef},1}:\n (x[1]_a, x[1]_b)\n (x[2]_a, x[2]_b)\n\njulia> num_variables(model)\n4\n\njulia> first(x[1])\nx[1]_a\n\njulia> last(x[2])\nx[2]_b","category":"page"},{"location":"developers/extensions/#Extend-[@constraint](@ref)","page":"Extensions","title":"Extend @constraint","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"The @constraint macro always calls the same three functions:","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"parse_constraint: is called at parsing time, it parses the constraint expression and returns a build_constraint call expression;\nbuild_constraint: given the functions and sets involved in the constraints, it returns a AbstractConstraint;\nadd_constraint: given the model, the AbstractConstraint constructed in build_constraint and the constraint name, it stores them in the model and returns a ConstraintRef.","category":"page"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Adding methods to these functions is the recommended way to extend the @constraint macro.","category":"page"},{"location":"developers/extensions/#Adding-parse_constraint-methods","page":"Extensions","title":"Adding parse_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Adding-build_constraint-methods","page":"Extensions","title":"Adding build_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"There are typically two choices when creating a build_constraint method, either return an AbstractConstraint already supported by the model, i.e. ScalarConstraint or VectorConstraint, or a custom AbstractConstraint with a corresponding add_constraint method (see Adding add_constraint methods).","category":"page"},{"location":"developers/extensions/#Adding-add_constraint-methods","page":"Extensions","title":"Adding add_constraint methods","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Shapes","page":"Extensions","title":"Shapes","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Shapes allow vector constraints, which are represented as flat vectors in MOI, to retain a matrix shape at the JuMP level. There is a shape field in VectorConstraint that can be set in build_constraint and that is used to reshape the result computed in value and dual.","category":"page"},{"location":"developers/extensions/#Extend-[@objective](@ref)","page":"Extensions","title":"Extend @objective","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Adding-a-bridge","page":"Extensions","title":"Adding a bridge","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"developers/extensions/#Defining-new-JuMP-models","page":"Extensions","title":"Defining new JuMP models","text":"","category":"section"},{"location":"developers/extensions/","page":"Extensions","title":"Extensions","text":"Work in progress.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/min_ellipse.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/#Minimum-ellipses","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This example is from the Boyd & Vandenberghe book \"Convex Optimization\". Given a set of ellipses centered on the origin","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"E(A) = { u | u^T inv(A) u <= 1 }","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"find a \"minimal\" ellipse that contains the provided ellipses.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"We can formulate this as an SDP:","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"minimize    trace(WX)\nsubject to  X >= A_i,    i = 1,...,m\n            X PSD","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"where W is a PD matrix of weights to choose between different solutions.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"using JuMP\nimport LinearAlgebra\nimport SCS\nimport Test\n\nfunction example_min_ellipse()\n    # We will use three ellipses: two \"simple\" ones, and a random one.\n    As = [\n        [2.0  0.0; 0.0  1.0],\n        [1.0  0.0; 0.0  3.0],\n        [2.86715 1.60645; 1.60645 1.12639]\n    ]\n    # We change the weights to see different solutions, if they exist\n    weights = [1.0 0.0; 0.0 1.0]\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[i=1:2, j=1:2], PSD)\n    @objective(model, Min, LinearAlgebra.tr(weights * X))\n    for As_i in As\n        @SDconstraint(model, X >= As_i)\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 6.46233 atol = 1e-5\n    Test.@test value.(X) ‚âà [3.1651 0.8022; 0.8022 3.2972] atol = 1e-4\n    return\nend\n\nexample_min_ellipse()","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/min_ellipse/","page":"Minimum ellipses","title":"Minimum ellipses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/network_flows.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#Network-Flows","page":"Network Flows","title":"Network Flows","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"In graph theory, a flow network (also known as a transportation network) is a directed graph where each edge has a capacity and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Often in operations research, a directed graph is called a network, the vertices are called nodes and the edges are called arcs.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it,  unless it is a source, which has only outgoing flow, or sink, which has only incoming flow.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"A network can be used to model traffic in a computer network, circulation with demands, fluids in pipes,  currents in an electrical circuit, or anything similar in which something travels through a network of nodes.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"using JuMP\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Shortest-Path-Problem","page":"Network Flows","title":"The Shortest Path Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Suppose that each arc (i j) of a graph is assigned a scalar cost a_ij, and suppose that we define the cost of a forward path to be the sum of the costs of its arcs.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Given a pair of nodes, the shortest path problem is to find a forward path that connects these nodes and has minimum cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmin  sum_forall e(ij) in E a_ij times x_ij \nst  b(i) = sum_j x_ij - sum_k x_ki = begincases\n1 mboxif i is the starting node \n-1 mboxif i is the ending node \n0 mboxotherwise endcases \n x_e in 01  forall e in E\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    0 100 30  0  0;\n    0   0 20  0  0;\n    0   0  0 10 60;\n    0  15  0  0 50;\n    0   0  0  0  0;\n]\n\nn = size(G)[1]\n\nshortest_path = Model(GLPK.Optimizer)\n\n@variable(shortest_path, x[1:n,1:n], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Arcs with zero cost are not a part of the path as they do no exist","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, [i = 1:n, j = 1:n; G[i,j] == 0], x[i,j] == 0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow conservation constraint","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, [i = 1:n; i != 1 && i != 2], sum(x[i,:]) == sum(x[:,i]))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow coming out of source = 1","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, sum(x[1,:]) - sum(x[:,1]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flowing coming out of destination = -1 i.e. Flow entering destination = 1","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(shortest_path, sum(x[2,:]) - sum(x[:,2]) == -1)\n@objective(shortest_path, Min, LinearAlgebra.dot(G, x))\n\noptimize!(shortest_path)\nobjective_value(shortest_path)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(x)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Assignment-Problem","page":"Network Flows","title":"The Assignment Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Suppose that there are n persons and n objects that we have to match on a one-to-one basis. There is a benefit or value a_ij for matching person i with object j, and we want to assign persons to objects so as to maximize the total benefit.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"There is also a restriction that person i can be assigned to object j only if (i j) belongs to a given set of pairs A.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Mathematically, we want to find a set of person-object pairs (1 j_1) (n j_n) from A such that the objects j_1j_n are all distinct, and the total benefit sum_i=1^y a_ij_i is maximized.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmax  sum_(ij) in A a_ij times y_ij \nst  sum_j(ij) in A y_ij = 1  forall i = 12n \n sum_i(ij) in A y_ij = 1  forall j = 12n \n y_ij in 01  forall (ij) in 12k\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 2)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    6 4 5 0;\n    0 3 6 0;\n    5 0 4 3;\n    7 5 5 5;\n]\n\nn = size(G)[1]\n\nassignment = Model(GLPK.Optimizer)\n@variable(assignment, y[1:n,1:n], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"One person can only be assigned to one object","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(assignment, [i = 1:n], sum(y[:,i]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"One object can only be assigned to one person","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(assignment, [j = 1:n], sum(y[j,:]) == 1)\n@objective(assignment, Max, LinearAlgebra.dot(G, y))\n\noptimize!(assignment)\nobjective_value(assignment)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(y)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/#The-Max-Flow-Problem","page":"Network Flows","title":"The Max-Flow Problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"In the max-flow problem, we have a graph with two special nodes: the source, denoted by s, and the sink, denoted by t.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"The objective is to move as much flow as possible from s into t while observing the capacity constraints.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"beginaligned\nmax  sum_v(sv) in E f(sv) \nst  sum_u(uv) in E f(uv)  = sum_w(vw) in E f(vw)  forall v in V - st \n f(uv) leq c(uv)  forall (uv) in E \n f(uv) geq 0  forall (uv) in E\nendaligned","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"(Image: Flow Network 3)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"G = [\n    0 3 2 2 0 0 0 0;\n    0 0 0 0 5 1 0 0;\n    0 0 0 0 1 3 1 0;\n    0 0 0 0 0 1 0 0;\n    0 0 0 0 0 0 0 4;\n    0 0 0 0 0 0 0 2;\n    0 0 0 0 0 0 0 4;\n    0 0 0 0 0 0 0 0;\n]\n\nn = size(G)[1]\n\nmax_flow = Model(GLPK.Optimizer)\n\n@variable(max_flow, f[1:n,1:n] >= 0)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Capacity constraints","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(max_flow, [i = 1:n, j = 1:n], f[i,j] <= G[i,j])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"Flow conservation constraints","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"@constraint(max_flow, [i = 1:n; i != 1 && i != 8], sum(f[i,:]) == sum(f[:,i]))\n@objective(max_flow, Max, sum(f[1, :]))\n\noptimize!(max_flow)\nobjective_value(max_flow)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"value.(f)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/network_flows/","page":"Network Flows","title":"Network Flows","text":"This page was generated using Literate.jl.","category":"page"},{"location":"developers/style/#Style-guide-and-design-principles","page":"Style Guide","title":"Style guide and design principles","text":"","category":"section"},{"location":"developers/style/#Style-guide","page":"Style Guide","title":"Style guide","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the coding style rules that apply to JuMP code and that we recommend for JuMP models and surrounding Julia code. The motivations for a style guide include:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"conveying best practices for writing readable and maintainable code\nreducing the amount of time spent on bike-shedding by establishing basic naming and formatting conventions\nlowering the barrier for new contributors by codifying the existing practices (e.g., you can be more confident your code will pass review if you follow the style guide)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In some cases, the JuMP style guide diverges from the Julia style guide. All such cases will be explicitly noted and justified.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The JuMP style guide adopts many recommendations from the Google style guides.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nThe style guide is always a work in progress, and not all JuMP code follows the rules. When modifying JuMP, please fix the style violations of the surrounding code (i.e., leave the code tidier than when you started). If large changes are needed, consider separating them into another PR.","category":"page"},{"location":"developers/style/#JuliaFormatter","page":"Style Guide","title":"JuliaFormatter","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"JuMP uses JuliaFormatter.jl as an autoformatting tool.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We use the options contained in .JuliaFormatter.toml.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"To format code, cd to the JuMP directory, then run:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"] add JuliaFormatter@0.13.2\nusing JuliaFormatter\nformat(\"src\")\nformat(\"test\")","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"info: Info\nA continuous integration check verifies that all PRs made to JuMP have passed the formatter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The following sections outline extra style guide points that are not fixed automatically by JuliaFormatter.","category":"page"},{"location":"developers/style/#Whitespace","page":"Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For conciseness, never use more than one blank line within a function, and never begin a function with a blank line.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"function foo(x)\n    y = 2 * x\n\n\n    return y\nend\n\nfunction foo(x)\n\n    y = 2 * x\n    return y\nend","category":"page"},{"location":"developers/style/#Juxtaposed-multiplication","page":"Style Guide","title":"Juxtaposed multiplication","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Only use juxtaposed multiplication when the right-hand side is a symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2x  # Acceptable if there are space constraints.\n2 * x  # This is preferred if space is not an issue.\n2 * (x + 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"2(x + 1)","category":"page"},{"location":"developers/style/#Empty-vectors","page":"Style Guide","title":"Empty vectors","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For a type T, T[] and Vector{T}() are equivalent ways to create an empty vector with element type T. Prefer T[] because it is more concise.","category":"page"},{"location":"developers/style/#Comments","page":"Style Guide","title":"Comments","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For non-native speakers and for general clarity, comments in code must be proper English sentences with appropriate punctuation.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# This is a comment demonstrating a good comment.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"# a bad comment","category":"page"},{"location":"developers/style/#JuMP-macro-syntax","page":"Style Guide","title":"JuMP macro syntax","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use parentheses.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable model x >= 0","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For consistency, always use constant * variable as opposed to variable * constant. This makes it easier to read models in ambiguous cases like a * x.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, 3 * x <= 1)\n@constraint(model, a * x <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"a = 4\n@constraint(model, x * 3 <= 1)\n@constraint(model, x * a <= 1)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"In order to reduce boilerplate code, prefer the plural form of macros over lots of repeated calls to singular forms.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0\n    y >= 1\n    z <= 2\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0)\n@variable(model, y >= 1)\n@variable(model, z <= 2)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"An exception is made for calls with many keyword arguments, since these need to be enclosed in parentheses in order to parse properly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x >= 0, start = 0.0, base_name = \"my_x\")\n@variable(model, y >= 1, start = 2.0)\n@variable(model, z <= 2, start = -1.0)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also acceptable:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variables(model, begin\n    x >= 0, (start = 0.0, base_name = \"my_x\")\n    y >= 1, (start = 2.0)\n    z <= 2, (start = -1.0)\nend)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"While we always use in for for-loops, it is acceptable to use = in the container declarations of JuMP macros.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i=1:3])","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Also okay:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@variable(model, x[i in 1:3])","category":"page"},{"location":"developers/style/#Naming","page":"Style Guide","title":"Naming","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module SomeModule end\nfunction some_function end\nconst SOME_CONSTANT = ...\nstruct SomeStruct\n  some_field::SomeType\nend\n@enum SomeEnum ENUM_VALUE_A ENUM_VALUE_B\nsome_local_variable = ...\nsome_file.jl # Except for ModuleName.jl.","category":"page"},{"location":"developers/style/#Exported-and-non-exported-names","page":"Style Guide","title":"Exported and non-exported names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Begin private module level functions and constants with an underscore. All other objects in the scope of a module should be exported. (See JuMP.jl for an example of how to do this.)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Names beginning with an underscore should only be used for distinguishing between exported (public) and non-exported (private) objects. Therefore, never begin the name of a local variable with an underscore.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module MyModule\n\nexport public_function, PUBLIC_CONSTANT\n\nfunction _private_function()\n    local_variable = 1\n    return\nend\n\nfunction public_function end\n\nconst _PRIVATE_CONSTANT = 3.14159\nconst PUBLIC_CONSTANT = 1.41421\n\nend","category":"page"},{"location":"developers/style/#Use-of-underscores-within-names","page":"Style Guide","title":"Use of underscores within names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The Julia style guide recommends avoiding underscores \"when readable\", for example, haskey, isequal, remotecall, and remotecall_fetch. This convention creates the potential for unnecessary bikeshedding and also forces the user to recall the presence/absence of an underscore, e.g., \"was that argument named basename or base_name?\". For consistency, always use underscores in variable names and function names to separate words.","category":"page"},{"location":"developers/style/#Use-of-!","page":"Style Guide","title":"Use of !","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Julia has a convention of appending ! to a function name if the function modifies its arguments. We recommend to:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Omit ! when the name itself makes it clear that modification is taking place, e.g., add_constraint and set_name. We depart from the Julia style guide because ! does not provide a reader with any additional information in this case, and adherence to this convention is not uniform even in base Julia itself (consider Base.println and Base.finalize).\nUse ! in all other cases. In particular it can be used to distinguish between modifying and non-modifying variants of the same function like scale and scale!.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Note that ! is not a self-documenting feature because it is still ambiguous which arguments are modified when multiple arguments are present. Be sure to document which arguments are modified in the method's docstring.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"See also the Julia style guide recommendations for ordering of function arguments.","category":"page"},{"location":"developers/style/#Abbreviations","page":"Style Guide","title":"Abbreviations","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Abbreviate names to make the code more readable, not to save typing. Don't arbitrarily delete letters from a word to abbreviate it (e.g., indx). Use abbreviations consistently within a body of code (e.g., do not mix con and constr, idx and indx).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Common abbreviations:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"num for number\ncon for constraint","category":"page"},{"location":"developers/style/#No-one-letter-variable-names","page":"Style Guide","title":"No one-letter variable names","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Where possible, avoid one-letter variable names.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use model = Model() instead of m = Model()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Exceptions are made for indices in loops.","category":"page"},{"location":"developers/style/#User-facing-MethodError","page":"Style Guide","title":"User-facing MethodError","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Specifying argument types for methods is mostly optional in Julia, which means that it's possible to find out that you are working with unexpected types deep in the call chain. Avoid this situation or handle it with a helpful error message. A user should see a MethodError only for methods that they called directly.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Bad:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for _internal_function when calling\n# public_function(\"a string\"). This is not very helpful.\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Good:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\n# The user sees a MethodError for public_function when calling\n# public_function(\"a string\"). This is easy to understand.\npublic_function(x::Integer) = _internal_function(x)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"If it is hard to provide an error message at the top of the call chain, then the following pattern is also ok:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"_internal_function(x::Integer) = x + 1\nfunction _internal_function(x)\n    error(\n        \"Internal error. This probably means that you called \" *\n        \"public_function() with the wrong type.\",\n    )\nend\npublic_function(x) = _internal_function(x)","category":"page"},{"location":"developers/style/#@enum-vs.-Symbol","page":"Style Guide","title":"@enum vs. Symbol","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"The @enum macro lets you define types with a finite number of values that are explicitly enumerated (like enum in C/C++). Symbols are lightweight strings that are used to represent identifiers in Julia (for example, :x).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"@enum provides type safety and can have docstrings attached to explain the possible values. Use @enums when applicable, e.g., for reporting statuses. Use strings to provide long-form additional information like error messages.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use of Symbol should typically be reserved for identifiers, e.g., for lookup in the JuMP model (model[:my_variable]).","category":"page"},{"location":"developers/style/#using-vs.-import","page":"Style Guide","title":"using vs. import","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"using ModuleName brings all symbols exported by the module ModuleName into scope, while import ModuleName brings only the module itself into scope. (See the Julia manual) for examples and more details.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For the same reason that from <module> import * is not recommended in python (PEP 8), avoid using ModuleName except in throw-away scripts or at the REPL. The using statement makes it harder to track where symbols come from and exposes the code to ambiguities when two modules export the same symbol.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Prefer using ModuleName: x, p to import ModuleName.x, ModuleName.p and import MyModule: x, p because the import versions allow method extension without qualifying with the module name.","category":"page"},{"location":"developers/style/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for JuMP (and supporting packages).","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"We can recommend the documentation style guides by Divio, Google, and Write the Docs as general reading for those writing documentation. This guide delegates a thorough handling of the topic to those guides and instead elaborates on the points more specific to Julia and documentation that use Documenter.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Be concise\nUse lists instead of long sentences\nUse numbered lists when describing a sequence, e.g., (1) do X, (2) then Y\nUse bullet points when the items are not ordered\nExample code should be covered by doctests\nWhen a word is a Julia symbol and not an English word, enclose it with backticks. In addition, if it has a docstring in this doc add a link using @ref. If it is a plural, add the \"s\" after the closing backtick. For example,\n[`VariableRef`](@ref)s\nUse @meta blocks for TODOs and other comments that shouldn't be visible to readers. For example,\n```@meta\n# TODO: Mention also X, Y, and Z.\n```","category":"page"},{"location":"developers/style/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Every exported object needs a docstring\nAll examples in docstrings should be jldoctests\nAlways use complete English sentences with proper punctuation\nDo not terminate lists with punctuation (e.g., as in this doc)","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is an example:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    signature(args; kwargs...)\n\nShort sentence describing the function.\n\nOptional: add a slightly longer paragraph describing the function.\n\n## Notes\n\n - List any notes that the user should be aware of\n\n## Examples\n\n```jldoctest\njulia> 1 + 1\n2\n```\n\"\"\"","category":"page"},{"location":"developers/style/#Testing","page":"Style Guide","title":"Testing","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Use a module to encapsulate tests, and structure all tests as functions. This avoids leaking local variables between tests.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Here is a basic skeleton:","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"module TestPkg\n\nusing Test\n\n_helper_function() = 2\n\nfunction test_addition()\n    @test 1 + 1 == _helper_function()\nend\n\nfunction runtests()\n    for name in names(@__MODULE__; all = true)\n        if startswith(\"$(name)\", \"test_\")\n            @testset \"$(name)\" begin\n                getfield(@__MODULE__, name)()\n            end\n        end\n    end\nend\n\nend # TestPkg\n\nTestPkg.runtests()","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"Break the tests into multiple files, with one module per file, so that subsets of the codebase can be tested by calling include with the relevant file.","category":"page"},{"location":"developers/style/#Design-principles","page":"Style Guide","title":"Design principles","text":"","category":"section"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"TODO: How to structure and test large JuMP models, libraries that use JuMP.","category":"page"},{"location":"developers/style/","page":"Style Guide","title":"Style Guide","text":"For how to write a solver, see MOI.","category":"page"},{"location":"developers/roadmap/#Development-roadmap","page":"Roadmap","title":"Development roadmap","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"This page is not JuMP documentation per se but are notes for the JuMP community. The JuMP developers have compiled this roadmap document to share their plans and goals. Contributions to roadmap issues are especially invited.","category":"page"},{"location":"developers/roadmap/#JuMP-1.0","page":"Roadmap","title":"JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"JuMP 1.0 will be ready to release roughly when all of these tasks are completed. Some but not all of these tasks are summarized in the JuMP 1.0 milestone.","category":"page"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"Create a website for JuMP (Done: jump.dev)\nDeprecate the JuliaOpt organization and move repositories to the JuMP-dev organization (Done)\nAddress major regressions from JuMP 0.18\nPerformance (#1403,              #1654,              #1607)\nCallbacks (Done: see examples/callbacks.jl)\nColumn generation syntax (Done: see examples/cutting_stock_column_generation.jl)\nSupport for second-order cones in Gurobi, CPLEX, and Xpress (Done)\nFix issues that we promised MOI would fix\nChecking feasibility of solutions (Done: #2466)\nAccessing IIS (Done: see Conflicts)\nAccessing multiple results from solvers (Done: Gurobi#392)\nDual warm-starts (Done: #2214)\nAddress \"easy\" usability issues\nLine numbers in error messages (Done: #2276)\nLP sensitivity summary (Done: see Sensitivity analysis for LP)\nInferred element types for collections in macros (Done: #2070)\nExpose solver-independent options from JuMP (Done: see set_silent etc.)\nImprove the documentation (#1062)\nSeparate how-to, concept explanation, and technical reference following the Divio recommendations (Done)\nFully integrate JuMPTutorials with JuMP's documentation (Done)\nDeveloper experience\nGet JuMP's unit tests running faster. See #1745. (Done)\nAll solvers should complete the transition to MOI (Done)\nProvide packages for installing Bonmin and Couenne\nMathOptFormat 1.0 (Done)","category":"page"},{"location":"developers/roadmap/#MOI-1.0","page":"Roadmap","title":"MOI 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: List MOI 1.0 items here.","category":"page"},{"location":"developers/roadmap/#Beyond-JuMP-1.0","page":"Roadmap","title":"Beyond JuMP 1.0","text":"","category":"section"},{"location":"developers/roadmap/","page":"Roadmap","title":"Roadmap","text":"# TODO: Copy over list of items not tied to JuMP 1.0. These should have more\n# elaborate explanations so that potential contributors know what we mean,\n# i.e., a few sentences each or a link to a document/issue.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/knapsack.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/#The-knapsack-problem","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"Formulate and solve a simple knapsack problem:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"max sum(p_j x_j)\n st sum(w_j x_j) <= C\n    x binary","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_knapsack(; verbose = true)\n    profit = [5, 3, 2, 7, 4]\n    weight = [2, 8, 4, 2, 5]\n    capacity = 10\n    model = Model(GLPK.Optimizer)\n    @variable(model, x[1:5], Bin)\n    # Objective: maximize profit\n    @objective(model, Max, profit' * x)\n    # Constraint: can carry all\n    @constraint(model, weight' * x <= capacity)\n    # Solve problem using MIP solver\n    optimize!(model)\n    if verbose\n        println(\"Objective is: \", objective_value(model))\n        println(\"Solution is:\")\n        for i in 1:5\n            print(\"x[$i] = \", value(x[i]))\n            println(\", p[$i]/w[$i] = \", profit[i] / weight[i])\n        end\n    end\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 16.0\n    return\nend\n\nexample_knapsack()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/knapsack/","page":"The knapsack problem","title":"The knapsack problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/nlp/#Nonlinear-Modeling","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP has support for general smooth nonlinear (convex and nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order derivatives to solvers. This information can improve solver accuracy and performance.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There are three main changes to solve nonlinear programs in JuMP.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective instead of @objective\nUse @NLconstraint instead of @constraint\nUse @NLexpression instead of @expression","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nThere are some restrictions on what syntax you can use in the @NLxxx macros. Make sure to read the Syntax notes.","category":"page"},{"location":"manual/nlp/#Set-a-nonlinear-objective","page":"Nonlinear Modeling","title":"Set a nonlinear objective","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLobjective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, exp(x[1]) - sqrt(x[2]))","category":"page"},{"location":"manual/nlp/#Add-a-nonlinear-constraint","page":"Nonlinear Modeling","title":"Add a nonlinear constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLconstraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, exp(x[1]) <= 1)\nexp(x[1]) - 1.0 ‚â§ 0\n\njulia> @NLconstraint(model, [i = 1:2], x[i]^i >= i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n x[1] ^ 1.0 - 1.0 ‚â• 0\n x[2] ^ 2.0 - 2.0 ‚â• 0\n\njulia> @NLconstraint(model, con[i = 1:2], prod(x[j] for j = 1:i) == i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n (*)(x[1]) - 1.0 = 0\n x[1] * x[2] - 2.0 = 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nYou can only create nonlinear constraints with <=, >=, and ==. More general Nonlinear-in-Set constraints are not supported.","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-expression","page":"Nonlinear Modeling","title":"Create a nonlinear expression","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use @NLexpression to create nonlinear expression objects. The syntax is identical to @expression, except that the expression can contain nonlinear terms.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = @NLexpression(model, exp(x[1]) + sqrt(x[2]))\n\"Reference to nonlinear expression #1\"\n\njulia> my_anon_expr = @NLexpression(model, [i = 1:2], sin(x[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #2\"\n \"Reference to nonlinear expression #3\"\n\njulia> @NLexpression(model, my_expr[i = 1:2], sin(x[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #4\"\n \"Reference to nonlinear expression #5\"","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear expression can be used in @NLobjective, @NLconstraint, and even nested in other @NLexpressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, expr^2 + 1)\n\njulia> @NLconstraint(model, [i = 1:2], my_expr[i] <= i)\n2-element Array{ConstraintRef{Model,NonlinearConstraintIndex,ScalarShape},1}:\n subexpression[4] - 1.0 ‚â§ 0\n subexpression[5] - 2.0 ‚â§ 0\n\njulia> @NLexpression(model, nested[i = 1:2], sin(my_expr[i]))\n2-element Array{NonlinearExpression,1}:\n \"Reference to nonlinear expression #6\"\n \"Reference to nonlinear expression #7\"","category":"page"},{"location":"manual/nlp/#Create-a-nonlinear-parameter","page":"Nonlinear Modeling","title":"Create a nonlinear parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For nonlinear models only, JuMP offers a syntax for explicit \"parameter\" objects, which are constants in the model that can be efficiently updated between solves.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are declared by using the @NLparameter macro and may be indexed by arbitrary sets analogously to JuMP variables and expressions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The initial value of the parameter must be provided on the right-hand side of the == sign.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLparameter(model, p[i = 1:2] == i)\n2-element Array{NonlinearParameter,1}:\n \"Reference to nonlinear parameter #1\"\n \"Reference to nonlinear parameter #2\"","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nA parameter is not an optimization variable. It must be fixed to a value with ==. If you want a parameter that is <= or >=, create a variable instead using @variable.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use value and set_value to query or update the value of a parameter.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 2.0\n\njulia> set_value(p[2], 3.0)\n3.0\n\njulia> value.(p)\n2-element Array{Float64,1}:\n 1.0\n 3.0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nThere is no anonymous syntax for creating parameters.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters can be used within nonlinear macros only:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @objective(model, Max, p[1] * x)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::VariableRef)\n[...]\n\njulia> @NLobjective(model, Max, p[1] * x)\n\njulia> @expression(model, my_expr, p[1] * x^2)\nERROR: MethodError: no method matching *(::NonlinearParameter, ::GenericQuadExpr{Float64,VariableRef})\n[...]\n\njulia> @NLexpression(model, my_nl_expr, p[1] * x^2)\n\"Reference to nonlinear expression #1\"","category":"page"},{"location":"manual/nlp/#When-to-use-a-parameter","page":"Nonlinear Modeling","title":"When to use a parameter","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Nonlinear parameters are useful when solving nonlinear models in a sequence:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP, Ipopt\nmodel = Model(Ipopt.Optimizer)\nset_silent(model)\n@variable(model, z)\n@NLparameter(model, x == 1.0)\n@NLobjective(model, Min, (z - x)^2)\noptimize!(model)\n@show value(z) # Equals 1.0.\n\n# Now, update the value of x to solve a different problem.\nset_value(x, 5.0)\noptimize!(model)\n@show value(z) # Equals 5.0\nnothing #hide","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nUsing nonlinear parameters can be faster than creating a new model from scratch with updated data because JuMP is able to avoid repeating a number of steps in processing the model before handing it off to the solver.","category":"page"},{"location":"manual/nlp/#Syntax-notes","page":"Nonlinear Modeling","title":"Syntax notes","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The syntax accepted in nonlinear macros is more restricted than the syntax for linear and quadratic macros. We note some important points below.","category":"page"},{"location":"manual/nlp/#No-operator-overloading","page":"Nonlinear Modeling","title":"No operator overloading","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"There is no operator overloading provided to build up nonlinear expressions. For example, if x is a JuMP variable, the code 3x will return an AffExpr object that can be used inside of future expressions and linear constraints. However, the code sin(x) is an error. All nonlinear expressions must be inside of macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = sin(x) + 1\nERROR: sin is not defined for type AbstractVariableRef. Are you trying to build a nonlinear problem? Make sure you use @NLconstraint/@NLobjective.\n[...]\n\njulia> expr = @NLexpression(model, sin(x) + 1)\n\"Reference to nonlinear expression #1\"","category":"page"},{"location":"manual/nlp/#aux_trick","page":"Nonlinear Modeling","title":"AffExpr and QuadExpr cannot be used","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"AffExpr and QuadExpr objects cannot currently be used inside nonlinear  expressions. Instead, introduce auxiliary variables, e.g.:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @expression(model, my_expr, c' * x + 3y)\nx[1] + 2 x[2] + 3 y\n\njulia> @NLobjective(model, Min, sin(my_expr))\nERROR: Unexpected affine expression x[1] + 2 x[2] + 3 y in nonlinear expression. Affine expressions (e.g., created using @expression) and nonlinear expressions cannot be mixed.\n[...]\n\njulia> aux = @variable(model)\nnoname\n\njulia> @constraint(model, aux == my_expr)\n-x[1] - 2 x[2] - 3 y + noname = 0.0\n\njulia> @NLobjective(model, Min, sin(aux))","category":"page"},{"location":"manual/nlp/#Scalar-operations-only","page":"Nonlinear Modeling","title":"Scalar operations only","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"With the exception of the splatting syntax discussed below, all expressions must be simple scalar operations. You cannot use dot, matrix-vector products, vector slices, etc. Translate vector operations into explicit sum() operations or use the AffExpr plus the auxiliary variable trick.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, c' * x + 3y)\nERROR: Unexpected array [1 2] in nonlinear expression. Nonlinear expressions may contain only scalar expressions.\n[...]\n\njulia> @NLobjective(model, Min, sum(c[i] * x[i] for i = 1:2) + 3y)","category":"page"},{"location":"manual/nlp/#Splatting","page":"Nonlinear Modeling","title":"Splatting","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The splatting operator   ... is recognized in a very restricted setting for expanding function   arguments. The expression splatted can be only a symbol. More complex   expressions are not recognized.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x[1:3]);\n\njulia> @NLconstraint(model, *(x...) <= 1.0)\nx[1] * x[2] * x[3] - 1.0 ‚â§ 0\n\njulia> @NLconstraint(model, *((x / 2)...) <= 0.0)\nERROR: LoadError: Unexpected expression in (*)(x / 2...). JuMP supports splatting only symbols. For example, x... is ok, but (x + 1)..., [x; y]... and g(f(y)...) are not.","category":"page"},{"location":"manual/nlp/#User-defined-Functions","page":"Nonlinear Modeling","title":"User-defined Functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP's library of recognized univariate functions is derived from the Calculus.jl package.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to this list of functions, it is possible to register custom user-defined nonlinear functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nUser-defined functions can be used anywhere in @NLobjective, @NLconstraint, and @NLexpression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nJuMP will attempt to automatically register functions it detects in your nonlinear expressions, which means that in most cases, manually registering a function is not needed. Two exceptions are if you want to provide custom derivatives, or if the function is not available in the scope of the nonlinear expression.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions must return a scalar output. For a work-around, see User-defined functions with vector outputs.","category":"page"},{"location":"manual/nlp/#Automatic-differentiation","page":"Nonlinear Modeling","title":"Automatic differentiation","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Fortunately, JuMP supports automatic differentiation of user-defined functions, a feature to our knowledge not available in any comparable modeling systems.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"info: Info\nAutomatic differentiation is not finite differencing. JuMP's automatically computed derivatives are not subject to approximation error.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"JuMP uses ForwardDiff.jl to perform automatic differentiation; see the ForwardDiff.jl documentation for a description of how to write a function suitable for automatic differentiation.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nGet an error like No method matching Float64(::ForwardDiff.Dual)? Read this section, and see the guidelines at ForwardDiff.jl.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The most common error is that your user-defined function is not generic with respect to the number type, i.e., don't assume that the input to the function is Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Float64) = 2 * x  # This will not work.\nf(x::Real)    = 2 * x  # This is good.\nf(x)          = 2 * x  # This is also good.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Another reason you may encounter this error is if you create arrays inside your function which are Float64.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"function bad_f(x...)\n    y = zeros(length(x))  # This constructs an array of `Float64`!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend\n\nfunction good_f(x::T...) where {T<:Real}\n    y = zeros(T, length(x))  # Construct an array of type `T` instead!\n    for i = 1:length(x)\n        y[i] = x[i]^i\n    end\n    return sum(y)\nend","category":"page"},{"location":"manual/nlp/#Register-a-function","page":"Nonlinear Modeling","title":"Register a function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"To register a user-defined function with derivatives computed by automatic differentiation, use the register method as in the following example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nsquare(x) = x^2\nf(x, y) = (x - 1)^2 + (y - 2)^2\n\nmodel = Model()\n\nregister(model, :square, 1, square; autodiff = true)\nregister(model, :my_f, 2, f; autodiff = true)\n\n@variable(model, x[1:2] >= 0.5)\n@NLobjective(model, Min, my_f(x[1], square(x[2])))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The above code creates a JuMP model with the objective function (x[1] - 1)^2 + (x[2]^2 - 2)^2. The arguments to register are:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The model for which the functions are registered.\nA Julia symbol object which serves as the name of the user-defined function in JuMP expressions.\nThe number of input arguments that the function takes.\nThe Julia method which computes the function\nA flag to instruct JuMP to compute exact gradients automatically.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nThe symbol :my_f doesn't have to match the name of the function f. However, it's generally more readable if it does. Make sure you use my_f and not f in the macros.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nIf you use multi-variate user-defined functions, JuMP will disable second-derivative information. This can lead to significant slow-downs in some cases. Only use a user-defined function if you cannot write out the expression algebraically in the macro.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nUser-defined functions cannot be re-registered and will not update if you modify the underlying Julia function. If you want to change a user-defined function between solves, rebuild the model or use a different name. To use a different name programmatically, see Raw expression input.","category":"page"},{"location":"manual/nlp/#Register-a-function-and-gradient","page":"Nonlinear Modeling","title":"Register a function and gradient","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients.","category":"page"},{"location":"manual/nlp/#Univariate-functions","page":"Nonlinear Modeling","title":"Univariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For univariate functions, the gradient function ‚àáf should return a number that represents the first-order derivative:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n‚àáf(x) = 2x\nmodel = Model()\nregister(model, :my_square, 1, f, ‚àáf; autodiff = true)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"If autodiff = true, JuMP will use automatic differentiation to compute the hessian.","category":"page"},{"location":"manual/nlp/#Multivariate-functions","page":"Nonlinear Modeling","title":"Multivariate functions","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For multivariate functions, the gradient function ‚àáf must take a gradient vector as the first argument that is filled in-place:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x, y) = (x - 1)^2 + (y - 2)^2\nfunction ‚àáf(g::Vector{T}, x::T, y::T) where {T}\n    g[1] = 2 * (x - 1)\n    g[2] = 2 * (y - 2)\n    return\nend\n\nmodel = Model()\nregister(model, :my_square, 2, f, ‚àáf)\n@variable(model, x[1:2] >= 0)\n@NLobjective(model, Min, my_square(x[1], x[2]))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Hessian information is not supported for multivariate functions.","category":"page"},{"location":"manual/nlp/#Register-a-function,-gradient,-and-hessian","page":"Nonlinear Modeling","title":"Register a function, gradient, and hessian","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThe ability to explicitly register a hessian is only available for univariate functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Instead of automatically differentiating the hessian, you can instead pass a function which returns a number representing the second-order derivative.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nf(x) = x^2\n‚àáf(x) = 2x\n‚àá¬≤f(x) = 2\nmodel = Model()\nregister(model, :my_square, 1, f, ‚àáf, ‚àá¬≤f)\n@variable(model, x >= 0)\n@NLobjective(model, Min, my_square(x))","category":"page"},{"location":"manual/nlp/#User-defined-functions-with-vector-inputs","page":"Nonlinear Modeling","title":"User-defined functions with vector inputs","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"User-defined functions which take vectors as input arguments (e.g. f(x::Vector)) are not supported. Instead, use Julia's splatting syntax to create a function with scalar arguments. For example, instead of","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x::Vector) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"define:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"f(x...) = sum(x[i]^i for i in 1:length(x))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This function f can be used in a JuMP model as follows:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"using JuMP #hide\nmodel = Model()\n@variable(model, x[1:5] >= 0)\nf(x...) = sum(x[i]^i for i in 1:length(x))\nregister(model, :f, 5, f; autodiff = true)\n@NLobjective(model, Min, f(x...))","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"tip: Tip\nMake sure to read the syntax restrictions of Splatting.","category":"page"},{"location":"manual/nlp/#Factors-affecting-solution-time","page":"Nonlinear Modeling","title":"Factors affecting solution time","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Total CPU secs in IPOPT (w/o function evaluations)   =      7.412\nTotal CPU secs in NLP function evaluations           =      2.083","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see Installation Guide. For other solvers, see their respective documentation for performance tips.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix [1]. As a conservative bound, JuMP's performance here currently may be expected to be within a factor of 5 of AMPL's.","category":"page"},{"location":"manual/nlp/#Querying-derivatives-from-a-JuMP-model","page":"Nonlinear Modeling","title":"Querying derivatives from a JuMP model","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For some advanced use cases, one may want to directly query the derivatives of a JuMP model instead of handing the problem off to a solver. Internally, JuMP implements the AbstractNLPEvaluator interface from MathOptInterface. To obtain an NLP evaluator object from a JuMP model, use NLPEvaluator. index returns the MOI.VariableIndex corresponding to a JuMP variable. MOI.VariableIndex itself is a type-safe wrapper for Int64 (stored in the .value field.)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"raw_index(v::MOI.VariableIndex) = v.value\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\n@NLobjective(model, Min, sin(x) + sin(y))\nvalues = zeros(2)\nx_index = raw_index(JuMP.index(x))\ny_index = raw_index(JuMP.index(y))\nvalues[x_index] = 2.0\nvalues[y_index] = 3.0\nd = NLPEvaluator(model)\nMOI.initialize(d, [:Grad])\nMOI.eval_objective(d, values) # == sin(2.0) + sin(3.0)\n\n# output\n1.0504174348855488","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"‚àáf = zeros(2)\nMOI.eval_objective_gradient(d, ‚àáf, values)\n(‚àáf[x_index], ‚àáf[y_index]) # == (cos(2.0), cos(3.0))\n\n# output\n(-0.4161468365471424, -0.9899924966004454)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Only nonlinear constraints (those added with @NLconstraint), and nonlinear objectives (added with @NLobjective) exist in the scope of the NLPEvaluator.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The NLPEvaluator does not evaluate derivatives of linear or quadratic constraints or objectives.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"The index method applied to a nonlinear constraint reference object returns its index as a NonlinearConstraintIndex. The .value field of NonlinearConstraintIndex stores the raw integer index. For example:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> model = Model();\n\njulia> @variable(model, x);\n\njulia> @NLconstraint(model, cons1, sin(x) <= 1);\n\njulia> @NLconstraint(model, cons2, x + 5 == 10);\n\njulia> typeof(cons1)\nConstraintRef{Model,NonlinearConstraintIndex,ScalarShape}\n\njulia> index(cons1)\nNonlinearConstraintIndex(1)\n\njulia> index(cons2)\nNonlinearConstraintIndex(2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"# TODO: Provide a link for how to access the linear and quadratic parts of the\n# model.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This method of querying derivatives directly from a JuMP model is convenient for interacting with the model in a structured way, e.g., for accessing derivatives of specific variables. For example, in statistical maximum likelihood estimation problems, one is often interested in the Hessian matrix at the optimal solution, which can be queried using the NLPEvaluator.","category":"page"},{"location":"manual/nlp/#Raw-expression-input","page":"Nonlinear Modeling","title":"Raw expression input","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"warning: Warning\nThis section requires advanced knowledge of Julia's Expr. You should read the Expressions and evaluation section of the Julia documentation first.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"In addition to the @NLobjective and @NLconstraint macros, it is also possible to provide Julia Expr objects directly by using set_NL_objective and add_NL_constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This input form may be useful if the expressions are generated programmatically.","category":"page"},{"location":"manual/nlp/#Set-the-objective-function","page":"Nonlinear Modeling","title":"Set the objective function","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use set_NL_objective to set a nonlinear objective.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> set_NL_objective(model, MOI.MIN_SENSE, expr)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLobjective(model, Min, x + x^2)","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must interpolate the variables directly into the expression expr.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"note: Note\nYou must use MOI.MIN_SENSE or MOI.MAX_SENSE instead of Min and Max.","category":"page"},{"location":"manual/nlp/#Add-a-constraint","page":"Nonlinear Modeling","title":"Add a constraint","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Use add_NL_constraint to add a nonlinear constraint.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> expr = :($(x) + $(x)^2)\n:(x + x ^ 2)\n\njulia> add_NL_constraint(model, :($(expr) <= 1))\n(x + x ^ 2.0) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"This is equivalent to","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> @NLconstraint(model, Min, x + x^2 <= 1)\n(x + x ^ 2.0) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/#More-complicated-examples","page":"Nonlinear Modeling","title":"More complicated examples","text":"","category":"section"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"Raw expression input is most useful when the expressions are generated programmatically, often in conjunction with user-defined functions.","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As an example, we construct a model with the nonlinear constraints f(x) <= 1, where f(x) = x^2 and f(x) = sin(x)^2:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               add_NL_constraint(model, :($(f_sym)($(x)) <= 1))\n           end\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n f_1(x) - 1.0 ‚â§ 0\n f_2(x) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"As another example, we construct a model with the constraint x^2 + sin(x)^2 <= 1:","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"julia> function main(functions::Vector{Function})\n           model = Model()\n           @variable(model, x)\n           expr = Expr(:call, :+)\n           for (i, f) in enumerate(functions)\n               f_sym = Symbol(\"f_$(i)\")\n               register(model, f_sym, 1, f; autodiff = true)\n               push!(expr.args, :($(f_sym)($(x))))\n           end\n           add_NL_constraint(model, :($(expr) <= 1))\n           print(model)\n           return\n       end\nmain (generic function with 1 method)\n\njulia> main([x -> x^2, x -> sin(x)^2])\nFeasibility\nSubject to\n (f_1(x) + f_2(x)) - 1.0 ‚â§ 0","category":"page"},{"location":"manual/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"[1]: Dunning, Huchette, and Lubin, \"JuMP: A Modeling Language for Mathematical Optimization\", SIAM Review, PDF.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/experiment_design.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#Experiment-Design","page":"Experiment Design","title":"Experiment Design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Originally Contributed by: Arpit Bhatia, Chris Coey","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"This tutorial covers experiment design examples (D-optimal, A-optimal, and E-optimal) from section 7.5 of the book Convex Optimization by Boyd and Vandenberghe.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The tutorial uses the following packages","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"using JuMP\nimport SCS\nimport LinearAlgebra\nimport Random","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"We set a seed so the random numbers are repeatable:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Random.seed!(1234)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#Relaxed-Experiment-Design-Problem","page":"Experiment Design","title":"Relaxed Experiment Design Problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The basic experiment design problem is as follows.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Given the menu of possible choices for experiments, v_1 ldots v_p, and the total number m of experiments to be carried out, choose the numbers of each type of experiment, i.e., m_1 ldots m_p to make the error covariance E small (in  some sense).","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The variables m_1 ldots m_p must, of course, be integers and sum to m the given total number of experiments. This leads to the optimization problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=left(sum_j=1^p m_j v_j v_j^Tright)^-1 \ntextsubject to  m_i geq 0 \n sumlimits_i=1^p m_i = m \n m_i in mathbbZquad i=1ldotsp\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The basic experiment design problem can be a hard combinatorial problem when m, the total number of experiments, is comparable to n, since in this case the m_i are all small integers.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In the case when m is large compared to n, however, a good approximate solution can be found by ignoring, or relaxing, the constraint that the m_i are integers.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Let lambda_i=m_i  m which is the fraction of the total number of experiments for which a_j=v_i or the relative frequency of experiment i. We can express the error covariance in terms of lambda_i as:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"E=frac1mleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The vector lambda in mathbfR^p satisfies lambda succeq 0 mathbf1^T lambda=1 and also, each lambda_i is an integer multiple of 1  m. By ignoring this last constraint, we arrive at the problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nminleft(mathrmwrt mathbfS_+^nright)  E=(1  m)left(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject toquad  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Several scalarizations have been proposed for the experiment design problem, which is a vector optimization problem over the positive semidefinite cone.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"q = 4 # dimension of estimate space\np = 8 # number of experimental vectors\nnmax = 3 # upper bound on lambda\nn = 12\n\nV = randn(q, p)\n\neye = Matrix{Float64}(LinearAlgebra.I, q, q);\nnothing #hide","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#A-optimal-design","page":"Experiment Design","title":"A-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In A-optimal experiment design, we minimize tr E, the trace of the covariance matrix. This objective is simply the mean of the norm of the error squared:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"mathbfEe_2^2=mathbfE operatornametrleft(e e^Tright)=operatornametr E","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The A-optimal experiment design problem in SDP form is","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  mathbf1^T u \ntextsubject to  leftbeginalignedsum_i=1^p lambda_i v_i v_i^T  e_k  e_k^T  u_kendalignedright succeq 0 quad k=1 ldots n \n lambda succeq 0 \n  mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"aOpt = Model(SCS.Optimizer)\nset_silent(aOpt)\n@variable(aOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(aOpt, u[1:q], lower_bound = 0)\n@constraint(aOpt, sum(np) <= n)\nfor i = 1:q\n    matrix = [\n        V * LinearAlgebra.diagm(0 => np ./ n) * V' eye[:, i];\n        eye[i, :]' u[i]\n    ]\n    @SDconstraint(aOpt, matrix >= 0)\nend\n@objective(aOpt, Min, sum(u))\noptimize!(aOpt)\nobjective_value(aOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#E-optimal-design","page":"Experiment Design","title":"E-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"In E -optimal design, we minimize the norm of the error covariance matrix, i.e. the maximum eigenvalue of E.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"Since the diameter (twice the longest semi-axis) of the confidence ellipsoid mathcalE is proportional to E_2^1  2, minimizing E_2 can be interpreted geometrically as minimizing the diameter of the confidence ellipsoid.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"E-optimal design can also be interpreted as minimizing the maximum variance of q^T e, over all q with q_2=1. The E-optimal experiment design problem in SDP form is:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  t \ntextsubject to  sum_i=1^p lambda_i v_i v_i^T succeq t I \n lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"eOpt = Model(SCS.Optimizer)\nset_silent(eOpt)\n@variable(eOpt, 0 <= np[1:p] <= nmax)\n@variable(eOpt, t)\n@SDconstraint(eOpt, V * LinearAlgebra.diagm(0 => np ./ n) * V' - (t .* eye) >= 0)\n@constraint(eOpt, sum(np) <= n)\n@objective(eOpt, Max, t)\noptimize!(eOpt)\nobjective_value(eOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/#D-optimal-design","page":"Experiment Design","title":"D-optimal design","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"The most widely used scalarization is called D -optimal design, in which we minimize the determinant of the error covariance matrix E. This corresponds to designing the experiment to minimize the volume of the resulting confidence ellipsoid (for a fixed confidence level). Ignoring the constant factor 1  m in E, and taking the logarithm of the objective, we can pose this problem as convex optimization problem:","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"beginaligned\nmin  log operatornamedetleft(sum_i=1^p lambda_i v_i v_i^Tright)^-1 \ntextsubject to  lambda succeq 0 \n mathbf1^T lambda=1\nendaligned","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"dOpt = Model(SCS.Optimizer)\nset_silent(dOpt)\n@variable(dOpt, np[1:p], lower_bound = 0, upper_bound = nmax)\n@variable(dOpt, t)\n@objective(dOpt, Max, t)\n@constraint(dOpt, sum(np) <= n)\nE = V * LinearAlgebra.diagm(0 => np ./ n) * V'\n@constraint(\n    dOpt,\n    [t, 1, (E[i, j] for i in 1:q for j in 1:i)...] in MOI.LogDetConeTriangle(q)\n)\noptimize!(dOpt)\nobjective_value(dOpt)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"value.(np)","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/experiment_design/","page":"Experiment Design","title":"Experiment Design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Optimization concepts/benders_decomposition.jl\"","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Benders-Decomposition","page":"Benders Decomposition","title":"Benders Decomposition","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Originally Contributed by: Shuvomoy Das Gupta","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"This notebook describes how to implement Benders decomposition in JuMP, which is a large scale optimization scheme.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We only discuss the classical approach (using loops) here. The approach using lazy constraints is showed in the corresponding tutorial.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"To illustrate an implementation of the Benders decomposition in JuMP, we apply it to the following general mixed integer problem:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\n textmaximize quad c_1^T x+c_2^T v \n textsubject to quad A_1 x+ A_2 v preceq b \n x succeq 0 x in mathbbZ^n \n v succeq 0 v in mathbbR^p \nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"where b in mathbbR^m, A_1 in mathbbR^m times n, A_2 in mathbbR^m times p and mathbbZ is the set of integers.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Here the symbol succeq (preceq) stands for element-wise greater (less) than or equal to. Any mixed integer programming problem can be written in the form above.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We want to write the Benders decomposition algorithm for the problem above. Consider the polyhedron u in mathbbR^m A_2^T u succeq 0 u succeq 0. Assume the set of vertices and extreme rays of the polyhedron is denoted by P and Q respectively.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Assume on the kth iteration the subset of vertices of the polyhedron mentioned is denoted by T(k) and the subset of extreme rays are denoted by Q(k), which will be generated by the Benders decomposition problem below.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Benders-decomposition-algorithm","page":"Benders Decomposition","title":"Benders decomposition algorithm","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 1 (Initialization)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"We start with T(1)=Q(1)=emptyset. Let f_m^(1) be arbitrarily large and x^(1) be any non-negative integer vector and go to Step 2.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 2 (Solving the master problem)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Solve the master problem, f_textm^(k) =","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\ntextmaximize quad t \ntextsubject to quad forall baru in T(k) qquad t + (A_1^T baru - c_1)^T x leq b^T baru \n  forall bary in Q(k) qquad (A_1 ^T bary)^T x leq b^T bary \n  qquad qquad qquad  x succeq 0 x in mathbbZ^n\nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let the maximizer corresponding to the objective value f_textm^(k) be denoted by x^(k). Now there are three possibilities:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"If f_textm^(k)=-infty, i.e., the master problem is infeasible, then the original proble is infeasible and sadly, we are done.\nIf f_textm^(k)=infty, i.e. the master problem is unbounded above, then we take f_textm^(k) to be arbitrarily large and x^(k) to be a corresponding feasible solution. Go to Step 3.\nIf f_textm^(k) is finite, then we collect t^(k) and x^(k) and go to Step 3.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Step 3 (Solving the subproblem and add Benders cut when needed)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Solve the subproblem, f_s(x^(k)) =","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"beginaligned\n  c_1^T x^(k) +  textminimize   (b-A_1 x^(k))^T u \n   textsubject to  A_2^T u succeq c_2 \n    u succeq 0 u in mathbbR^m\nendaligned","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let the minimizer corresponding to the objective value f_s(x^(k)) be denoted by u^(k). There are three possibilities:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"If f_s(x^(k)) = infty, the original problem is either infeasible or unbounded. We quit from Benders algorithm and use special purpose algorithm to find a feasible solution if there exists one.\nIf f_s(x^(k)) = - infty, we arrive at an extreme ray y^(k). We add the Benders cut corresponding to this extreme ray (A_1 ^T y^(k))^T x leq b^T y^(k) to the master problem, i.e., Q(k+1)= Q(k) cup y^(k). Take k=k+1 and go to Step 3.\nIf f_s(x^(k)) is finite, then\nIf f_s(x^(k))=f_m^(k) we arrive at the optimal solution.  The optimum objective value of the original problem is f_s(x^(k))=f_m^(k),  an optimal x is x^(k) and an optimal v is the dual values for the  second constraints of the subproblem. We are happily done!\nIf f_s(x^(k))  f_m^(k) we get an suboptimal vertex u^(k). We add  the corresponding Benders cut u_0 + (A_1^T u^(k) - c_1)^T x leq b^T u^(k)  to the master problem, i.e., T(k+1) = T(k) cup u^(k). Take k=k+1  and go to Step 3.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"For a more general approach to Bender's Decomposition you can have a look at Mathieu Besan√ßon's blog.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Data-for-the-problem","page":"Benders Decomposition","title":"Data for the problem","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"The input data is from page 139, Integer programming by Garfinkel and Nemhauser[1].","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"c1 = [-1; -4]\nc2 = [-2; -3]\n\ndim_x = length(c1)\ndim_u = length(c2)\n\nb = [-2; -3]\n\nA1 = [1 -3;\n     -1 -3]\nA2 = [1 -2;\n     -1 -1]\n\nM = 1000;\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#How-to-implement-the-Benders-decomposition-algorithm-in-JuMP","page":"Benders Decomposition","title":"How to implement the Benders decomposition algorithm in JuMP","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"There are two ways we can implement Benders decomposition in JuMP:","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Classical approach: Adding the Benders cuts in a loop,  and\nModern approach: Adding the Benders cuts as lazy constraints.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"The classical approach might be inferior to the modern one, as the solver","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"might revisit previously eliminated solution, and\nmight discard the optimal solution to the original problem in favor of a better but ultimately infeasible solution to the relaxed one.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"For more details on the comparison between the two approaches, see Paul Rubin's blog on Benders Decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Classical-Approach:-Adding-the-Benders-Cuts-in-a-Loop","page":"Benders Decomposition","title":"Classical Approach: Adding the Benders Cuts in a Loop","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Let's describe the master problem first. Note that there are no constraints, which we will added later using Benders decomposition.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Loading-the-necessary-packages","page":"Benders Decomposition","title":"Loading the necessary packages","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"using JuMP\nimport GLPK\nimport Test","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Master-Problem-Description","page":"Benders Decomposition","title":"Master Problem Description","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"master_problem_model = Model(GLPK.Optimizer);\nnothing #hide","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Variable-Definition","page":"Benders Decomposition","title":"Variable Definition","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"@variable(master_problem_model, 0 <= x[1:dim_x] <= 1e6, Int)\n@variable(master_problem_model, t <= 1e6)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#Objective-Setting","page":"Benders Decomposition","title":"Objective Setting","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"@objective(master_problem_model, Max, t)\nglobal iter_num = 1\n\nprint(master_problem_model)","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Here is the loop that checks the status of the master problem and the subproblem and then adds necessary Benders cuts accordingly.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"iter_num = 1\n\nwhile true\n    println(\"\\n-----------------------\")\n    println(\"Iteration number = \", iter_num)\n    println(\"-----------------------\\n\")\n    println(\"The current master problem is\")\n    print(master_problem_model)\n\n    optimize!(master_problem_model)\n\n    t_status = termination_status(master_problem_model)\n    p_status = primal_status(master_problem_model)\n\n    if p_status == MOI.INFEASIBLE_POINT\n        println(\"The problem is infeasible :-(\")\n        break\n    end\n\n    (fm_current, x_current) = if t_status == MOI.INFEASIBLE_OR_UNBOUNDED\n        (M, M * ones(dim_x))\n    elseif p_status == MOI.FEASIBLE_POINT\n        (value(t), value.(x))\n    else\n        error(\"Unexpected status: $((t_status, p_status))\")\n    end\n\n    println(\"Status of the master problem is \", t_status,\n            \"\\nwith fm_current = \", fm_current,\n            \"\\nx_current = \", x_current)\n\n    sub_problem_model = Model(GLPK.Optimizer)\n\n    c_sub = b - A1 * x_current\n\n    local u = @variable(sub_problem_model, u[1:dim_u] >= 0)\n\n    @constraint(\n        sub_problem_model,\n        constr_ref_subproblem[j = 1:size(A2, 2)],\n        A2[:, j]' * u >= c2[j],\n    )\n    # The second argument of @constraint macro,\n    # constr_ref_subproblem[j=1:size(A2,2)] means that the j-th constraint is\n    # referenced by constr_ref_subproblem[j].\n\n    @objective(sub_problem_model, Min, c1' * x_current + c_sub' * u)\n\n    print(\"\\nThe current subproblem model is \\n\")\n    print(sub_problem_model)\n\n    optimize!(sub_problem_model)\n\n    t_status_sub = termination_status(sub_problem_model)\n    p_status_sub = primal_status(sub_problem_model)\n\n    fs_x_current = objective_value(sub_problem_model)\n\n    u_current = value.(u)\n\n    Œ≥ = b' * u_current\n\n    println(\"Status of the subproblem is \", t_status_sub,\n        \"\\nwith fs_x_current = \", fs_x_current,\n        \"\\nand fm_current = \", fm_current)\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current == fm_current # we are done\n        Test.@test value(t) ‚âà -4 #hide\n        println(\"\\n################################################\")\n        println(\"Optimal solution of the original problem found\")\n        println(\"The optimal objective value t is \", fm_current)\n        println(\"The optimal x is \", x_current)\n                println(\"The optimal v is \", dual.(constr_ref_subproblem))\n        println(\"################################################\\n\")\n        break\n    end\n\n    if p_status_sub == MOI.FEASIBLE_POINT && fs_x_current < fm_current\n        println(\"\\nThere is a suboptimal vertex, add the corresponding constraint\")\n        cv = A1' * u_current - c1\n        @constraint(master_problem_model, t + cv' * x <= Œ≥)\n        println(\"t + \", cv, \"·µÄ x <= \", Œ≥)\n    end\n\n    if t_status_sub == MOI.INFEASIBLE_OR_UNBOUNDED\n        println(\"\\nThere is an  extreme ray, adding the corresponding constraint\")\n        ce = A1'* u_current\n        @constraint(master_problem_model, ce' * x <= Œ≥)\n        println(ce, \"·µÄ x <= \", Œ≥)\n    end\n\n    global iter_num += 1\nend","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/#References","page":"Benders Decomposition","title":"References","text":"","category":"section"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"<a id='c1'></a>","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"Garfinkel, R. & Nemhauser, G. L. Integer programming. (Wiley, 1972).","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"View this file on Github.","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"","category":"page"},{"location":"tutorials/Optimization concepts/benders_decomposition/","page":"Benders Decomposition","title":"Benders Decomposition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/an_introduction_to_julia.jl\"","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Getting-started-with-Julia","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since JuMP is embedded in Julia, knowing some basic Julia is important for learning JuMP. This tutorial is designed to provide a minimalist crash course in the basics of Julia. You can find resources that provide a more comprehensive introduction to Julia here.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Installing-Julia","page":"Getting started with Julia","title":"Installing Julia","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"To install Julia, download the latest stable release, then follow the platform specific install instructions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nUnless you know otherwise, you probably want the 64-bit version.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Next, you need an IDE to develop in. VS Code is a popular choice, so follow these install instructions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Numbers-and-arithmetic","page":"Getting started with Julia","title":"Numbers and arithmetic","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Since we want to solve optimization problems, we're going to be using a lot of math. Luckily, Julia is great for math, with all the usual operators:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show 1 + 1\n@show 1 - 2\n@show 2 * 2\n@show 4 / 5\n@show 3^2\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe @ in front of something indicates that it is a macro, which is just a special type of function. In this case, @show prints the expression as typed (e.g., 1 - 2), as well as the evaluation of the expression (-1).","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Did you notice how Julia didn't print .0 after some of the numbers? Julia is a dynamic language, which means you never have to explicitly declare the type of a variable. However, in the background, Julia is giving each variable a type. Check the type of something using the typeof function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"@show typeof(1)\n@show typeof(1.0)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Here 1 is an Int64, which is an integer with 64 bits of precision, and 1.0 is a Float64, which is a floating point number with 64-bits of precision.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nIf you aren't familiar with floating point numbers, make sure to read the Floating point numbers section.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We create complex numbers using im:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 2 + 1im\n@show real(x)\n@show imag(x)\n@show typeof(x)\n@show x * (1 - 2im)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nThe curly brackets surround what we call the parameters of a type. You can read Complex{Int64}  as \"a complex number, where the real and imaginary parts are represented by Int64.\" If we call typeof(1.0 + 2.0im) it will be Complex{Float64}, which a complex number with the parts represented by Float64.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"There are also some cool things like an irrational representation of œÄ.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"œÄ","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nTo make œÄ (and most other Greek letters), type \\pi and then press [TAB].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(œÄ)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"However, if we do math with irrational numbers, they get converted to Float64:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(2œÄ / 3)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Floating-point-numbers","page":"Getting started with Julia","title":"Floating point numbers","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nIf you aren't familiar with floating point numbers, make sure to read this section carefully.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A Float64 is a floating point approximation of a real number using 64-bits of information.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because it is an approximation, things we know hold true in mathematics don't hold true in a computer! For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 == 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) == ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet ‚àö by typing \\sqrt then press [TAB].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's see what the differences are:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 - 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) - ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"They are small, but not zero!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"One way of explaining this difference is to consider how we would write 1 / 3 and 2 / 3 using only four digits after the decimal point. We would write 1 / 3 as 0.3333, and 2 / 3 as 0.6667. So, despite the fact that 2 * (1 / 3) == 2 / 3, 2 * 0.3333 == 0.6666 != 0.6667.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Let's try that again using ‚âà (\\approx + [TAB]) instead of ==:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"0.1 * 3 ‚âà 0.3","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"sin(2œÄ / 3) ‚âà ‚àö3 / 2","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"‚âà is just a clever way of calling the isapprox function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isapprox(sin(2œÄ / 3), ‚àö3 / 2; atol = 1e-8)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"warning: Warning\nFloating point is the reason solvers use tolerances when they solve optimization models. A common mistake you're likely to make is checking whether a binary variable is 0 using value(z) == 0. Always remember to use something like isapprox when comparing floating point numbers.Gurobi has a good series of articles on the implications of floating point in optimization if you want to read more.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"If you aren't careful, floating point arithmetic can throw up all manner of issues. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"1 + 1e-16 == 1","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It even turns out that floating point numbers aren't associative!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"(1 + 1e-16) - 1e-16 == 1 + (1e-16 - 1e-16)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"It's important to note that this issue isn't Julia-specific. It happens in every programming language (try it out in Python).","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Vectors,-matrices-and-arrays","page":"Getting started with Julia","title":"Vectors, matrices and arrays","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Matlab, Julia has native support for vectors, matrices and tensors; all of which are represented by arrays of different dimensions. Vectors are constructed by comma-separated elements surrounded by square brackets:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b = [5, 6]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nArray{Int64, 1} means that this is an Array, with Int64 elements, and it has 1 dimension.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can by constructed with spaces separating the columns, and semicolons separating the rows:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A = [1.0 2.0; 3.0 4.0]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note how this time the type is Array{Float64, 2}; the elements are Float64 and there are 2 dimensions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can do linear algebra:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = A \\ b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nHere is floating point at work again! x is approximately [-4, 4.5].","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A * x ‚âà b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that when multiplying vectors and matrices, dimensions matter. For example, you can't multiply a vector by a vector:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try  #hide\nb * b\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But multiplying transposes works:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b' * b","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"b * b'","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Other-common-types","page":"Getting started with Julia","title":"Other common types","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Strings","page":"Getting started with Julia","title":"Strings","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Double quotes are used for strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"This is Julia\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Unicode is fine in strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(\"œÄ is about 3.1415\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Use println to print a string:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"println(\"Hello, World!\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can use $() to interpolate values into a string:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"x = 123\nprintln(\"The value of x is: $(x)\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Symbols","page":"Getting started with Julia","title":"Symbols","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia Symbols provide a way to make human readable unique identifiers:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":":my_id","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(:my_id)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can think of a Symbol as a String that takes up less memory, and that can't be modified.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Tuples","page":"Getting started with Julia","title":"Tuples","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia makes extensive use of a simple data structure called Tuples. Tuples are immutable collections of values. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (\"hello\", 1.2, :foo)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"typeof(t)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Tuples can be accessed by index, similar to arrays:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t[2]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"And they be \"unpacked\" like so:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"a, b, c = t\nb","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The values can also be given names, which is a convenient way of making light-weight data structures.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t = (word = \"hello\", num = 1.2, sym = :foo)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Values can be accessed using dot syntax:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"t.word","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Dictionaries","page":"Getting started with Julia","title":"Dictionaries","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to Python, Julia has native support for dictionaries. Dictionaries provide a very generic way of mapping keys to values.  For example, a map of integers to strings:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1 = Dict(1 => \"A\", 2 => \"B\", 4 => \"D\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nType-stuff again: Dict{Int64,String} is a dictionary with Int64 keys and String values.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Looking up a values uses the bracket syntax:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d1[2]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries support non-integer keys and can mix data types:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nJulia types form a hierarchy. Here the value type of the dictionary is Number, which is a generalization of Int64, Float64, and Complex{Int}. In general, having variables with \"Abstract\" types like Number can lead to slower code, so you should try to make sure every element in a dictionary or vector is the same type. For example, in this case we could represent every element as a Complex{Float64}:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"A\" => 1.0 + 0.0im, \"B\" => 2.5 + 0.0im, \"D\" => 2.0 - 3.0im)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dictionaries can be nested:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2 = Dict(\"A\" => 1, \"B\" => 2, \"D\" => Dict(:foo => 3, :bar => 4))","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"B\"]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"d2[\"D\"][:foo]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Loops","page":"Getting started with Julia","title":"Loops","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia has native support for for-each style loops with the syntax for <value> in <collection> end:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 1:5\n    println(i)\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"info: Info\nRanges are constructed as start:stop, or start:step:stop.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in [1.2, 2.3, 3.4, 4.5, 5.6]\n    println(i)\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This for-each loop also works with dictionaries:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for (key, value) in Dict(\"A\" => 1, \"B\" => 2.5, \"D\" => 2 - 3im)\n    println(\"$(key): $(value)\")\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Note that in contrast to vector languages like Matlab and R, loops do not result in a significant performance degradation in Julia.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Control-Flow","page":"Getting started with Julia","title":"Control Flow","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Julia control flow is similar to Matlab, using the keywords if-elseif-else-end, and the logical operators || and && for or and and respectively:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"for i in 0:3:15\n    if i < 5\n        println(\"$(i) is less than 5\")\n    elseif i < 10\n        println(\"$(i) is less than 10\")\n    else\n        if i == 10\n            println(\"the value is 10\")\n        else\n            println(\"$(i) is bigger than 10\")\n        end\n    end\nend","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Comprehensions","page":"Getting started with Julia","title":"Comprehensions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Similar to languages like Haskell and Python, Julia supports the use of simple loops in the construction of arrays and dictionaries, called comprehensions.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A list of increasing integers:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:5]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Matrices can be built by including multiple indices:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i * j for i in 1:5, j in 5:10]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Conditional statements can be used to filter out some values:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"[i for i in 1:10 if i % 2 == 1]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A similar syntax can be used for building dictionaries:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Dict(\"$(i)\" => i for i in 1:10 if i % 2 == 1)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Functions","page":"Getting started with Julia","title":"Functions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"A simple function is defined as follows:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_hello()\n    println(\"hello\")\nend\nprint_hello()","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Arguments can be added to a function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x)\n    println(x)\nend\nprint_it(\"hello\")\nprint_it(1.234)\nprint_it(:my_id)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Optional keyword arguments are also possible:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function print_it(x; prefix = \"value:\")\n    println(\"$(prefix) $(x)\")\nend\nprint_it(1.234)\nprint_it(1.234, prefix = \"val:\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The keyword return is used to specify the return values of a function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mult(x; y = 2.0)\n    return x * y\nend\n\nmult(4.0)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"mult(4.0, y = 5.0)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Anonymous-functions","page":"Getting started with Julia","title":"Anonymous functions","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The syntax input -> output creates an anonymous function. These are most useful when passed to other functions. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f = x -> x^2\nf(2)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"map(x -> x^2, 1:4)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Type-parameters","page":"Getting started with Julia","title":"Type parameters","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We can constrain the inputs to a function using type parameters, which are :: followed by the type of the input we want. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function foo(x::Int)\n    return x^2\nend\n\nfunction foo(x::Float64)\n    return exp(x)\nend\n\nfunction foo(x::Number)\n    return x + 1\nend\n\n@show foo(2)\n@show foo(2.0)\n@show foo(1 + 1im)\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"But what happens if we call foo with something we haven't defined it for?","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"try  #hide\nfoo([1, 2, 3])\ncatch err; showerror(stdout, err) end  #hide","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"We get a dreaded MethodError! A MethodError means that you passed a function something that didn't match the type that it was expecting. In this case, the error message says that it doesn't know how to handle an Array{Int64, 1}, but it does know how to handle Float64, Int64, and Number.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nRead the \"Closest candidates\" part of the error message carefully to get a hint as to what was expected.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Broadcasting","page":"Getting started with Julia","title":"Broadcasting","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In the example above, we didn't define what to do if f was passed an Array. Luckily, Julia provides a convenient syntax for mapping f element-wise over arrays! Just add a . between the name of the function and the opening (. This works for any function, including functions with multiple arguments. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"f.([1, 2, 3])","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nGet a MethodError when calling a function that takes an Array? Try broadcasting it!","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Mutable-vs-immutable-objects","page":"Getting started with Julia","title":"Mutable vs immutable objects","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Some types in Julia are mutable, which means you can change the values inside them. A good example is an array. You can modify the contents of an array without having to make a new array.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"In contrast, types like Float64 are immutable. You can't modify the contents of a Float64.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This is something to be aware of when passing types into functions. For example:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"function mutability_example(mutable_type::Vector{Int}, immutable_type::Int)\n    mutable_type[1] += 1\n    immutable_type += 1\n    return\nend\n\nmutable_type = [1, 2, 3]\nimmutable_type = 1\n\nmutability_example(mutable_type, immutable_type)\n\nprintln(\"mutable_type: $(mutable_type)\")\nprintln(\"immutable_type: $(immutable_type)\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Because Vector{Int} is a mutable type, modifying the variable inside the function changed the value outside of the function. In contrast, the change to immutable_type didn't modify the value outside the function.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can check mutability with the isimmutable function:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable([1, 2, 3])","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"isimmutable(1)","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#The-package-manager","page":"Getting started with Julia","title":"The package manager","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Installing-packages","page":"Getting started with Julia","title":"Installing packages","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"No matter how wonderful Julia's base language is, at some point you will want to use an extension package.  Some of these are built-in, for example random number generation is available in the Random package in the standard library. These packages are loaded with the commands using and import.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Random  # The equivalent of Python's `from Random import *`\nimport Random  # The equivalent of Python's `import Random`\n\nRandom.seed!(33)\n\n[rand() for i in 1:10]","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"The Package Manager is used to install packages that are not part of Julia's standard library.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For example the following can be used to install JuMP,","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"JuMP\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"For a complete list of registered Julia packages see the package listing at JuliaHub.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"From time to you may wish to use a Julia package that is not registered.  In this case a git repository URL can be used to install the package.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"using Pkg\nPkg.add(\"https://github.com/user-name/MyPackage.jl.git\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/#Package-environments","page":"Getting started with Julia","title":"Package environments","text":"","category":"section"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"By default, Pkg.add will add packages to Julia's global environment. However, Julia also has built-in support for virtual environments.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"Activate a virtual environment with:","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"import Pkg; Pkg.activate(\"/path/to/environment\")","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"You can see what packages are installed in the current environment with Pkg.status().","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"tip: Tip\nWe strongly recommend you create a Pkg environment for each project that you create in Julia, and add only the packages that you need, instead of adding lots of packages to the global environment. The Pkg manager documentation has more information on this topic.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"","category":"page"},{"location":"tutorials/Getting started/an_introduction_to_julia/","page":"Getting started with Julia","title":"Getting started with Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/min_distortion.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/#The-minimum-distortion-problem","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This example arises from computational geometry, in particular the problem of embedding a general finite metric space into a euclidean space.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"It is known that the 4-point metric space defined by the star graph:","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"x\n \\\\\n  x ‚Äî x\n /\nx","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"where distances are computed by length of the shortest path between vertices, cannot be exactly embedded into a euclidean space of any dimension.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Here we will formulate and solve an SDP to compute the best possible embedding, that is, the embedding f() that minimizes the distortion c such that","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"(1 / c) * D(a, b) ‚â§ ||f(a) - f(b)|| ‚â§ D(a, b)","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"for all points (a, b), where D(a, b) is the distance in the metric space.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"Any embedding can be characterized by its Gram matrix Q, which is PSD, and","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"||f(a) - f(b)||^2 = Q[a, a] + Q[b, b] - 2 * Q[a, b]","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"We can therefore constrain","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"D[i, j]^2 ‚â§ Q[i, i] + Q[j, j] - 2 * Q[i, j] ‚â§ c^2 * D[i, j]^2","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"and minimize c^2, which gives us the SDP formulation below.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"For more detail, see \"Lectures on discrete geometry\" by J. Matou≈°ek, Springer, 2002, pp. 378-379.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"using JuMP\nimport SCS\nimport Test\n\nfunction example_min_distortion()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    D = [\n        0.0 1.0 1.0 1.0;\n        1.0 0.0 2.0 2.0;\n        1.0 2.0 0.0 2.0;\n        1.0 2.0 2.0 0.0\n    ]\n    @variable(model, c¬≤ >= 1.0)\n    @variable(model, Q[1:4, 1:4], PSD)\n    for i in 1:4\n        for j in (i + 1):4\n            @constraint(model, D[i, j]^2 <= Q[i, i] + Q[j, j] - 2 * Q[i, j])\n            @constraint(model, Q[i, i] + Q[j, j] - 2 * Q[i, j] <= c¬≤ * D[i, j]^2)\n        end\n    end\n    @objective(model, Min, c¬≤)\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 4/3 atol = 1e-4\n    return\nend\n\nexample_min_distortion()","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/min_distortion/","page":"The minimum distortion problem","title":"The minimum distortion problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/objectives/#ObjectiveAPI","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"More information can be found in the Objectives section of the manual.","category":"page"},{"location":"reference/objectives/#Objective-functions","page":"Objectives","title":"Objective functions","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"@objective\nobjective_function\nset_objective_function\nset_objective_coefficient\nset_objective\nobjective_function_type\nobjective_function_string\nshow_objective_function_summary","category":"page"},{"location":"reference/objectives/#JuMP.@objective","page":"Objectives","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programmatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programmatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx¬≤ - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"reference/objectives/#JuMP.objective_function","page":"Objectives","title":"JuMP.objective_function","text":"objective_function(model::Model,\n               T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function. Error if the objective is not convertible to type T.\n\nExamples\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, 2x + 1)\n2 x + 1\n\njulia> objective_function(model, AffExpr)\n2 x + 1\n\njulia> objective_function(model, QuadExpr)\n2 x + 1\n\njulia> typeof(objective_function(model, QuadExpr))\nGenericQuadExpr{Float64,VariableRef}\n\nWe see with the last two commands that even if the objective function is affine, as it is convertible to a quadratic function, it can be queried as a quadratic function and the result is quadratic.\n\nHowever, it is not convertible to a variable.\n\njulia> objective_function(model, VariableRef)\nERROR: InexactError: convert(MathOptInterface.SingleVariable, MathOptInterface.ScalarAffineFunction{Float64}(MathOptInterface.ScalarAffineTerm{Float64}[MathOptInterface.ScalarAffineTerm{Float64}(2.0, MathOptInterface.VariableIndex(1))], 1.0))\n[...]\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_function","page":"Objectives","title":"JuMP.set_objective_function","text":"set_objective_function(\n    model::Model,\n    func::Union{AbstractJuMPScalar, MathOptInterface.AbstractScalarFunction})\n\nSets the objective function of the model to the given function. See set_objective_sense to set the objective sense. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_coefficient","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(model::Model, variable::VariableRef, coefficient::Real)\n\nSet the linear objective coefficient associated with Variable to coefficient.\n\nNote: this function will throw an error if a nonlinear objective is set.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective","page":"Objectives","title":"JuMP.set_objective","text":"set_objective(model::AbstractModel, sense::MOI.OptimizationSense, func)\n\nThe functional equivalent of the @objective macro.\n\nSets the objective sense and objective function simultaneously, and is equivalent to:\n\nset_objective_sense(model, sense)\nset_objective_function(model, func)\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nset_objective(model, MOI.MIN_SENSE, x)\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_type","page":"Objectives","title":"JuMP.objective_function_type","text":"objective_function_type(model::Model)::AbstractJuMPScalar\n\nReturn the type of the objective function.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.objective_function_string","page":"Objectives","title":"JuMP.objective_function_string","text":"objective_function_string(print_mode, model::AbstractModel)::String\n\nReturn a String describing the objective function of the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.show_objective_function_summary","page":"Objectives","title":"JuMP.show_objective_function_summary","text":"show_objective_function_summary(io::IO, model::AbstractModel)\n\nWrite to io a summary of the objective function type.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#Objective-sense","page":"Objectives","title":"Objective sense","text":"","category":"section"},{"location":"reference/objectives/","page":"Objectives","title":"Objectives","text":"objective_sense\nset_objective_sense","category":"page"},{"location":"reference/objectives/#JuMP.objective_sense","page":"Objectives","title":"JuMP.objective_sense","text":"objective_sense(model::Model)::MathOptInterface.OptimizationSense\n\nReturn the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"reference/objectives/#JuMP.set_objective_sense","page":"Objectives","title":"JuMP.set_objective_sense","text":"set_objective_sense(model::Model, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the model to the given sense. See set_objective_function to set the objective function. These are low-level functions; the recommended way to set the objective is with the @objective macro.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/diet.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/#The-diet-problem","page":"The diet problem","title":"The diet problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"Solve the classic \"diet problem\", also known as the Stigler diet. The code is based on an example from Gurobi.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction print_solution(is_optimal, foods, buy)\n    println(\"RESULTS:\")\n    if is_optimal\n        for food in foods\n            println(\"  $(food) = $(value(buy[food]))\")\n        end\n    else\n        println(\"The solver did not find an optimal solution.\")\n    end\nend\n\nfunction example_diet(; verbose = true)\n    # Nutrition guidelines\n    categories = [\"calories\", \"protein\", \"fat\", \"sodium\"]\n    category_data = Containers.DenseAxisArray([\n        1800 2200;\n        91   Inf;\n        0    65;\n        0    1779\n        ], categories, [\"min\", \"max\"]\n    )\n    Test.@test category_data[\"protein\", \"min\"] == 91.0\n    Test.@test category_data[\"sodium\", \"max\"] == 1779.0\n    # Foods\n    foods = [\n        \"hamburger\", \"chicken\", \"hot dog\", \"fries\", \"macaroni\", \"pizza\",\n        \"salad\", \"milk\", \"ice cream\",\n    ]\n    cost = Containers.DenseAxisArray(\n        [2.49, 2.89, 1.50, 1.89, 2.09, 1.99, 2.49, 0.89, 1.59],\n        foods\n    )\n    food_data = Containers.DenseAxisArray(\n        [\n            410 24 26 730;\n            420 32 10 1190;\n            560 20 32 1800;\n            380  4 19 270;\n            320 12 10 930;\n            320 15 12 820;\n            320 31 12 1230;\n            100  8 2.5 125;\n            330  8 10 180\n        ], foods, categories\n    )\n    Test.@test food_data[\"hamburger\", \"calories\"] == 410.0\n    Test.@test food_data[\"milk\", \"fat\"] == 2.5\n    # Build model\n    model = Model(GLPK.Optimizer)\n    @variables(model, begin\n        # Variables for nutrition info\n        category_data[c, \"min\"] <= nutrition[c = categories] <= category_data[c, \"max\"]\n        # Variables for which foods to buy\n        buy[foods] >= 0\n    end)\n    # Objective - minimize cost\n    @objective(model, Min, sum(cost[f] * buy[f] for f in foods))\n    # Nutrition constraints\n    @constraint(model, [c in categories],\n        sum(food_data[f, c] * buy[f] for f in foods) == nutrition[c]\n    )\n    # Solve\n    if verbose\n        println(\"Solving original problem...\")\n    end\n    optimize!(model)\n    term_status = termination_status(model)\n    is_optimal = term_status == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) ‚âà 11.8288 atol = 1e-4\n    if verbose\n        print_solution(is_optimal, foods, buy)\n    end\n    # Limit dairy (note that the problem will become infeasible).\n    @constraint(model, buy[\"milk\"] + buy[\"ice cream\"] <= 6)\n    if verbose\n        println(\"Solving dairy-limited problem...\")\n    end\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.INFEASIBLE\n    Test.@test primal_status(model) == MOI.NO_SOLUTION\n    if verbose\n        print_solution(false, foods, buy)\n    end\n    return\nend\n\nexample_diet()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/diet/","page":"The diet problem","title":"The diet problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/geographic_clustering.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Geographical-Clustering","page":"Geographical Clustering","title":"Geographical Clustering","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Originally Contributed by: Matthew Helm (with help from Mathieu Tanneau on Julia Discourse)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"The goal of this exercise is to cluster n cities into k groups, minimizing the total pairwise distance between cities and ensuring that the variance in the total populations of each group is relatively small.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"This tutorial uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"using JuMP\nimport DataFrames\nimport GLPK\nimport LinearAlgebra","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"For this example, we'll use the 20 most populous cities in the United States.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"cities = DataFrames.DataFrame(\n    city = [\"New York, NY\", \"Los Angeles, CA\", \"Chicago, IL\", \"Houston, TX\", \"Philadelphia, PA\", \"Phoenix, AZ\", \"San Antonio, TX\", \"San Diego, CA\", \"Dallas, TX\", \"San Jose, CA\", \"Austin, TX\", \"Indianapolis, IN\", \"Jacksonville, FL\", \"San Francisco, CA\", \"Columbus, OH\", \"Charlotte, NC\", \"Fort Worth, TX\", \"Detroit, MI\", \"El Paso, TX\", \"Memphis, TN\"],\n    population = [8.405,3.884,2.718,2.195,1.553,1.513,1.409,1.355,1.257,0.998,0.885,0.843,0.842,0.837,0.822,0.792,0.792,0.688,0.674,0.653],\n    lat = [40.7127,34.0522,41.8781,29.7604,39.9525,33.4483,29.4241,32.7157,32.7766,37.3382,30.2671,39.7684,30.3321,37.7749,39.9611,35.2270,32.7554,42.3314,31.7775,35.1495],\n    lon = [-74.0059,-118.2436,-87.6297,-95.3698,-75.1652,-112.0740,-98.4936,-117.1610,-96.7969,-121.8863,-97.7430,-86.1580,-81.6556,-122.4194,-82.9987,-80.8431,-97.3307,-83.0457,-106.4424,-90.0489],\n)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Model-Specifics","page":"Geographical Clustering","title":"Model Specifics","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We will cluster these 20 cities into 3 different groups and we will assume that the ideal or target population P for a group is simply the total population of the 20 cities divided by 3:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"n = size(cities,1)\nk = 3\nP = sum(cities.population) / k","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Obtaining-the-distances-between-each-city","page":"Geographical Clustering","title":"Obtaining the distances between each city","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Let's compute the pairwise Haversine distance between each of the cities in our data set and store the result in a variable we'll call dm:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"\"\"\"\n    haversine(lat1, long1, lat2, long2, r = 6372.8)\n\nCompute the haversine distance between two points on a sphere of radius `r`,\nwhere the points are given by the latitude/longitude pairs `lat1/long1` and\n`lat2/long2` (in degrees).\n\"\"\"\nfunction haversine(lat1, long1, lat2, long2, r = 6372.8)\n    lat1, long1 = deg2rad(lat1), deg2rad(long1)\n    lat2, long2 = deg2rad(lat2), deg2rad(long2)\n    hav(a, b) = sin((b - a) / 2)^2\n    inner_term = hav(lat1, lat2) + cos(lat1) * cos(lat2) * hav(long1, long2)\n    d = 2 * r * asin(sqrt(inner_term))\n    # Round distance to nearest kilometer.\n    return round(Int, d)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Our distance matrix is symmetric so we'll convert it to a LowerTriangular matrix so that we can better interpret the objective value of our model:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"dm = LinearAlgebra.LowerTriangular([\n    haversine(cities.lat[i], cities.lon[i], cities.lat[j], cities.lon[j])\n    for i = 1:n, j = 1:n\n])","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Build-the-model","page":"Geographical Clustering","title":"Build the model","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now that we have the basics taken  care of, we can set up our model, create decision variables, add constraints, and then solve.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"First, we'll set up a model that leverages the Cbc solver. Next, we'll set up a binary variable x_ik that takes the value 1 if city i is in group k and 0 otherwise. Each city must be in a group, so we'll add the constraint sum_kx_ik = 1 for every i.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"model = Model(GLPK.Optimizer)\nset_silent(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, x[1:n, 1:k], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@constraint(model, [i = 1:n], sum(x[i, :]) == 1)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"To reduce symmetry, we fix the first city to belong to the first group.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"fix(x[1, 1], 1; force = true)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"The total population of a group k is Q_k = sum_ix_ikq_i where q_i is simply the ith value from the population column in our cities DataFrame. Let's add constraints so that alpha leq (Q_k - P) leq beta. We'll set alpha equal to -3 million and beta equal to 3. By adjusting these thresholds you'll find that there is a tradeoff between having relatively even populations between groups and having geographically close cities within each group. In other words, the larger the absolute values of alpha and beta, the closer together the cities in a group will be but the variance between the group populations will be higher.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, -3 <= population_diff[1:k] <= 3)\n@constraint(model, population_diff .== x' * cities.population .- P)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now we need to add one last binary variable z_ij to our model that we'll use to compute the total distance between the cities in our groups, defined as sum_ijd_ijz_ij. Variable z_ij will equal 1 if cities i and j are in the same group, and 0 if they are not in the same group.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"To ensure that z_ij = 1 if and only if cities i and j are in the same group, we add the constraints z_ij geq x_ik + x_jk - 1 for every pair ij and every k:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@variable(model, z[i = 1:n, j = 1:i], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"for k in 1:k, i in 1:n, j in 1:i\n    @constraint(model, z[i, j] >= x[i, k] + x[j, k] - 1)\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We can now add an objective to our model which will simply be to minimize the dot product of z and our distance matrix, dm.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"@objective(model, Min, sum(dm[i, j] * z[i, j] for i = 1:n, j = 1:i))","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"We can then call optimize! and review the results.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"optimize!(model)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/#Reviewing-the-Results","page":"Geographical Clustering","title":"Reviewing the Results","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"Now that we have results, we can add a column to our cities DataFrame for the group and then loop through our x variable to assign each city to its group. Once we have that, we can look at the total population for each group and also look at the cities in each group to verify that they are grouped by geographic proximity.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"cities.group = zeros(n)\n\nfor i = 1:n, j = 1:k\n    if round(Int, value(x[i, j])) == 1\n        cities.group[i] = j\n    end\nend\n\nfor group in DataFrames.groupby(cities, :group)\n    @show group\n    println(\"\")\n    @show sum(group.population)\n    println(\"\")\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/geographic_clustering/","page":"Geographical Clustering","title":"Geographical Clustering","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/factory_schedule.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/#The-factory-schedule-example","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This is a Julia translation of part 5 from \"Introduction to to Linear Programming with Python\" available at https://github.com/benalexkeen/Introduction-to-linear-programming","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"For 2 factories (A, B), minimize the cost of production over the course of 12 months while meeting monthly demand. Factory B has a planned outage during month 5.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"It was originally contributed by @Crghilardi.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_factory_schedule()\n   # Sets in the problem:\n   months, factories = 1:12, [:A, :B]\n   # This function takes a matrix and converts it to a JuMP container so we can\n   # refer to elements such as `d_max_cap[1, :A]`.\n   containerize(A::Matrix) = Containers.DenseAxisArray(A, months, factories)\n   # Maximum production capacity in (month, factory) [units/month]:\n   d_max_cap = containerize([\n         100000\t50000;\n         110000\t55000;\n         120000\t60000;\n         145000\t100000;\n         160000\t0;\n         140000\t70000;\n         155000\t60000;\n         200000\t100000;\n         210000\t100000;\n         197000\t100000;\n         80000\t120000;\n         150000\t150000;\n   ])\n   # Minimum production capacity in (month, factory) [units/month]:\n   d_min_cap = containerize([\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t0;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n         20000\t20000;\n   ])\n   # Variable cost of production in (month, factory) [$/unit]:\n   d_var_cost = containerize([\n         10\t5;\n         11\t4;\n         12\t3;\n         9\t5;\n         8\t0;\n         8\t6;\n         5\t4;\n         7\t6;\n         9\t8;\n         10\t11;\n         8\t10;\n         8\t12\n   ])\n   # Fixed cost of production in (month, factory) # [$/month]:\n   d_fixed_cost = containerize([\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t0;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600;\n         500\t600\n   ])\n   # Demand in each month [units/month]:\n   d_demand = [\n      120_000,\n      100_000,\n      130_000,\n      130_000,\n      140_000,\n      130_000,\n      150_000,\n      170_000,\n      200_000,\n      190_000,\n      140_000,\n      100_000,\n   ]\n   # The model!\n   model = Model(GLPK.Optimizer)\n   # Decision variables\n   @variables(model, begin\n      status[m in months, f in factories], Bin\n      production[m in months, f in factories], Int\n   end)\n   # The production cannot be less than minimum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] >= d_min_cap[m, f] * status[m, f],\n   )\n   # The production cannot be more that maximum capacity.\n   @constraint(\n      model,\n      [m in months, f in factories],\n      production[m, f] <= d_max_cap[m, f] * status[m, f],\n   )\n   # The production must equal demand in a given month.\n   @constraint(model, [m in months], sum(production[m, :]) == d_demand[m])\n   # Factory B is shut down during month 5, so production and status are both\n   # zero.\n   fix(status[5, :B], 0.0)\n   fix(production[5, :B], 0.0)\n   # The objective is to minimize the cost of production across all time\n   ##periods.\n   @objective(\n      model,\n      Min,\n      sum(\n         d_fixed_cost[m, f] * status[m, f] + d_var_cost[m, f] * production[m, f]\n         for m in months, f in factories\n      )\n   )\n   # Optimize the problem\n   optimize!(model)\n   # Check the solution!\n   Test.@testset \"Check the solution against known optimal\" begin\n      Test.@test termination_status(model) == MOI.OPTIMAL\n      Test.@test objective_value(model) == 12_906_400.0\n      Test.@test value.(production)[1, :A] == 70_000\n      Test.@test value.(status)[1, :A] == 1\n      Test.@test value.(status)[5, :B] == 0\n      Test.@test value.(production)[5, :B] == 0\n   end\n   println(\"The production schedule is:\")\n   println(value.(production))\n   return\nend\n\nexample_factory_schedule()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/factory_schedule/","page":"The factory schedule example","title":"The factory schedule example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"background/should_i_use/#Should-I-use-JuMP?","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP is an algebraic modeling language for mathematical optimization written in the Julia language.","category":"page"},{"location":"background/should_i_use/#When-should-I-use-JuMP?","page":"Should I use JuMP?","title":"When should I use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"You should use JuMP if you have a constrained optimization problem for which you can formulate a set of decision variables, a scalar objective function, and a set of constraints.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Key reasons to use JuMP include:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"User friendliness\nSyntax that mimics natural mathematical expressions. (See the section on algebraic modeling languages.)\nSpeed\nBenchmarking has shown that JuMP can create problems at similar speeds to special-purpose modeling languages such as AMPL.\nJuMP communicates with most solvers in memory, avoiding the need to write intermediary files.\nSolver independence\nJuMP uses a generic solver-independent interface provided by the MathOptInterface package, making it easy to change between a number of open-source and commercial optimization software packages (\"solvers\"). The Supported solvers section contains a table of the currently supported solvers.\nAccess to advanced algorithmic techniques\nEfficient in-memory LP re-solves which previously required using solver-specific and/or low-level C++ libraries.\nAccess to solver-independent and solver-dependent Callbacks.\nEase of embedding\nJuMP itself is written purely in Julia. Solvers are the only binary dependencies.\nAutomated install of many solver dependencies.\nJuMP provides automatic installation of many open-source solvers. This is different to modeling languages in Python which require you to download and install a solver yourself.\nBeing embedded in a general-purpose programming language makes it easy to solve optimization problems as part of a larger workflow (e.g., inside a simulation, behind a web server, or as a subproblem in a decomposition algorithm).\nAs a trade-off, JuMP's syntax is constrained by the syntax available in Julia.\nJuMP is MPL licensed, meaning that it can be embedded in commercial software that complies with the terms of the license.","category":"page"},{"location":"background/should_i_use/#When-should-I-not-use-JuMP?","page":"Should I use JuMP?","title":"When should I not use JuMP?","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP supports a broad range of optimization classes. However, there are still some that it doesn't support, or that are better supported by other software packages.","category":"page"},{"location":"background/should_i_use/#Black-box,-derivative-free,-or-unconstrained-optimization","page":"Should I use JuMP?","title":"Black-box, derivative free, or unconstrained optimization","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does support nonlinear programs with constraints and objectives containing user-defined functions. However, the functions must be automatically differentiable, or need to provide explicit derivatives. (See User-defined Functions for more information.)","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your function is a black-box that is non-differentiable (e.g., the output of a simulation written in C++), JuMP is not the right tool for the job. This also applies if you want to use a derivative free method.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Even if your problem is differentiable, if it is unconstrained there is limited benefit (and downsides in the form of more overhead) to using JuMP over tools which are only concerned with function minimization.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Optim.jl\nNLopt.jl","category":"page"},{"location":"background/should_i_use/#Multiobjective-programs","page":"Should I use JuMP?","title":"Multiobjective programs","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"If your problem has more than one objective, JuMP is not the right tool for the job. However, we're working on fixing this!.","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"vOptGeneric.jl","category":"page"},{"location":"background/should_i_use/#Disciplined-convex-programming","page":"Should I use JuMP?","title":"Disciplined convex programming","text":"","category":"section"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"JuMP does not support disciplined convex programming (DCP).","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Alternatives to consider are:","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"Convex.jl","category":"page"},{"location":"background/should_i_use/","page":"Should I use JuMP?","title":"Should I use JuMP?","text":"note: Note\nConvex.jl is also built on MathOptInterface, and shares the same set of underlying solvers. However, you input problems differently, and Convex.jl checks that the problem is DCP.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/models/#Create-a-model","page":"Models","title":"Create a model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Create a model by passing an optimizer to Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"or by calling set_optimizer on an empty Model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> set_optimizer(model, GLPK.Optimizer)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nJuMP uses \"optimizer\" as a synonym for \"solver.\" Our convention is to use \"solver\" to refer to the underlying software, and use \"optimizer\" to refer to the Julia object that wraps the solver. For example, GLPK is a solver, and GLPK.Optimizer is an optimizer.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nDon't know what the fields Model mode, CachingOptimizer state mean? Read the Backends section.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use optimizer_with_attributes to create an optimizer with some attributes initialized:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0))\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Alternatively, you can create a function which takes no arguments and returns an initialized Optimizer object:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> function my_optimizer()\n           model = GLPK.Optimizer()\n           MOI.set(model, MOI.RawParameter(\"msg_lev\"), 0)\n           return model\n       end\nmy_optimizer (generic function with 1 method)\n\njulia> model = Model(my_optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/#Print-the-model","page":"Models","title":"Print the model","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default, show(model) will print a summary of the problem.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(); @variable(model, x >= 0); @objective(model, Max, x);\n\njulia> model\nA JuMP Model\nMaximization problem with:\nVariable: 1\nObjective function type: VariableRef\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: x","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use print to print the formulation of the model (in IJulia, this will render as LaTeX.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> print(model)\nMax x\nSubject to\n x ‚â• 0.0","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nThis format is specific to JuMP. To write the model to a file, use write_to_file instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use latex_formulation to display the model in LaTeX form.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> latex_formulation(model)\n$$ \\begin{aligned}\n\\max\\quad & x\\\\\n\\text{Subject to} \\quad & x \\geq 0.0\\\\\n\\end{aligned} $$","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"In IJulia (and Documenter), ending a cell in with latex_formulation will render the model in LaTeX!","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"using JuMP                # hide\nmodel = Model()           # hide\n@variable(model, x >= 0)  # hide\n@objective(model, Max, x) # hide\nlatex_formulation(model)","category":"page"},{"location":"manual/models/#Turn-off-output","page":"Models","title":"Turn off output","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_silent and unset_silent to disable or enable printing output from the solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_silent(model)\ntrue\n\njulia> unset_silent(model)\nfalse","category":"page"},{"location":"manual/models/#Set-a-time-limit","page":"Models","title":"Set a time limit","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use set_time_limit_sec, unset_time_limit_sec, and time_limit_sec to manage time limits.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> set_time_limit_sec(model, 60.0)\n60.0\n\njulia> time_limit_sec(model)\n60.0\n\njulia> unset_time_limit_sec(model)\n\njulia> time_limit_sec(model)\n2.147483647e6","category":"page"},{"location":"manual/models/#Write-a-model-to-file","page":"Models","title":"Write a model to file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP can write models to a variety of file-formats using write_to_file and Base.write.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> write_to_file(model, \"model.mps\")\n\njulia> write(io, model; format = MOI.FileFormats.FORMAT_MPS)","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe supported file formats are defined by the MOI.FileFormats.FileFormat enum.julia> MOI.FileFormats.FileFormat\nEnum MathOptInterface.FileFormats.FileFormat:\nFORMAT_AUTOMATIC = 0\nFORMAT_CBF = 1\nFORMAT_LP = 2\nFORMAT_MOF = 3\nFORMAT_MPS = 4\nFORMAT_SDPA = 5","category":"page"},{"location":"manual/models/#Read-a-model-from-file","page":"Models","title":"Read a model from file","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"JuMP models can be created from file formats using read_from_file and Base.read.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = read_from_file(\"model.mps\")\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: GenericAffExpr{Float64,VariableRef}\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> seekstart(io);\n\njulia> model2 = read(io, Model; format = MOI.FileFormats.FORMAT_MPS)\nA JuMP Model\nMinimization problem with:\nVariables: 0\nObjective function type: GenericAffExpr{Float64,VariableRef}\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/models/#Backends","page":"Models","title":"Backends","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A JuMP Model is a thin layer around a backend of type MOI.ModelLike that stores the optimization problem and acts as the optimization solver.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"From JuMP, the MOI backend can be accessed using the backend function. Let's see what the backend of a JuMP Model is:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> b = backend(model)\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer MOIB.LazyBridgeOptimizer{GLPK.Optimizer}\n  with 0 variable bridges\n  with 0 constraint bridges\n  with 0 objective bridges\n  with inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The backend is a MOIU.CachingOptimizer in the state EMPTY_OPTIMIZER and mode AUTOMATIC.","category":"page"},{"location":"manual/models/#CachingOptimizer","page":"Models","title":"CachingOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"A MOIU.CachingOptimizer is an MOI layer that abstracts the difference between solvers that support incremental modification (e.g., they support adding variables one-by-one), and solvers that require the entire problem in a single API call (e.g., they only accept the A, b and c matrices of a linear program).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"It has two parts:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A cache, where the model can be built and modified incrementally\njulia> b.model_cache\nMOIU.UniversalFallback{MOIU.Model{Float64}}\nfallback for MOIU.Model{Float64}\nAn optimizer, which is used to solve the problem\njulia> b.optimizer\nMOIB.LazyBridgeOptimizer{GLPK.Optimizer}\nwith 0 variable bridges\nwith 0 constraint bridges\nwith 0 objective bridges\nwith inner model A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"info: Info\nThe LazyBridgeOptimizer section explains what a LazyBridgeOptimizer is.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The CachingOptimizer has logic to decide when to copy the problem from the cache to the optimizer, and when it can efficiently update the optimizer in-place.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer may be in one of three possible states:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"NO_OPTIMIZER: The CachingOptimizer does not have any optimizer.\nEMPTY_OPTIMIZER: The CachingOptimizer has an empty optimizer, and it is not synchronized with the cached model.\nATTACHED_OPTIMIZER: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A CachingOptimizer has two modes of operation:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"AUTOMATIC: The CachingOptimizer changes its state when necessary. For example, optimize! will automatically call attach_optimizer (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to EMPTY_OPTIMIZER mode.\nMANUAL: The user must change the state of the CachingOptimizer using MOIU.reset_optimizer(::JuMP.Model), MOIU.drop_optimizer(::JuMP.Model), and MOIU.attach_optimizer(::JuMP.Model). Attempting to perform an operation in the incorrect state results in an error.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"By default Model will create a CachingOptimizer in AUTOMATIC mode. Use the caching_mode keyword to create a model in MANUAL mode:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> Model(GLPK.Optimizer; caching_mode = MOI.Utilities.MANUAL)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: MANUAL\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nOnly use MANUAL mode if you have a very good reason. If you want to reduce the overhead between JuMP and the underlying solver, consider Direct mode instead.","category":"page"},{"location":"manual/models/#LazyBridgeOptimizer","page":"Models","title":"LazyBridgeOptimizer","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"The second layer that JuMP applies automatically is a LazyBridgeOptimizer. A LazyBridgeOptimizer is an MOI layer that attempts to transform constraints added by the user into constraints supported by the solver. This may involve adding new variables and constraints to the optimizer. The transformations are selected from a set of known recipes called bridges.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A common example of a bridge is one that splits an interval constrait like @constraint(model, 1 <= x + y <= 2) into two constraints, @constraint(model, x + y >= 1) and @constraint(model, x + y <= 2).","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"Use the bridge_constraints=false keyword to remove the bridging layer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = Model(GLPK.Optimizer; bridge_constraints = false)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> backend(model)\nMOIU.CachingOptimizer{MOI.AbstractOptimizer,MOIU.UniversalFallback{MOIU.Model{Float64}}}\nin state EMPTY_OPTIMIZER\nin mode AUTOMATIC\nwith model cache MOIU.UniversalFallback{MOIU.Model{Float64}}\n  fallback for MOIU.Model{Float64}\nwith optimizer A GLPK model","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"tip: Tip\nOnly disable bridges if you have a very good reason. If you want to reduce the overhead between JuMP and the underlying solver, consider Direct mode instead.","category":"page"},{"location":"manual/models/#Direct-mode","page":"Models","title":"Direct mode","text":"","category":"section"},{"location":"manual/models/","page":"Models","title":"Models","text":"Using a CachingOptimizer results in an additional copy of the model being stored by JuMP in the .model_cache field. To avoid this overhead, create a JuMP model using direct_model:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> model = direct_model(GLPK.Optimizer())\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: DIRECT\nSolver name: GLPK","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"warning: Warning\nSolvers that do not support incremental modification do not support direct_model. An error will be thrown, telling you to use a CachingOptimizer instead.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"The benefit of using direct_model is that there are no extra layers (e.g., Cachingoptimizer or LazyBridgeOptimizer) between model and the provided optimizer:","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> typeof(backend(model))\nGLPK.Optimizer","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"A downside of direct mode is that there is no bridging layer. Therefore, only constraints which are natively supported by the solver are supported. For example, GLPK.jl does not implement constraints of the form l <= a' x <= u.","category":"page"},{"location":"manual/models/","page":"Models","title":"Models","text":"julia> @variable(model, x[1:2]);\n\njulia> @constraint(model, 1 <= x[1] + x[2] <= 2)\nERROR: Constraints of type MathOptInterface.ScalarAffineFunction{Float64}-in-MathOptInterface.Interval{Float64} are not supported by the solver.\n[...]","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/steelT3.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/#The-SteelT3-problem","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"The steelT3 model from AMPL: A Modeling Language for Mathematical Programming, 2nd ed by Robert Fourer, David Gay, and Brian W. Kernighan.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"Originally contributed by Louis Luangkesorn, April 3, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"using JuMP\nimport GLPK\nimport Test\n\nfunction example_steelT3(; verbose = true)\n    T = 4\n    prod = [\"bands\", \"coils\"]\n    area = Dict(\n        \"bands\" => (\"east\", \"north\"),\n        \"coils\" => (\"east\", \"west\", \"export\")\n    )\n    avail = [40, 40, 32, 40]\n    rate = Dict(\"bands\" => 200, \"coils\" => 140)\n    inv0 = Dict(\"bands\" => 10, \"coils\" => 0)\n    prodcost = Dict(\"bands\" => 10, \"coils\" => 11)\n    invcost = Dict(\"bands\" => 2.5, \"coils\" => 3)\n    revenue = Dict(\n        \"bands\" => Dict(\n            \"east\" => [25.0, 26.0, 27.0, 27.0],\n            \"north\" => [26.5, 27.5, 28.0, 28.5],\n        ),\n        \"coils\" => Dict(\n            \"east\" =>[30, 35, 37, 39],\n            \"west\" => [29, 32, 33, 35],\n            \"export\" => [25, 25, 25, 28],\n        )\n    )\n    market = Dict(\n        \"bands\" => Dict(\n            \"east\" => [2000, 2000, 1500, 2000],\n            \"north\" => [4000, 4000, 2500, 4500],\n        ),\n        \"coils\" => Dict(\n            \"east\" => [1000, 800, 1000, 1100],\n            \"west\" => [2000, 1200, 2000, 2300],\n            \"export\" => [1000, 500, 500, 800],\n        )\n    )\n    # Model\n    model = Model(GLPK.Optimizer)\n    # Decision Variables\n    @variables(model, begin\n        make[p in prod, t in 1:T] >= 0\n        inventory[p in prod, t in 0:T] >= 0\n        0 <= sell[p in prod, a in area[p], t in 1:T] <= market[p][a][t]\n    end)\n    @constraints(model, begin\n        [p = prod, a = area[p], t = 1:T], sell[p, a, t] <= market[p][a][t]\n        # Total of hours used by all products may not exceed hours available,\n        # in each week\n        [t in 1:T], sum(1 / rate[p] * make[p, t] for p in prod) <= avail[t]\n        # Initial inventory must equal given value\n        [p in prod], inventory[p, 0] == inv0[p]\n        # Tons produced and taken from inventory must equal tons sold and put\n        # into inventory.\n        [p in prod, t in 1:T], make[p, t] + inventory[p, t - 1] == sum(sell[p, a, t] for a in area[p]) + inventory[p, t]\n    end)\n    # Maximize total profit: total revenue less costs for all products in all\n    # weeks.\n    @objective(\n        model,\n        Max,\n        sum(\n            revenue[p][a][t] * sell[p, a, t] -\n            prodcost[p] * make[p, t] -\n            invcost[p] * inventory[p, t]\n            for p in prod, a in area[p], t in 1:T\n        )\n    )\n    optimize!(model)\n    Test.@test termination_status(model) == MOI.OPTIMAL\n    Test.@test primal_status(model) == MOI.FEASIBLE_POINT\n    Test.@test objective_value(model) == 172850.0\n    if verbose\n        println(\"RESULTS:\")\n        for p in prod\n            println(\"make $(p)\")\n            for t in 1:T\n                print(value(make[p, t]), \"\\t\")\n            end\n            println()\n            println(\"Inventory $(p)\")\n            for t in 1:T\n                print(value(inventory[p, t]), \"\\t\")\n            end\n            println()\n            for a in area[p]\n                println(\"sell $(p) $(a)\")\n            for t in 1:T\n                print(value(sell[p, a, t]), \"\\t\")\n            end\n            println()\n            end\n        end\n    end\n    return\nend\n\nexample_steelT3()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/steelT3/","page":"The SteelT3 problem","title":"The SteelT3 problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/nlp/#NonlinearAPI","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"More information can be found in the Nonlinear Modeling section of the manual.","category":"page"},{"location":"reference/nlp/#ref_nl_constraints","page":"Nonlinear Modeling","title":"Constraints","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLconstraint\n@NLconstraints\nNonlinearConstraintIndex\nnum_nl_constraints\nadd_NL_constraint","category":"page"},{"location":"reference/nlp/#JuMP.@NLconstraint","page":"Nonlinear Modeling","title":"JuMP.@NLconstraint","text":"@NLconstraint(m::Model, expr)\n\nAdd a constraint described by the nonlinear expression expr. See also @constraint. For example:\n\n@NLconstraint(model, sin(x) <= 1)\n@NLconstraint(model, [i = 1:3], sin(i * x) <= 1 / i)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLconstraints","page":"Nonlinear Modeling","title":"JuMP.@NLconstraints","text":"@NLconstraints(model, args...)\n\nAdds multiple nonlinear constraints to model at once, in the same fashion as the @NLconstraint macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLconstraints(model, begin\n    t >= sqrt(x^2 + y^2)\n    [i = 1:2], z[i] <= log(a[i])\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearConstraintIndex","page":"Nonlinear Modeling","title":"JuMP.NonlinearConstraintIndex","text":"NonlinearConstraintIndex(index::Int64)\n\nA struct to refer to the 1-indexed nonlinear constraint index.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.num_nl_constraints","page":"Nonlinear Modeling","title":"JuMP.num_nl_constraints","text":"num_nl_constraints(model::Model)\n\nReturns the number of nonlinear constraints associated with the model.\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#JuMP.add_NL_constraint","page":"Nonlinear Modeling","title":"JuMP.add_NL_constraint","text":"add_NL_constraint(model::Model, expr::Expr)\n\nAdd a nonlinear constraint described by the Julia expression ex to model.\n\nThis function is most useful if the expression ex is generated programmatically, and you cannot use @NLconstraint.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\n\nExamples\n\njulia> add_NL_constraint(model, :($(x) + $(x)^2 <= 1))\n(x + x ^ 2.0) - 1.0 ‚â§ 0\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_expressions","page":"Nonlinear Modeling","title":"Expressions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLexpression\n@NLexpressions\nNonlinearExpression","category":"page"},{"location":"reference/nlp/#JuMP.@NLexpression","page":"Nonlinear Modeling","title":"JuMP.@NLexpression","text":"@NLexpression(args...)\n\nEfficiently build a nonlinear expression which can then be inserted in other nonlinear constraints and the objective. See also [@expression]. For example:\n\n@NLexpression(model, my_expr, sin(x)^2 + cos(x^2))\n@NLconstraint(model, my_expr + y >= 5)\n@NLobjective(model, Min, my_expr)\n\nIndexing over sets and anonymous expressions are also supported:\n\n@NLexpression(m, my_expr_1[i=1:3], sin(i * x))\nmy_expr_2 = @NLexpression(m, log(1 + sum(exp(x[i])) for i in 1:2))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.@NLexpressions","page":"Nonlinear Modeling","title":"JuMP.@NLexpressions","text":"@NLexpressions(model, args...)\n\nAdds multiple nonlinear expressions to model at once, in the same fashion as the @NLexpression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@NLexpressions(model, begin\n    my_expr, sqrt(x^2 + y^2)\n    my_expr_1[i = 1:2], log(a[i]) - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearExpression","page":"Nonlinear Modeling","title":"JuMP.NonlinearExpression","text":"NonlinearExpression\n\nA struct to represent a nonlinear expression.\n\nCreate an expression using @NLexpression.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#ref_nl_objectives","page":"Nonlinear Modeling","title":"Objectives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLobjective\nset_NL_objective","category":"page"},{"location":"reference/nlp/#JuMP.@NLobjective","page":"Nonlinear Modeling","title":"JuMP.@NLobjective","text":"@NLobjective(model, sense, expression)\n\nAdd a nonlinear objective to model with optimization sense sense. sense must be Max or Min.\n\nExample\n\n@NLobjective(model, Max, 2x + 1 + sin(x))\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.set_NL_objective","page":"Nonlinear Modeling","title":"JuMP.set_NL_objective","text":"set_NL_objective(model::Model, sense::MOI.OptimizationSense, expr::Expr)\n\nSet the nonlinear objective of model to the expression expr, with the optimization sense sense.\n\nThis function is most useful if the expression expr is generated programmatically, and you cannot use @NLobjective.\n\nNotes\n\nYou must interpolate the variables directly into the expression expr.\nYou must use MOI.MIN_SENSE or MOI.MAX_SENSE instead of Min and Max.\n\nExamples\n\njulia> set_NL_objective(model, MOI.MIN_SENSE, :($(x) + $(x)^2))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#ref_nl_parameters","page":"Nonlinear Modeling","title":"Parameters","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"@NLparameter\nNonlinearParameter\nvalue(::JuMP.NonlinearParameter)\nset_value(::JuMP.NonlinearParameter, ::Number)","category":"page"},{"location":"reference/nlp/#JuMP.@NLparameter","page":"Nonlinear Modeling","title":"JuMP.@NLparameter","text":"@NLparameter(model, param == value)\n\nCreate and return a nonlinear parameter param attached to the model model with initial value set to value. Nonlinear parameters may be used only in nonlinear expressions.\n\nExample\n\nmodel = Model()\n@NLparameter(model, x == 10)\nvalue(x)\n\n# output\n10.0\n\n@NLparameter(model, param_collection[...] == value_expr)\n\nCreate and return a collection of nonlinear parameters param_collection attached to the model model with initial value set to value_expr (may depend on index sets). Uses the same syntax for specifying index sets as @variable.\n\nExample\n\nmodel = Model()\n@NLparameter(model, y[i = 1:10] == 2 * i)\nvalue(y[9])\n\n# output\n18.0\n\n\n\n\n\n","category":"macro"},{"location":"reference/nlp/#JuMP.NonlinearParameter","page":"Nonlinear Modeling","title":"JuMP.NonlinearParameter","text":"NonlinearParameter\n\nA struct to represent a nonlinear parameter.\n\nCreate a parameter using @NLparameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/nlp/#JuMP.value-Tuple{NonlinearParameter}","page":"Nonlinear Modeling","title":"JuMP.value","text":"value(p::NonlinearParameter)\n\nReturn the current value stored in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 10)\nvalue(p)\n\n# output\n10.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#JuMP.set_value-Tuple{NonlinearParameter,Number}","page":"Nonlinear Modeling","title":"JuMP.set_value","text":"set_value(p::NonlinearParameter, v::Number)\n\nStore the value v in the nonlinear parameter p.\n\nExample\n\nmodel = Model()\n@NLparameter(model, p == 0)\nset_value(p, 5)\nvalue(p)\n\n# output\n5.0\n\n\n\n\n\n","category":"method"},{"location":"reference/nlp/#User-defined-functions","page":"Nonlinear Modeling","title":"User-defined functions","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"register","category":"page"},{"location":"reference/nlp/#JuMP.register","page":"Nonlinear Modeling","title":"JuMP.register","text":"register(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s.\n\nThe function f must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nFor this method, you must explicitly set autodiff = true, because no user-provided gradient function ‚àáf is given.\nSecond-derivative information is only computed if dimension == 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\nregister(model, :foo, 1, f; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nregister(model, :g, 2, g; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ‚àáf::Function;\n    autodiff:Bool = false,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ‚àáf.\n\nThe functions fand ‚àáf must support all subtypes of Real as arguments. Do not assume that the inputs are Float64.\n\nNotes\n\nIf the function f is univariate (i.e., dimension == 1), ‚àáf must return a number which represents the first-order derivative of the function f.\nIf the function f is multi-variate, ‚àáf must have a signature matching ‚àáf(g::Vector{T}, args::T...) where {T<:Real}, where the first argument is a vector g that is modified in-place with the gradient.\nIf autodiff = true and dimension == 1, use automatic differentiation to compute the second-order derivative information. If autodiff = false, only first-order derivative information will be used.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::T) where {T<:Real} = x^2\n‚àáf(x::T) where {T<:Real} = 2 * x\nregister(model, :foo, 1, f, ‚àáf; autodiff = true)\n@NLobjective(model, Min, foo(x))\n\nmodel = Model()\n@variable(model, x[1:2])\ng(x::T, y::T) where {T<:Real} = x * y\nfunction ‚àág(g::Vector{T}, x::T, y::T) where {T<:Real}\n    g[1] = y\n    g[2] = x\n    return\nend\nregister(model, :g, 2, g, ‚àág; autodiff = true)\n@NLobjective(model, Min, g(x[1], x[2]))\n\n\n\n\n\nregister(\n    model::Model,\n    s::Symbol,\n    dimension::Integer,\n    f::Function,\n    ‚àáf::Function,\n    ‚àá¬≤f::Function,\n)\n\nRegister the user-defined function f that takes dimension arguments in model as the symbol s. In addition, provide a gradient function ‚àáf and a hessian function ‚àá¬≤f.\n\n‚àáf and ‚àá¬≤f must return numbers corresponding to the first- and second-order derivatives of the function f respectively.\n\nNotes\n\nBecause automatic differentiation is not used, you can assume the inputs are all Float64.\nThis method will throw an error if dimension > 1.\ns does not have to be the same symbol as f, but it is generally more readable if it is.\n\nExamples\n\nmodel = Model()\n@variable(model, x)\nf(x::Float64) = x^2\n‚àáf(x::Float64) = 2 * x\n‚àá¬≤f(x::Float64) = 2.0\nregister(model, :foo, 1, f, ‚àáf, ‚àá¬≤f)\n@NLobjective(model, Min, foo(x))\n\n\n\n\n\n","category":"function"},{"location":"reference/nlp/#Derivatives","page":"Nonlinear Modeling","title":"Derivatives","text":"","category":"section"},{"location":"reference/nlp/","page":"Nonlinear Modeling","title":"Nonlinear Modeling","text":"NLPEvaluator","category":"page"},{"location":"reference/nlp/#JuMP.NLPEvaluator","page":"Nonlinear Modeling","title":"JuMP.NLPEvaluator","text":"NLPEvaluator(m::Model)\n\nReturn an MOI.AbstractNLPEvaluator constructed from the model model.\n\nBefore using, you must initialize the evaluator using MOI.initialize.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Nonlinear programs/mle.jl\"","category":"page"},{"location":"tutorials/Nonlinear programs/mle/#Maximum-likelihood-estimation","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"Use nonlinear optimization to compute the maximum likelihood estimate (MLE) of the parameters of a normal distribution, a.k.a., the sample mean and variance.","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"using JuMP\nimport Ipopt\nimport Random\nimport Statistics\nimport Test\n\nfunction example_mle(; verbose = true)\n    n = 1_000\n    Random.seed!(1234)\n    data = randn(n)\n    model = Model(Ipopt.Optimizer)\n    set_silent(model)\n    @variable(model, Œº, start = 0.0)\n    @variable(model, œÉ >= 0.0, start = 1.0)\n    @NLobjective(\n        model,\n        Max,\n        n / 2 * log(1 / (2 * œÄ * œÉ^2)) - sum((data[i] - Œº)^2 for i = 1:n) / (2 * œÉ^2)\n    )\n    optimize!(model)\n    if verbose\n        println(\"Œº             = \", value(Œº))\n        println(\"mean(data)    = \", Statistics.mean(data))\n        println(\"œÉ^2           = \", value(œÉ)^2)\n        println(\"var(data)     = \", Statistics.var(data))\n        println(\"MLE objective = \", objective_value(model))\n    end\n    Test.@test value(Œº) ‚âà Statistics.mean(data) atol = 1e-3\n    Test.@test value(œÉ)^2 ‚âà Statistics.var(data) atol = 1e-2\n    # You can even do constrained MLE!\n    @NLconstraint(model, Œº == œÉ^2)\n    optimize!(model)\n    Test.@test value(Œº) ‚âà value(œÉ)^2\n    if verbose\n        println()\n        println(\"With constraint Œº == œÉ^2:\")\n        println(\"Œº                         = \", value(Œº))\n        println(\"œÉ^2                       = \", value(œÉ)^2)\n        println(\"Constrained MLE objective = \", objective_value(model))\n    end\n    return\nend\n\nexample_mle()","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"View this file on Github.","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"","category":"page"},{"location":"tutorials/Nonlinear programs/mle/","page":"Maximum likelihood estimation","title":"Maximum likelihood estimation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Quadratic programs/portfolio.jl\"","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Optimization models play an increasingly important role in financial decisions. Many computational finance problems can be solved efficiently using modern optimization techniques.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This tutorial solves the famous Markowitz Portfolio Optimization problem with data from lecture notes from a course taught at Georgia Tech by Shabir Ahmed.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This tutorial uses the following packages","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using JuMP\nimport Ipopt\nimport Statistics","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Suppose we are considering investing 1000 dollars in three non-dividend paying stocks, IBM (IBM), Walmart (WMT), and Southern Electric (SEHI), for a one-month period.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This means we will use the money to buy shares of the three stocks at the current market prices, hold these for one month, and sell the shares off at the prevailing market prices at the end of the month.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"As a rational investor, we hope to make some profit out of this endeavor, i.e., the return on our investment should be positive.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Suppose we bought a stock at p dollars per share in the beginning of the month, and sold it off at s dollars per share at the end of the month. Then the one-month return on a share of the stock is $ \\frac{s-p}{p} $.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Since the stock prices are quite uncertain, so is the end-of-month return on our investment. Our goal is to invest in such a way that the expected end-of-month return is at least $50 or 5%. Furthermore, we want to make sure that the ‚Äúrisk‚Äù of not achieving our desired return is minimum.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Note that we are solving the problem under the following assumptions:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"We can trade any continuum of shares.\nNo short-selling is allowed.\nThere are no transaction costs.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"We model this problem by taking decision variables x_i i=123 denoting the dollars invested in each of the 3 stocks.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Let us denote by tilder_i the random variable corresponding to the monthly return (increase in the stock price) per dollar for stock i.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Then, the return (or profit) on x_i dollars invested in stock i is tilder_i x_i and the total (random) return on our investment is sum_i=1^3 tilder_i x_i The expected return on our investment is then mathbbEleftsum_i=1^3 tilder_i x_iright=sum_i=1^3 overliner_i x_i where overliner_i is the expected value of the tilder_i","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Now we need to quantify the notion of ‚Äúrisk‚Äù in our investment.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Markowitz, in his Nobel prize winning work, showed that a rational investor‚Äôs notion of minimizing risk can be closely approximated by minimizing the variance of the return of the investment portfolio. This variance is given by:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright = sum_i=1^3 sum_j=1^3 x_i x_j sigma_i j","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"where sigma_i j is the covariance of the return of stock i with stock j.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Note that the right hand side of the equation is the most reduced form of the expression and we have not shown the intermediate steps involved in getting to this form. We can also write this equation as:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"operatornameVarleftsum_i=1^3 tilder_i x_iright =x^T Q x","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Where Q is the covariance matrix for the random vector tilder.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Finally, we can write the model as:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginaligned\nmin x^T Q x \ntext  st  sum_i=1^3 x_i leq 100000 \noverliner^T x geq 5000 \nx geq 0\nendaligned","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"After that long discussion, lets now use JuMP to solve the portfolio optimization problem for the data given below.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Month IBM WMT SEHI\nNovember-00 93.043 51.826 1.063\nDecember-00 84.585 52.823 0.938\nJanuary-01 111.453 56.477 1.000\nFebruary-01 99.525 49.805 0.938\nMarch-01 95.819 50.287 1.438\nApril-01 114.708 51.521 1.700\nMay-01 111.515 51.531 2.540\nJune-01 113.211 48.664 2.390\nJuly-01 104.942 55.744 3.120\nAugust-01 99.827 47.916 2.980\nSeptember-01 91.607 49.438 1.900\nOctober-01 107.937 51.336 1.750\nNovember-01 115.590 55.081 1.800","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"stock_data = [\n    93.043 51.826 1.063;\n    84.585 52.823 0.938;\n    111.453 56.477 1.000;\n    99.525 49.805 0.938;\n    95.819 50.287 1.438;\n    114.708 51.521 1.700;\n    111.515 51.531 2.540;\n    113.211 48.664 2.390;\n    104.942 55.744 3.120;\n    99.827 47.916 2.980;\n    91.607 49.438 1.900;\n    107.937 51.336 1.750;\n    115.590 55.081 1.800;\n]","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating stock returns","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"stock_returns = Array{Float64}(undef, 12, 3)\nfor i in 1:12\n    stock_returns[i, :] = (stock_data[i + 1, :] .- stock_data[i, :]) ./ stock_data[i, :]\nend\nstock_returns","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating the expected value of monthly return:","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"r = Statistics.mean(stock_returns, dims = 1)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Calculating the covariance matrix Q","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"Q = Statistics.cov(stock_returns)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"JuMP Model","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"portfolio = Model(Ipopt.Optimizer)\nset_silent(portfolio)\n@variable(portfolio, x[1:3] >= 0)\n@objective(portfolio, Min, x' * Q * x)\n@constraint(portfolio, sum(x) <= 1000)\n@constraint(portfolio, sum(r[i] * x[i] for i = 1:3) >= 50)\noptimize!(portfolio)\n\nobjective_value(portfolio)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"value.(x)","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"View this file on Github.","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"page"},{"location":"tutorials/Quadratic programs/portfolio/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/corr_sdp.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/#The-correlation-problem","page":"The correlation problem","title":"The correlation problem","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"Given three random variables A, B, C and given bounds on two of the three correlation coefficients:","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"-0.2 <= œÅ_AB <= -0.1\n0.4 <= œÅ_BC <=  0.5","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"We can use the following property of the correlations to determine bounds on œÅ_AC by solving a SDP:","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"|  1    œÅ_AB  œÅ_AC |\n| œÅ_AB   1    œÅ_BC |  ‚âΩ 0\n| œÅ_AC  œÅ_BC   1   |","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"using JuMP\nimport SCS\n\nfunction example_corr_sdp()\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:3, 1:3], PSD)\n    # Diagonal is 1s\n    @constraint(model, X[1, 1] == 1)\n    @constraint(model, X[2, 2] == 1)\n    @constraint(model, X[3, 3] == 1)\n    # Bounds on the known correlations\n    @constraint(model, X[1, 2] >= -0.2)\n    @constraint(model, X[1, 2] <= -0.1)\n    @constraint(model, X[2, 3] >=  0.4)\n    @constraint(model, X[2, 3] <=  0.5)\n    # Find upper bound\n    @objective(model, Max, X[1, 3])\n    optimize!(model)\n    println(\"An upper bound for X[1, 3] is $(value(X[1, 3]))\")\n    # Find lower bound\n    @objective(model, Min, X[1, 3])\n    optimize!(model)\n    println(\"A lower bound for X[1, 3] is $(value(X[1, 3]))\")\n    return\nend\n\nexample_corr_sdp()","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/corr_sdp/","page":"The correlation problem","title":"The correlation problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/sudoku.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/#Sudoku","page":"Sudoku","title":"Sudoku","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Originally Contributed by: Iain Dunning","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Sudoku is a popular number puzzle. The goal is to place the digits 1,...,9 on a nine-by-nine grid, with some of the digits already filled in. Your solution must satisfy the following rules:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The numbers 1 to 9 must appear in each 3x3 square\nThe numbers 1 to 9 must appear in each row\nThe numbers 1 to 9 must appear in each column","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Here is a partially solved Sudoku problem:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Partially solved Sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Solving a Sudoku isn't an optimization problem with an objective; its actually a feasibility problem: we wish to find a feasible solution that satisfies these rules. You can think of it as an optimization problem with an objective of 0.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"We can model this problem using 0-1 integer programming: a problem where all the decision variables are binary. We'll use JuMP to create the model, and then we can solve it with any integer programming solver.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"using JuMP\nusing GLPK","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"We will define a binary variable (a variable that is either 0 or 1) for each possible number in each possible cell. The meaning of each variable is as follows: x[i,j,k] = 1  if and only if cell (i,j) has number k, where i is the row and j is the column.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a model","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sudoku = Model(GLPK.Optimizer)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create our variables","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"@variable(sudoku, x[i=1:9, j=1:9, k=1:9], Bin)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Now we can begin to add our constraints. We'll actually start with something obvious to us as humans, but what we need to enforce: that there can be only one number per cell.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i = 1:9  ## For each row\n    for j = 1:9  ## and each column\n        # Sum across all the possible digits. One and only one of the digits\n        # can be in this cell, so the sum must be equal to one.\n        @constraint(sudoku, sum(x[i, j, k] for k = 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Next we'll add the constraints for the rows and the columns. These constraints are all very similar, so much so that we can actually add them at the same time.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for ind = 1:9  ## Each row, OR each column\n    for k = 1:9  ## Each digit\n        # Sum across columns (j) - row constraint\n        @constraint(sudoku, sum(x[ind, j, k] for j = 1:9) == 1)\n        # Sum across rows (i) - column constraint\n        @constraint(sudoku, sum(x[i, ind, k] for i = 1:9) == 1)\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Finally, we have the to enforce the constraint that each digit appears once in each of the nine 3x3 sub-grids. Our strategy will be to index over the top-left corners of each 3x3 square with for loops, then sum over the squares.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"for i = 1:3:7\n    for j = 1:3:7\n        for k = 1:9\n            # i is the top left row, j is the top left column.\n            # We'll sum from i to i+2, e.g. i=4, r=4, 5, 6.\n            @constraint(\n                sudoku,\n                sum(x[r, c, k] for r in i:(i+2), c in j:(j+2)) == 1\n            )\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The final step is to add the initial solution as a set of constraints. We'll solve the problem that is in the picture at the start of the tutorial. We'll put a 0 if there is no digit in that location.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"The given digits","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"init_sol = [\n    5 3 0 0 7 0 0 0 0\n    6 0 0 1 9 5 0 0 0\n    0 9 8 0 0 0 0 6 0\n    8 0 0 0 6 0 0 0 3\n    4 0 0 8 0 3 0 0 1\n    7 0 0 0 2 0 0 0 6\n    0 6 0 0 0 0 2 8 0\n    0 0 0 4 1 9 0 0 5\n    0 0 0 0 8 0 0 7 9\n]\nfor i = 1:9\n    for j = 1:9\n        # If the space isn't empty\n        if init_sol[i, j] != 0\n            # Then the corresponding variable for that digit and location must\n            # be 1.\n            fix(x[i, j, init_sol[i, j]], 1; force = true)\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"solve problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"optimize!(sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Extract the values of x","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"x_val = value.(x)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Create a matrix to store the solution","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol = zeros(Int, 9, 9)  # 9x9 matrix of integers\nfor i = 1:9\n    for j = 1:9\n        for k = 1:9\n            # Integer programs are solved as a series of linear programs so the\n            # values might not be precisely 0 and 1. We can just round them to\n            # the nearest integer to make it easier.\n            if round(Int, x_val[i, j, k]) == 1\n                sol[i, j] = k\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Display the solution","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"sol","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"Which is the correct solution:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"(Image: Solved Sudoku)","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/sudoku/","page":"Sudoku","title":"Sudoku","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/variables/#VariableAPI","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"More information can be found in the Variables section of the manual.","category":"page"},{"location":"reference/variables/#Macros","page":"Variables","title":"Macros","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"@variable\n@variables","category":"page"},{"location":"reference/variables/#JuMP.@variable","page":"Variables","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ‚â§ and the symbol >=can be used instead of ‚â•)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ‚â§ ub (resp. varexpr ‚â• lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ‚â§ varexpr ‚â§ ub or ub ‚â• varexpr ‚â• lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\nof the form varexpr in set creating variables described by varexpr constrained to belong to set, see Variables constrained on creation.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ‚â§ j and sets varname[j,i] to the same variable as varname[i,j]. It is equivalent to using varexpr in SymMatrixSpace() as expr.\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite. It is equivalent to using varexpr in PSDCone() as expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\nset: Equivalent to using varexpr in value as expr where value is the value of the keyword argument.\ncontainer: Specify the container type.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b]. The upper bound can either be specified in expr:\n\nub = Dict(:a => 2, :b => 3)\n@variable(model, x[i=keys(ub)] <= ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n x[a]\n x[b]\n\nor it can be specified with the upper_bound keyword argument:\n\n@variable(model, y[i=keys(ub)], upper_bound=ub[i])\n\n# output\n1-dimensional DenseAxisArray{VariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{VariableRef,1}:\n y[a]\n y[b]\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#JuMP.@variables","page":"Variables","title":"JuMP.@variables","text":"@variables(model, args...)\n\nAdds multiple variables to model at once, in the same fashion as the @variable macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@variables(model, begin\n    x\n    y[i = 1:2] >= 0, (start = i)\n    z, Bin, (start = 0, base_name = \"Z\")\nend)\n\nnote: Note\nKeyword arguments must be contained within parentheses (refer to the example above).\n\n\n\n\n\n","category":"macro"},{"location":"reference/variables/#Basic-utilities","page":"Variables","title":"Basic utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"VariableRef\nnum_variables\nall_variables\nowner_model\nindex(::VariableRef)\noptimizer_index(::VariableRef)\ncheck_belongs_to_model\nVariableNotOwned\nVariableConstrainedOnCreation\nVariablesConstrainedOnCreation","category":"page"},{"location":"reference/variables/#JuMP.VariableRef","page":"Variables","title":"JuMP.VariableRef","text":"VariableRef <: AbstractVariableRef\n\nHolds a reference to the model and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.num_variables","page":"Variables","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.all_variables","page":"Variables","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.owner_model","page":"Variables","title":"JuMP.owner_model","text":"owner_model(s::AbstractJuMPScalar)\n\nReturn the model owning the scalar s.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.index-Tuple{VariableRef}","page":"Variables","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.optimizer_index-Tuple{VariableRef}","page":"Variables","title":"JuMP.optimizer_index","text":"optimizer_index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the optimizer model. It throws NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.check_belongs_to_model","page":"Variables","title":"JuMP.check_belongs_to_model","text":"check_belongs_to_model(func::AbstractJuMPScalar, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the function func is not model.\n\ncheck_belongs_to_model(constraint::AbstractConstraint, model::AbstractModel)\n\nThrow VariableNotOwned if the owner_model of one of the variables of the constraint constraint is not model.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.VariableNotOwned","page":"Variables","title":"JuMP.VariableNotOwned","text":"struct VariableNotOwned{V <: AbstractVariableRef} <: Exception\n    variable::V\nend\n\nThe variable variable was used in a model different to owner_model(variable).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariableConstrainedOnCreation","page":"Variables","title":"JuMP.VariableConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVariable scalar_variables constrained to belong to set. Adding this variable can be understood as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariableConstrainedOnCreation, names)\n    var_ref = JuMP.add_variable(model, variable.scalar_variable, name)\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_ref, variable.set))\n    return var_ref\nend\n\nbut adds the variables with MOI.add_constrained_variable(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variable and adding them with MOI.add_variable and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.VariablesConstrainedOnCreation","page":"Variables","title":"JuMP.VariablesConstrainedOnCreation","text":"VariablesConstrainedOnCreation <: AbstractVariable\n\nVector of variables scalar_variables constrained to belong to set. Adding this variable can be thought as doing:\n\nfunction JuMP.add_variable(model::Model, variable::JuMP.VariablesConstrainedOnCreation, names)\n    var_refs = JuMP.add_variable.(model, variable.scalar_variables,\n                                  JuMP.vectorize(names, variable.shape))\n    JuMP.add_constraint(model, JuMP.VectorConstraint(var_refs, variable.set))\n    return JuMP.reshape_vector(var_refs, variable.shape)\nend\n\nbut adds the variables with MOI.add_constrained_variables(model, variable.set) instead. See the MOI documentation for the difference between adding the variables with MOI.add_constrained_variables and adding them with MOI.add_variables and adding the constraint separately.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#Names","page":"Variables","title":"Names","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"name(::JuMP.VariableRef)\nset_name(::JuMP.VariableRef, ::String)\nvariable_by_name","category":"page"},{"location":"reference/variables/#JuMP.name-Tuple{VariableRef}","page":"Variables","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.set_name-Tuple{VariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"reference/variables/#JuMP.variable_by_name","page":"Variables","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Start-values","page":"Variables","title":"Start values","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"set_start_value\nstart_value","category":"page"},{"location":"reference/variables/#JuMP.set_start_value","page":"Variables","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Union{Real,Nothing})\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable to value.\n\nPass nothing to unset the start value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.start_value","page":"Variables","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\nSee also set_start_value.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Lower-bounds","page":"Variables","title":"Lower bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_lower_bound\nlower_bound\nset_lower_bound\ndelete_lower_bound\nLowerBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_lower_bound","page":"Variables","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound.\n\nSee also LowerBoundRef, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.lower_bound","page":"Variables","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist.\n\nSee also LowerBoundRef, has_lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_lower_bound","page":"Variables","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_lower_bound","page":"Variables","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\nSee also LowerBoundRef, has_lower_bound, lower_bound, set_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.LowerBoundRef","page":"Variables","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\nSee also has_lower_bound, lower_bound, set_lower_bound, delete_lower_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Upper-bounds","page":"Variables","title":"Upper bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"has_upper_bound\nupper_bound\nset_upper_bound\ndelete_upper_bound\nUpperBoundRef","category":"page"},{"location":"reference/variables/#JuMP.has_upper_bound","page":"Variables","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound.\n\nSee also UpperBoundRef, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.upper_bound","page":"Variables","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist.\n\nSee also UpperBoundRef, has_upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_upper_bound","page":"Variables","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.delete_upper_bound","page":"Variables","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\nSee also UpperBoundRef, has_upper_bound, upper_bound, set_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.UpperBoundRef","page":"Variables","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\nSee also has_upper_bound, upper_bound, set_upper_bound, delete_upper_bound.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Fixed-bounds","page":"Variables","title":"Fixed bounds","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_fixed\nfix_value\nfix\nunfix\nFixRef","category":"page"},{"location":"reference/variables/#JuMP.is_fixed","page":"Variables","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value.\n\nSee also FixRef, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix_value","page":"Variables","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist.\n\nSee also FixRef, is_fixed, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.fix","page":"Variables","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\nSee also FixRef, is_fixed, fix_value, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unfix","page":"Variables","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\nSee also FixRef, is_fixed, fix_value, fix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.FixRef","page":"Variables","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\nSee also is_fixed, fix_value, fix, unfix.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_integer\nset_integer\nunset_integer\nIntegerRef","category":"page"},{"location":"reference/variables/#JuMP.is_integer","page":"Variables","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer.\n\nSee also IntegerRef, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_integer","page":"Variables","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_integer","page":"Variables","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\nSee also IntegerRef, is_integer, set_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.IntegerRef","page":"Variables","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be integer. Errors if one does not exist.\n\nSee also is_integer, set_integer, unset_integer.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Binary-variables","page":"Variables","title":"Binary variables","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"is_binary\nset_binary\nunset_binary\nBinaryRef","category":"page"},{"location":"reference/variables/#JuMP.is_binary","page":"Variables","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary.\n\nSee also BinaryRef, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.set_binary","page":"Variables","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01.\n\nSee also BinaryRef, is_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.unset_binary","page":"Variables","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\nSee also BinaryRef, is_binary, set_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#JuMP.BinaryRef","page":"Variables","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constraining v to be binary. Errors if one does not exist.\n\nSee also is_binary, set_binary, unset_binary.\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Integrality-utilities","page":"Variables","title":"Integrality utilities","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"relax_integrality","category":"page"},{"location":"reference/variables/#JuMP.relax_integrality","page":"Variables","title":"JuMP.relax_integrality","text":"relax_integrality(model::Model)\n\nModifies model to \"relax\" all binary and integrality constraints on variables. Specifically,\n\nBinary constraints are deleted, and variable bounds are tightened if necessary to ensure the variable is constrained to the interval 0 1.\nIntegrality constraints are deleted without modifying variable bounds.\nAn error is thrown if semi-continuous or semi-integer constraints are present (support may be added for these in the future).\nAll other constraints are ignored (left in place). This includes discrete constraints like SOS and indicator constraints.\n\nReturns a function that can be called without any arguments to restore the original model. The behavior of this function is undefined if additional changes are made to the affected variables in the meantime.\n\nExample\n\njulia> model = Model();\n\njulia> @variable(model, x, Bin);\n\njulia> @variable(model, 1 <= y <= 10, Int);\n\njulia> @objective(model, Min, x + y);\n\njulia> undo_relax = relax_integrality(model);\n\njulia> print(model)\nMin x + y\nSubject to\n x ‚â• 0.0\n y ‚â• 1.0\n x ‚â§ 1.0\n y ‚â§ 10.0\n\njulia> undo_relax()\n\njulia> print(model)\nMin x + y\nSubject to\n y ‚â• 1.0\n y ‚â§ 10.0\n y integer\n x binary\n\n\n\n\n\n","category":"function"},{"location":"reference/variables/#Extensions","page":"Variables","title":"Extensions","text":"","category":"section"},{"location":"reference/variables/","page":"Variables","title":"Variables","text":"AbstractVariable\nAbstractVariableRef\nparse_one_operator_variable","category":"page"},{"location":"reference/variables/#JuMP.AbstractVariable","page":"Variables","title":"JuMP.AbstractVariable","text":"AbstractVariable\n\nVariable returned by build_variable. It represents a variable that has not been added yet to any model. It can be added to a given model with add_variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.AbstractVariableRef","page":"Variables","title":"JuMP.AbstractVariableRef","text":"AbstractVariableRef\n\nVariable returned by add_variable. Affine (resp. quadratic) operations with variables of type V<:AbstractVariableRef and coefficients of type T     create a GenericAffExpr{T,V} (resp. GenericQuadExpr{T,V}).\n\n\n\n\n\n","category":"type"},{"location":"reference/variables/#JuMP.parse_one_operator_variable","page":"Variables","title":"JuMP.parse_one_operator_variable","text":"parse_one_operator_variable(_error::Function, infoexpr::_VariableInfoExpr, sense::Val{S}, value) where S\n\nUpdate infoexr for a variable expression in the @variable macro of the form variable name S value.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#ModelAPI","page":"Models","title":"Models","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"More information can be found in the Models section of the manual.","category":"page"},{"location":"reference/models/#Constructors","page":"Models","title":"Constructors","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"Model\ndirect_model","category":"page"},{"location":"reference/models/#JuMP.Model","page":"Models","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.direct_model","page":"Models","title":"JuMP.direct_model","text":"direct_model(backend::MOI.ModelLike)\n\nReturn a new JuMP model using backend to store the model and solve it.\n\nAs opposed to the Model constructor, no cache of the model is stored outside of backend and no bridges are automatically applied to backend.\n\nNotes\n\nThe absence of a cache reduces the memory footprint but, it is important to bear in mind the following implications of creating models using this direct mode:\n\nWhen backend does not support an operation, such as modifying constraints or adding variables/constraints after solving, an error is thrown. For models created using the Model constructor, such situations can be dealt with by storing the modifications in a cache and loading them into the optimizer when optimize! is called.\nNo constraint bridging is supported by default.\nThe optimizer used cannot be changed the model is constructed.\nThe model created cannot be copied.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Enums","page":"Models","title":"Enums","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ModelMode\nAUTOMATIC\nMANUAL\nDIRECT","category":"page"},{"location":"reference/models/#JuMP.ModelMode","page":"Models","title":"JuMP.ModelMode","text":"ModelMode\n\nAn enum to describe the state of the CachingOptimizer inside a JuMP model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.AUTOMATIC","page":"Models","title":"JuMP.AUTOMATIC","text":"moi_backend field holds a CachingOptimizer in AUTOMATIC mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.MANUAL","page":"Models","title":"JuMP.MANUAL","text":"moi_backend field holds a CachingOptimizer in MANUAL mode.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#JuMP.DIRECT","page":"Models","title":"JuMP.DIRECT","text":"moi_backend field holds an AbstractOptimizer. No extra copy of the model is stored. The moi_backend must support add_constraint etc.\n\n\n\n\n\n","category":"constant"},{"location":"reference/models/#Basic-functions","page":"Models","title":"Basic functions","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"backend\nsolver_name\nBase.empty!(::Model)\nmode\nobject_dictionary\nunregister\nlatex_formulation","category":"page"},{"location":"reference/models/#JuMP.backend","page":"Models","title":"JuMP.backend","text":"backend(model::Model)\n\nReturn the lower-level MathOptInterface model that sits underneath JuMP. This model depends on which operating mode JuMP is in (see mode), and whether there are any bridges in the model.\n\nIf JuMP is in DIRECT mode (i.e., the model was created using direct_model), the backend will be the optimizer passed to direct_model.\n\nIf JuMP is in MANUAL or AUTOMATIC mode, the backend is a MOI.Utilities.CachingOptimizer.\n\nThis function should only be used by advanced users looking to access low-level MathOptInterface or solver-specific functionality.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.solver_name","page":"Models","title":"JuMP.solver_name","text":"solver_name(model::Model)\n\nIf available, returns the SolverName property of the underlying optimizer.\n\nReturns \"No optimizer attached\" in AUTOMATIC or MANUAL modes when no optimizer is attached.\n\nReturns \"SolverName() attribute not implemented by the optimizer.\" if the attribute is not implemented.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.empty!-Tuple{Model}","page":"Models","title":"Base.empty!","text":"empty!(model::Model)::Model\n\nEmpty the model, that is, remove all variables, constraints and model attributes but not optimizer attributes. Always return the argument.\n\nNote: removes extensions data.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.mode","page":"Models","title":"JuMP.mode","text":"mode(model::Model)\n\nReturn the ModelMode (DIRECT, AUTOMATIC, or MANUAL) of model.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.object_dictionary","page":"Models","title":"JuMP.object_dictionary","text":"object_dictionary(model::Model)\n\nReturn the dictionary that maps the symbol name of a variable, constraint, or expression to the corresponding object.\n\nObjects are registered to a specific symbol in the macros. For example, @variable(model, x[1:2, 1:2]) registers the array of variables x to the symbol :x.\n\nThis method should be defined for any subtype of AbstractModel.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unregister","page":"Models","title":"JuMP.unregister","text":"unregister(model::Model, key::Symbol)\n\nUnregister the name key from model so that a new variable, constraint, or expression can be created with the same key.\n\nNote that this will not delete the object model[key]; it will just remove the reference at model[key]. To delete the object, use\n\ndelete(model, model[key])\nunregister(model, key)\n\nSee also: object_dictionary.\n\nExamples\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, x)\nERROR: An object of name x is already attached to this model. If\nthis is intended, consider using the anonymous construction syntax,\ne.g., `x = @variable(model, [1:N], ...)` where the name of the object\ndoes not appear inside the macro.\n\nAlternatively, use `unregister(model, :x)` to first unregister the\nexisting name from the model. Note that this will not delete the object;\nit will just remove the reference at `model[:x]`.\n[...]\n\njulia> num_variables(model)\n1\n\njulia> unregister(model, :x)\n\njulia> @variable(model, x)\nx\n\njulia> num_variables(model)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.latex_formulation","page":"Models","title":"JuMP.latex_formulation","text":"latex_formulation(model::AbstractModel)\n\nWrap model in a type so that it can be pretty-printed as text/latex in a notebook like IJulia, or in Documenter.\n\nTo render the model, end the cell with latex_formulation(model), or call display(latex_formulation(model)) in to force the display of the model from inside a function.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Working-with-attributes","page":"Models","title":"Working with attributes","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"set_optimizer\noptimizer_with_attributes\nget_optimizer_attribute\nset_optimizer_attribute\nset_optimizer_attributes\nset_silent\nunset_silent\nset_time_limit_sec\nunset_time_limit_sec\ntime_limit_sec","category":"page"},{"location":"reference/models/#JuMP.set_optimizer","page":"Models","title":"JuMP.set_optimizer","text":"set_optimizer(model::Model, optimizer_factory;\n              bridge_constraints::Bool=true)\n\nCreates an empty MathOptInterface.AbstractOptimizer instance by calling optimizer_factory() and sets it as the optimizer of model. Specifically, optimizer_factory must be callable with zero arguments and return an empty MathOptInterface.AbstractOptimizer.\n\nIf bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitly added.\n\nSee set_optimizer_attributes and set_optimizer_attribute for setting solver-specific parameters of the optimizer.\n\nExamples\n\nmodel = Model()\nset_optimizer(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.optimizer_with_attributes","page":"Models","title":"JuMP.optimizer_with_attributes","text":"optimizer_with_attributes(optimizer_constructor, attrs::Pair...)\n\nGroups an optimizer constructor with the list of attributes attrs. Note that it is equivalent to MOI.OptimizerWithAttributes.\n\nWhen provided to the Model constructor or to set_optimizer, it creates an optimizer by calling optimizer_constructor(), and then sets the attributes using set_optimizer_attribute.\n\nExample\n\nmodel = Model(\n    optimizer_with_attributes(\n        Gurobi.Optimizer, \"Presolve\" => 0, \"OutputFlag\" => 1\n    )\n)\n\nis equivalent to:\n\nmodel = Model(Gurobi.Optimizer)\nset_optimizer_attribute(model, \"Presolve\", 0)\nset_optimizer_attribute(model, \"OutputFlag\", 1)\n\nNote\n\nThe string names of the attributes are specific to each solver. One should consult the solver's documentation to find the attributes of interest.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.get_optimizer_attribute","page":"Models","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(model, name::String)\n\nReturn the value associated with the solver-specific attribute named name.\n\nNote that this is equivalent to get_optimizer_attribute(model, MOI.RawParameter(name)).\n\nExample\n\nget_optimizer_attribute(model, \"SolverSpecificAttributeName\")\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\nget_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute\n)\n\nReturn the value of the solver-specific attribute attr in model.\n\nExample\n\nget_optimizer_attribute(model, MOI.Silent())\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attribute","page":"Models","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(model::Model, name::String, value)\n\nSets solver-specific attribute identified by name to value.\n\nNote that this is equivalent to set_optimizer_attribute(model, MOI.RawParameter(name), value).\n\nExample\n\nset_optimizer_attribute(model, \"SolverSpecificAttributeName\", true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\nset_optimizer_attribute(\n    model::Model, attr::MOI.AbstractOptimizerAttribute, value\n)\n\nSet the solver-specific attribute attr in model to value.\n\nExample\n\nset_optimizer_attribute(model, MOI.Silent(), true)\n\nSee also: set_optimizer_attributes, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_optimizer_attributes","page":"Models","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(model::Model, pairs::Pair...)\n\nGiven a list of attribute => value pairs, calls set_optimizer_attribute(model, attribute, value) for each pair.\n\nExample\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attributes(model, \"tol\" => 1e-4, \"max_iter\" => 100)\n\nis equivalent to:\n\nmodel = Model(Ipopt.Optimizer)\nset_optimizer_attribute(model, \"tol\", 1e-4)\nset_optimizer_attribute(model, \"max_iter\", 100)\n\nSee also: set_optimizer_attribute, get_optimizer_attribute.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_silent","page":"Models","title":"JuMP.set_silent","text":"set_silent(model::Model)\n\nTakes precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\nSee also: unset_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_silent","page":"Models","title":"JuMP.unset_silent","text":"unset_silent(model::Model)\n\nNeutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\nSee also: set_silent.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.set_time_limit_sec","page":"Models","title":"JuMP.set_time_limit_sec","text":"set_time_limit_sec(model::Model, limit)\n\nSet the time limit (in seconds) of the solver.\n\nCan be unset using unset_time_limit_sec or with limit set to nothing.\n\nSee also: unset_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.unset_time_limit_sec","page":"Models","title":"JuMP.unset_time_limit_sec","text":"unset_time_limit_sec(model::Model)\n\nUnset the time limit of the solver.\n\nSee also: set_time_limit_sec, time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.time_limit_sec","page":"Models","title":"JuMP.time_limit_sec","text":"time_limit_sec(model::Model)\n\nReturn the time limit (in seconds) of the model.\n\nReturns nothing if unset.\n\nSee also: set_time_limit_sec, unset_time_limit_sec.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Copying","page":"Models","title":"Copying","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"ReferenceMap\ncopy_model\ncopy_extension_data\nBase.copy(::AbstractModel)","category":"page"},{"location":"reference/models/#JuMP.ReferenceMap","page":"Models","title":"JuMP.ReferenceMap","text":"ReferenceMap\n\nMapping between variable and constraint reference of a model and its copy. The reference of the copied model can be obtained by indexing the map with the reference of the corresponding reference of the original model.\n\n\n\n\n\n","category":"type"},{"location":"reference/models/#JuMP.copy_model","page":"Models","title":"JuMP.copy_model","text":"copy_model(model::Model; filter_constraints::Union{Nothing, Function}=nothing)\n\nReturn a copy of the model model and a ReferenceMap that can be used to obtain the variable and constraint reference of the new model corresponding to a given model's reference. A Base.copy(::AbstractModel) method has also been implemented, it is similar to copy_model but does not return the reference map.\n\nIf the filter_constraints argument is given, only the constraints for which this function returns true will be copied. This function is given a constraint reference as argument.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model, reference_map = copy_model(model)\nx_new = reference_map[x]\ncref_new = reference_map[cref]\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.copy_extension_data","page":"Models","title":"JuMP.copy_extension_data","text":"copy_extension_data(data, new_model::AbstractModel, model::AbstractModel)\n\nReturn a copy of the extension data data of the model model to the extension data of the new model new_model. A method should be added for any JuMP extension storing data in the ext field.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.copy-Tuple{AbstractModel}","page":"Models","title":"Base.copy","text":"copy(model::AbstractModel)\n\nReturn a copy of the model model. It is similar to copy_model except that it does not return the mapping between the references of model and its copy.\n\nNote\n\nModel copy is not supported in DIRECT mode, i.e. when a model is constructed using the direct_model constructor instead of the Model constructor. Moreover, independently on whether an optimizer was provided at model construction, the new model will have no optimizer, i.e., an optimizer will have to be provided to the new model in the optimize! call.\n\nExamples\n\nIn the following example, a model model is constructed with a variable x and a constraint cref. It is then copied into a model new_model with the new references assigned to x_new and cref_new.\n\nmodel = Model()\n@variable(model, x)\n@constraint(model, cref, x == 2)\n\nnew_model = copy(model)\nx_new = model[:x]\ncref_new = model[:cref]\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#I/O","page":"Models","title":"I/O","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"write_to_file\nBase.write(::IO, ::Model; ::MOI.FileFormats.FileFormat)\nread_from_file\nBase.read(::IO, ::Type{Model}; ::MOI.FileFormats.FileFormat)","category":"page"},{"location":"reference/models/#JuMP.write_to_file","page":"Models","title":"JuMP.write_to_file","text":"write_to_file(\n    model::Model,\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nWrite the JuMP model model to filename in the format format.\n\nIf the filename ends in .gz, it will be compressed using Gzip. If the filename ends in .bz2, it will be compressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.write-Tuple{IO,Model}","page":"Models","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::Model;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_MOF\n)\n\nWrite the JuMP model model to io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#JuMP.read_from_file","page":"Models","title":"JuMP.read_from_file","text":"read_from_file(\n    filename::String;\n    format::MOI.FileFormats.FileFormat = MOI.FileFormats.FORMAT_AUTOMATIC\n)\n\nReturn a JuMP model read from filename in the format format.\n\nIf the filename ends in .gz, it will be uncompressed using Gzip. If the filename ends in .bz2, it will be uncompressed using BZip2.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Base.read-Tuple{IO,Type{Model}}","page":"Models","title":"Base.read","text":"Base.read(io::IO, ::Type{Model}; format::MOI.FileFormats.FileFormat)\n\nReturn a JuMP model read from io in the format format.\n\n\n\n\n\n","category":"method"},{"location":"reference/models/#Bridge-tools","page":"Models","title":"Bridge tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"bridge_constraints\nprint_bridge_graph","category":"page"},{"location":"reference/models/#JuMP.bridge_constraints","page":"Models","title":"JuMP.bridge_constraints","text":"bridge_constraints(model::Model)\n\nWhen in direct mode, return false. When in manual or automatic mode, return a Bool indicating whether the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.print_bridge_graph","page":"Models","title":"JuMP.print_bridge_graph","text":" print_bridge_graph([io::IO,] model::Model)\n\nPrint the hyper-graph containing all variable, constraint, and objective types that could be obtained by bridging the variables, constraints, and objectives that are present in the model.\n\nEach node in the hyper-graph corresponds to a variable, constraint, or objective type.\n\nVariable nodes are indicated by [ ]\nConstraint nodes are indicated by ( )\nObjective nodes are indicated by | |\n\nThe number inside each pair of brackets is an index of the node in the hyper-graph.\n\nNote that this hyper-graph is the full list of possible transformations. When the bridged model is created, we select the shortest hyper-path(s) from this graph, so many nodes may be un-used.\n\nFor more information, see Legat, B., Dowson, O., Garcia, J., and Lubin, M. (2020).  \"MathOptInterface: a data structure for mathematical optimization problems.\" URL: https://arxiv.org/abs/2002.03447\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#Extension-tools","page":"Models","title":"Extension tools","text":"","category":"section"},{"location":"reference/models/","page":"Models","title":"Models","text":"operator_warn\nerror_if_direct_mode","category":"page"},{"location":"reference/models/#JuMP.operator_warn","page":"Models","title":"JuMP.operator_warn","text":"operator_warn(model::AbstractModel)\noperator_warn(model::Model)\n\nThis function is called on the model whenever two affine expressions are added together without using destructive_add!, and at least one of the two expressions has more than 50 terms.\n\nFor the case of Model, if this function is called more than 20,000 times then a warning is generated once.\n\n\n\n\n\n","category":"function"},{"location":"reference/models/#JuMP.error_if_direct_mode","page":"Models","title":"JuMP.error_if_direct_mode","text":"error_if_direct_mode(model::Model, func::Symbol)\n\nErrors if model is in direct mode during a call from the function named func.\n\nUsed internally within JuMP, or by JuMP extensions who do not want to support models in direct mode.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/cutting_stock_column_generation.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/#Cutting-stock","page":"Cutting stock","title":"Cutting stock","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example solves the cutting stock problem (sometimes also called the cutting rod problem) using a column-generation technique. It is based on https://doi.org/10.5281/zenodo.3329388.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Intuitively, this problem is about cutting large rolls of paper into smaller pieces. There is an exact demand of pieces to meet, and all rolls have the same size. The goal is to meet the demand while maximizing the profits (each paper roll has a fixed cost, each sold piece allows earning some money), which is roughly equivalent to using the smallest amount of rolls to cut (or, equivalently, to minimize the amount of paper waste).","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This function takes five parameters:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"maxwidth: the maximum width of a roll (or length of a rod)\nwidths: an array of the requested widths\nrollcost: the cost of a complete roll\ndemand: the demand, in number of pieces, for each width\nprices: the selling price for each width","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Mathematically, this problem might be formulated with two variables:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"x[i, j] ‚àà ‚Ñï: the number of times the width i is cut out of the roll j\ny[j] ‚àà ùîπ: whether the roll j is used","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Several constraints are needed:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"the demand must be satisfied, for each width i: ‚àëj x[i, j] = demand[i]\nthe roll size cannot be exceed, for each roll j that is used: ‚àëi x[i, j] width[i] ‚â§ maxwidth y[j]","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"If you want to implement this na√Øve model, you will need an upper bound on the number of rolls to use: the simplest one is to consider that each required width is cut from its own roll, i.e. j varies from 1 to ‚àëi demand[i].","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example prefers a more advanced technique to solve this problem: column generation.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It considers a different set of variables: patterns of width to cut a roll. The decisions then become the number of times each pattern is used (i.e. the number of rolls that are cut following this pattern).","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The intelligence comes from the way these patterns are chosen: not all of them are considered, but only the \"interesting\" ones, within the master problem.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"A \"pricing\" problem is used to decide whether a new pattern should be generated or not (it is implemented in the function solve_pricing). \"Interesting\" means, for a pattern, that the optimal solution may use this cutting pattern.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In more detail, the solving process is the following. First, a series of dumb patterns are generated (just one width per roll, repeated until the roll is completely cut). Then, the master problem is solved with these first patterns and its dual solution is passed on to the pricing problem. The latter decides if there is a new pattern to include in the formulation or not; if so, it returns it to the master problem. The master is solved again, the new dual variables are given to the pricing problem, until there is no more pattern to generate from the pricing problem: all \"interesting\" patterns have been generated, and the master can take its optimal decision.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"In the implementation, the variables deciding how many times a pattern is chosen are called Œ∏.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"For more information on column-generation techniques applied on the cutting stock problem, you can see:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"Integer programming column generation strategies for the cutting stock problem and its variants\nTackling the cutting stock problem","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This example uses the following packages:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"using JuMP\nimport GLPK\nimport SparseArrays","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"The function solve_pricing implements the pricing problem for the function example_cutting_stock.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It takes, as input, the dual solution from the master problem and the cutting stock instance.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"It outputs either a new cutting pattern, or nothing if no pattern could improve the current cost.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"function solve_pricing(\n    dual_demand_satisfaction, maxwidth, widths, rollcost, demand, prices\n)\n    reduced_costs = dual_demand_satisfaction + prices\n    n = length(reduced_costs)\n    # The actual pricing model.\n    submodel = Model(GLPK.Optimizer)\n    set_silent(submodel)\n    @variable(submodel, xs[1:n] >= 0, Int)\n    @constraint(submodel, sum(xs .* widths) <= maxwidth)\n    @objective(submodel, Max, sum(xs .* reduced_costs))\n    optimize!(submodel)\n    new_pattern = round.(Int, value.(xs))\n    net_cost = rollcost - sum(new_pattern .* (dual_demand_satisfaction .+ prices))\n    # If the net cost of this new pattern is nonnegative, no more patterns to add.\n    return net_cost >= 0 ? nothing : new_pattern\nend\n\nfunction example_cutting_stock(; max_gen_cols::Int = 5_000)\n    maxwidth = 100.0\n    rollcost = 500.0\n    prices = [\n        167.0, 197.0, 281.0, 212.0, 225.0, 111.0, 93.0, 129.0, 108.0, 106.0,\n        55.0, 85.0, 66.0, 44.0, 47.0, 15.0, 24.0, 13.0, 16.0, 14.0,\n    ]\n    widths = [\n        75.0, 75.0, 75.0, 75.0, 75.0, 53.8, 53.0, 51.0, 50.2, 32.2,\n        30.8, 29.8, 20.1, 16.2, 14.5, 11.0, 8.6, 8.2, 6.6, 5.1,\n    ]\n    demand = [\n        38, 44, 30, 41, 36, 33, 36, 41, 35, 37,\n        44, 49, 37, 36, 42, 33, 47, 35, 49, 42,\n    ]\n    nwidths = length(prices)\n    n = length(widths)\n    ncols = length(widths)\n    # Initial set of patterns (stored in a sparse matrix: a pattern won't\n    # include many different cuts).\n    patterns = SparseArrays.spzeros(UInt16, n, ncols)\n    for i = 1:n\n        patterns[i, i] = min(\n            floor(Int, maxwidth / widths[i]), round(Int, demand[i])\n        )\n    end\n    # Write the master problem with this \"reduced\" set of patterns.\n    # Not yet integer variables: otherwise, the dual values may make no sense\n    # (actually, GLPK will yell at you if you're trying to get duals for\n    # integer problems).\n    m = Model(GLPK.Optimizer)\n    set_silent(m)\n    @variable(m, Œ∏[1:ncols] >= 0)\n    @objective(\n        m,\n        Min,\n        sum(\n            Œ∏[p] * (rollcost - sum(patterns[j, p] * prices[j] for j = 1:n))\n            for p = 1:ncols\n        )\n    )\n    @constraint(\n        m,\n        demand_satisfaction[j=1:n],\n        sum(patterns[j, p] * Œ∏[p] for p = 1:ncols) >= demand[j]\n    )\n    # First solve of the master problem.\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        warn(\"Master not optimal ($ncols patterns so far)\")\n    end\n    # Then, generate new patterns, based on the dual information.\n    while ncols - n <= max_gen_cols ## Generate at most max_gen_cols columns.\n        if ! has_duals(m)\n            break\n        end\n        new_pattern = solve_pricing(\n            dual.(demand_satisfaction),\n            maxwidth,\n            widths,\n            rollcost,\n            demand,\n            prices,\n        )\n        # No new pattern to add to the formulation: done!\n        if new_pattern === nothing\n            break\n        end\n        # Otherwise, add the new pattern to the master problem, recompute the\n        # duals, and go on waltzing one more time with the pricing problem.\n        ncols += 1\n        patterns = hcat(patterns, new_pattern)\n        # One new variable.\n        new_var = @variable(m, [ncols], base_name = \"Œ∏\", lower_bound = 0)\n        push!(Œ∏, new_var[ncols])\n        # Update the objective function.\n        set_objective_coefficient(\n            m,\n            Œ∏[ncols],\n            rollcost - sum(patterns[j, ncols] * prices[j] for j = 1:n)\n        )\n        # Update the constraint number j if the new pattern impacts this production.\n        for j = 1:n\n            if new_pattern[j] > 0\n                set_normalized_coefficient(\n                    demand_satisfaction[j], new_var[ncols], new_pattern[j]\n                )\n            end\n        end\n        # Solve the new master problem to update the dual variables.\n        optimize!(m)\n        if termination_status(m) != MOI.OPTIMAL\n            @warn(\"Master not optimal ($ncols patterns so far)\")\n        end\n    end\n    # Finally, impose the master variables to be integer and resolve.\n    # To be exact, at each node in the branch-and-bound tree, we would need to\n    # restart the column generation process (just in case a new column would be\n    # interesting to add). This way, we only get an upper bound (a feasible\n    # solution).\n    set_integer.(Œ∏)\n    optimize!(m)\n    if termination_status(m) != MOI.OPTIMAL\n        @warn(\"Final master not optimal ($ncols patterns)\")\n        return\n    end\n    println(\"Final solution:\")\n    for i = 1:length(Œ∏)\n        if value(Œ∏[i]) > 0.5\n            println(\"$(round(Int, value(Œ∏[i]))) units of pattern $(i)\")\n        end\n    end\n    return\nend\n\nexample_cutting_stock()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cutting_stock_column_generation/","page":"Cutting stock","title":"Cutting stock","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Conic programs/tips_and_tricks.jl\"","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Tips-and-Tricks","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This tutorial is aimed at providing a simplistic introduction to conic programming using JuMP.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"It uses the following packages:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"using JuMP\nimport SCS\nimport LinearAlgebra\n\nimport Random      # hide\nRandom.seed!(1234) # hide\nnothing            # hide","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tip: Tip\nA good resource for learning more about functions which can be modeled using cones is the MOSEK Modeling Cookbook.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#What-is-a-cone?","page":"Tips and Tricks","title":"What is a cone?","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A subset C of a vector space V is a cone if forall x in C and positive scalars lambda  0, the product lambda x in C.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A cone C is a convex cone if lambda x + (1 - lambda) y in C, for any lambda in 0 1, and any x y in C.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#What-is-a-conic-program?","page":"Tips and Tricks","title":"What is a conic program?","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Conic programming problems are convex optimization problems in which a convex function is minimized over the intersection of an affine subspace and a convex cone. An example of a conic-form minimization problems, in the primal form is:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n min_x in mathbbR^n  a_0^T x + b_0 \n textst  A_i x + b_i  in mathcalC_i  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The corresponding dual problem is:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max_y_1 ldots y_m  -sum_i=1^m b_i^T y_i + b_0 \n textst  a_0 - sum_i=1^m A_i^T y_i  = 0 \n  y_i  in mathcalC_i^*  i = 1 ldots m\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"where each mathcalC_i is a closed convex cone and mathcalC_i^* is its dual cone.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Second-Order-Cone","page":"Tips and Tricks","title":"Second-Order Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The Second-Order Cone (or Lorentz Cone) of dimension n is of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q^n =  (t x) in mathbbR^n  t ge x_2 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Minimize the L2 norm of a vector x.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3])\n@variable(model, norm_x)\n@constraint(model, [norm_x; x] in SecondOrderCone())\n@objective(model, Min, norm_x)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Rotated-Second-Order-Cone","page":"Tips and Tricks","title":"Rotated Second-Order Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A Second-Order Cone rotated by pi4 in the (x_1x_2) plane is called a Rotated Second-Order Cone. It is of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Q_r^n =  (tux) in mathbbR^n  2tu ge x_2^2 tu ge 0 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example-2","page":"Tips and Tricks","title":"Example","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Given a set of predictors x, and observations y, find the parameter theta that minimizes the sum of squares loss between y_i and theta x_i.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"x = [1.0, 2.0, 3.0, 4.0]\ny = [0.45, 1.04, 1.51, 1.97]\nmodel = Model()\n@variable(model, Œ∏)\n@variable(model, loss)\n@constraint(model, [loss; 0.5; Œ∏ .* x .- y] in RotatedSecondOrderCone())\n@objective(model, Min, loss)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Exponential-Cone","page":"Tips and Tricks","title":"Exponential Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"An Exponential Cone is a set of the form:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"K_exp =  (xyz) in mathbbR^3  y exp (xy) le z y  0 ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"model = Model()\n@variable(model, x[1:3] >= 0)\n@constraint(model, x in MOI.ExponentialCone())\n@objective(model, Min, x[3])","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example:-Entropy-Maximization","page":"Tips and Tricks","title":"Example: Entropy Maximization","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The entropy maximization problem consists of maximizing the entropy function, H(x) = -xlogx subject to linear inequality constraints.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  - sum_i=1^n x_i log x_i \n textst  mathbf1 x = 1 \n  Ax leq b\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"We can model this problem using an exponential cone by using the following transformation:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"tleq -xlogx iff tleq xlog(1x)  iff (t x 1) in K_exp","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Thus, our problem becomes,","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\n max  1^Tt \n textst  Ax leq b \n  1^T x = 1 \n  (t_i x_i 1) in K_exp  forall i = 1 ldots n \nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"n = 15\nm = 10\nA = randn(m, n)\nb = rand(m, 1)\n\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t[1:n])\n@variable(model, x[1:n])\n@objective(model, Max, sum(t))\n@constraint(model, sum(x) == 1)\n@constraint(model, A * x .<= b)\n@constraint(model, con[i = 1:n], [t[i], x[i], 1] in MOI.ExponentialCone())\noptimize!(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Positive-Semidefinite-Cone","page":"Tips and Tricks","title":"Positive Semidefinite Cone","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"The set of positive semidefinite matrices (PSD) of dimension n form a cone in mathbbR^n. We write this set mathematically as:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"mathcalS_+^n =  X in mathcalS^n mid z^T X z geq 0  forall zin mathbbR^n ","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A PSD cone is represented in JuMP using the MOI sets PositiveSemidefiniteConeTriangle (for upper triangle of a PSD matrix) and PositiveSemidefiniteConeSquare (for a complete PSD matrix). However, it is preferable to use the PSDCone shortcut as illustrated below.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Example:-largest-eigenvalue-of-a-symmetric-matrix","page":"Tips and Tricks","title":"Example: largest eigenvalue of a symmetric matrix","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"Suppose A has eigenvalues lambda_1 geq lambda_2 ldots geq lambda_n. Then the matrix t I-A has eigenvalues t-lambda_1 t-lambda_2 ldots t-lambda_n. Note that t I-A is PSD exactly when all these eigenvalues are non-negative, and this happens for values t geq lambda_1. Thus, we can model the problem of finding the largest eigenvalue of a symmetric matrix as:","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"beginaligned\nlambda_1 = min t \ntext  st  t I-A succeq 0\nendaligned","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"A = [3 2 4; 2 0 2; 4 2 3]\nI = Matrix{Float64}(LinearAlgebra.I, 3, 3)\nmodel = Model(SCS.Optimizer)\nset_silent(model)\n@variable(model, t)\n@objective(model, Min, t)\n@constraint(model, t .* I - A in PSDCone())\n\noptimize!(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"objective_value(model)","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/#Other-Cones-and-Functions","page":"Tips and Tricks","title":"Other Cones and Functions","text":"","category":"section"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"For other cones supported by JuMP, check out the MathOptInterface Manual.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"View this file on Github.","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"","category":"page"},{"location":"tutorials/Conic programs/tips_and_tricks/","page":"Tips and Tricks","title":"Tips and Tricks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DocTestSetup = quote\n    using JuMP\nend","category":"page"},{"location":"manual/containers/#Containers","page":"Containers","title":"Containers","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"JuMP provides specialized containers similar to AxisArrays that enable multi-dimensional arrays with non-integer indices.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"These containers are created automatically by JuMP's macros. Each macro has the same basic syntax:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"@macroname(model, name[key1=index1, index2; optional_condition], other stuff)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The containers are generated by the name[key1=index1, index2; optional_condition] syntax. Everything else is specific to the particular macro.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Containers can be named, e.g., name[key=index], or unnamed, e.g., [key=index]. We call unnamed containers anonymous.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bits inside the square brackets and before the ; the index sets. The index sets can be named, e.g., [i = 1:4], or they can be unnamed, e.g., [1:4].","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We call the bit inside the square brackets and after the ; the condition. Conditions are optional.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"In addition to the standard JuMP macros like @variable and @constraint, which construct containers of variables and constraints respectively, you can use Containers.@container to construct containers with arbitrary elements.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"We will use this macro to explain the three types of containers that are natively supported by JuMP: Array, Containers.DenseAxisArray, and Containers.SparseAxisArray.","category":"page"},{"location":"manual/containers/#Array","page":"Containers","title":"Array","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An Array is created when the index sets are rectangular and the index sets are of the form 1:n.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container(x[i = 1:2, j = 1:3], (i, j))\n2√ó3 Array{Tuple{Int64,Int64},2}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The result is just a normal Julia array, so you can do all the usual things.","category":"page"},{"location":"manual/containers/#Slicing","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Arrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, 1]\n2-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 1)\n\njulia> x[2, :]\n3-element Array{Tuple{Int64,Int64},1}:\n (2, 1)\n (2, 2)\n (2, 3)","category":"page"},{"location":"manual/containers/#Looping","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, 1)\n(2, 1)\n(1, 2)\n(2, 2)\n(1, 3)\n(2, 3)","category":"page"},{"location":"manual/containers/#Get-the-index-sets","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Base.OneTo(3))","category":"page"},{"location":"manual/containers/#Broadcasting","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over an Array returns an Array","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2√ó3 Array{Tuple{Int64,Int64},2}:\n (1, 1)  (2, 1)  (3, 1)\n (1, 2)  (2, 2)  (3, 2)","category":"page"},{"location":"manual/containers/#DenseAxisArray","page":"Containers","title":"DenseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.DenseAxisArray is created when the index sets are rectangular, but not of the form 1:n. The index sets can be of any type.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:2, j = [:A, :B]], (i, j))\n2-dimensional DenseAxisArray{Tuple{Int64,Symbol},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{Tuple{Int64,Symbol},2}:\n (1, :A)  (1, :B)\n (2, :A)  (2, :B)","category":"page"},{"location":"manual/containers/#Slicing-2","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"DenseAxisArrays can be sliced","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :A]\n1-dimensional DenseAxisArray{Tuple{Int64,Symbol},1,...} with index sets:\n    Dimension 1, Base.OneTo(2)\nAnd data, a 2-element Array{Tuple{Int64,Symbol},1}:\n (1, :A)\n (2, :A)\n\njulia> x[1, :]\n1-dimensional DenseAxisArray{Tuple{Int64,Symbol},1,...} with index sets:\n    Dimension 1, Symbol[:A, :B]\nAnd data, a 2-element Array{Tuple{Int64,Symbol},1}:\n (1, :A)\n (1, :B)","category":"page"},{"location":"manual/containers/#Looping-2","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(1, :A)\n(2, :A)\n(1, :B)\n(2, :B)","category":"page"},{"location":"manual/containers/#Get-the-index-sets-2","page":"Containers","title":"Get the index sets","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use axes to obtain the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> axes(x)\n(Base.OneTo(2), Symbol[:A, :B])","category":"page"},{"location":"manual/containers/#Broadcasting-2","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a DenseAxisArray returns a DenseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\n2-dimensional DenseAxisArray{Tuple{Symbol,Int64},2,...} with index sets:\n    Dimension 1, Base.OneTo(2)\n    Dimension 2, Symbol[:A, :B]\nAnd data, a 2√ó2 Array{Tuple{Symbol,Int64},2}:\n (:A, 1)  (:B, 1)\n (:A, 2)  (:B, 2)","category":"page"},{"location":"manual/containers/#SparseAxisArray","page":"Containers","title":"SparseAxisArray","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"A Containers.SparseAxisArray is created when the index sets are non-rectangular. This occurs in two circumstances:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"An index depends on a prior index:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:2, j = i:2], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64,Int64},2,Tuple{Int64,Int64}} with 3 entries:\n  [1, 2]  =  (1, 2)\n  [2, 2]  =  (2, 2)\n  [1, 1]  =  (1, 1)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The [indices; condition] syntax is used:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x = Containers.@container([i = 1:3, j = [:A, :B]; i > 1 && j == :B], (i, j))\nJuMP.Containers.SparseAxisArray{Tuple{Int64,Symbol},2,Tuple{Int64,Symbol}} with 2 entries:\n  [2, B]  =  (2, :B)\n  [3, B]  =  (3, :B)","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here we have the index sets i = 1:3, j = [:A, :B], followed by ;, and then a condition, which evaluates to true or false: i > 1 && j == :B.","category":"page"},{"location":"manual/containers/#Slicing-3","page":"Containers","title":"Slicing","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"# TODO: This is included so we know to update the documentation when this is fixed.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Slicing is not supported.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> x[:, :B]\nERROR: ArgumentError: Indexing with `:` is not supported by Containers.SparseAxisArray\n[...]","category":"page"},{"location":"manual/containers/#Looping-3","page":"Containers","title":"Looping","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Use eachindex to loop over the elements:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> for key in eachindex(x)\n           println(x[key])\n       end\n(2, :B)\n(3, :B)","category":"page"},{"location":"manual/containers/#Broadcasting-3","page":"Containers","title":"Broadcasting","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Broadcasting over a SparseAxisArray returns a SparseAxisArray","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> swap(x::Tuple) = (last(x), first(x))\nswap (generic function with 1 method)\n\njulia> swap.(x)\nJuMP.Containers.SparseAxisArray{Tuple{Symbol,Int64},2,Tuple{Int64,Symbol}} with 2 entries:\n  [2, B]  =  (:B, 2)\n  [3, B]  =  (:B, 3)","category":"page"},{"location":"manual/containers/#How-different-container-types-are-chosen","page":"Containers","title":"How different container types are chosen","text":"","category":"section"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove at compile time that the index sets are rectangular, and indexed by a compact set of integers that start at 1, Containers.@container will return an array. This is the case if your index sets are visible to the macro as 1:n:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:5], i + j)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or an instance of Base.OneTo:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = Base.OneTo(3)\nBase.OneTo(3)\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"If the compiler can prove that the index set is rectangular, but not necessarily of the form 1:n at compile time, then a Containers.DenseAxisArray will be constructed instead:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"info: Info\nWhat happened here? Although we know that set contains 1:3, at compile time the typeof(set) is a UnitRange{Int}. Therefore, Julia can't prove that the range starts at 1 (it only finds this out at runtime), and it defaults to a  DenseAxisArray. The case where we explicitly wrote i = 1:3 worked because the macro can \"see\" the 1 at compile time.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"However, if you know that the indices really do form an Array, you can force the container type with container = Array:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> set = 1:3\n1:3\n\njulia> Containers.@container([i=set, j=1:5], i + j, container = Array)\n3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Here's another example with something similar:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> a = 1\n1\n\njulia> Containers.@container([i=a:3, j=1:5], i + j)\n2-dimensional DenseAxisArray{Int64,2,...} with index sets:\n    Dimension 1, 1:3\n    Dimension 2, Base.OneTo(5)\nAnd data, a 3√ó5 Array{Int64,2}:\n 2  3  4  5  6\n 3  4  5  6  7\n 4  5  6  7  8\n\njulia> Containers.@container([i=1:a, j=1:5], i + j)\n1√ó5 Array{Int64,2}:\n 2  3  4  5  6","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"Finally, if the compiler cannot prove that the index set is rectangular, a Containers.SparseAxisArray will be created.","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"This occurs when some indices depend on a previous one:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i=1:3, j=1:i], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 6 entries:\n  [3, 1]  =  4\n  [3, 2]  =  5\n  [3, 3]  =  6\n  [2, 2]  =  4\n  [1, 1]  =  2\n  [2, 1]  =  3","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"or if there is a condition on the index sets:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> Containers.@container([i = 1:5; isodd(i)], i^2)\nJuMP.Containers.SparseAxisArray{Int64,1,Tuple{Int64}} with 3 entries:\n  [3]  =  9\n  [5]  =  25\n  [1]  =  1","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"The condition can depend on multiple indices; it just needs to be a function that returns true or false:","category":"page"},{"location":"manual/containers/","page":"Containers","title":"Containers","text":"julia> condition(i, j) = isodd(i) && iseven(j)\ncondition (generic function with 1 method)\n\njulia> Containers.@container([i = 1:2, j = 1:4; condition(i, j)], i + j)\nJuMP.Containers.SparseAxisArray{Int64,2,Tuple{Int64,Int64}} with 2 entries:\n  [1, 2]  =  3\n  [1, 4]  =  5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"CurrentModule = JuMP\nDocTestSetup = quote\n    using JuMP, GLPK\nend\nDocTestFilters = [r\"‚â§|<=\", r\"‚â•|>=\", r\" == | = \", r\" ‚àà | in \", r\"MathOptInterface|MOI\"]","category":"page"},{"location":"manual/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"This section of the manual describes how to access a solved solution to a problem. It uses the following model as an example:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y[[:a, :b]] <= 1)\n@objective(model, Max, -12x - 20y[:a])\n@expression(model, my_expr, 6x + 8y[:a])\n@constraint(model, my_expr >= 100)\n@constraint(model, c1, 7x + 12y[:a] >= 120)\noptimize!(model)\nprint(model)\n\n# output\n\nMax -12 x - 20 y[a]\nSubject to\n 6 x + 8 y[a] ‚â• 100.0\n c1 : 7 x + 12 y[a] ‚â• 120.0\n x ‚â• 0.0\n y[a] ‚â§ 1.0\n y[b] ‚â§ 1.0","category":"page"},{"location":"manual/solutions/#Solutions-summary","page":"Solutions","title":"Solutions summary","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solution_summary can be used for checking the summary of the optimization solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> solution_summary(model)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n\n* Work counters\n  Solve time (sec)   : 0.00008\n\njulia> solution_summary(model, verbose=true)\n* Solver : GLPK\n\n* Status\n  Termination status : OPTIMAL\n  Primal status      : FEASIBLE_POINT\n  Dual status        : FEASIBLE_POINT\n  Result count       : 1\n  Has duals          : true\n  Message from the solver:\n  \"Solution is optimal\"\n\n* Candidate solution\n  Objective value      : -205.14285714285714\n  Objective bound      : Inf\n  Dual objective value : -205.1428571428571\n  Primal solution :\n    x : 15.428571428571429\n    y[a] : 1.0\n    y[b] : 1.0\n  Dual solution :\n    c1 : 1.7142857142857142\n\n* Work counters\n  Solve time (sec)   : 0.00008","category":"page"},{"location":"manual/solutions/#Why-did-the-solver-stop?","page":"Solutions","title":"Why did the solver stop?","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Usetermination_status to understand why the solver stopped.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The MOI.TerminationStatusCode enum describes the full list of statuses that could be returned.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Common return values include MOI.OPTIMAL, MOI.LOCALLY_SOLVED, MOI.INFEASIBLE, MOI.DUAL_INFEASIBLE, and MOI.TIME_LIMIT.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nA return status of MOI.OPTIMAL means the solver found (and proved) a globally optimal solution. A return status of MOI.LOCALLY_SOLVED means the solver found a locally optimal solution (which may also be globally optimal, but it could not prove so).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nA return status of MOI.DUAL_INFEASIBLE does not guarantee that the primal is unbounded. When the dual is infeasible, the primal is unbounded if there exists a feasible primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use raw_status to get a solver-specific string explaining why the optimization stopped:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> raw_status(model)\n\"Solution is optimal\"","category":"page"},{"location":"manual/solutions/#Primal-solutions","page":"Solutions","title":"Primal solutions","text":"","category":"section"},{"location":"manual/solutions/#Primal-solution-status","page":"Solutions","title":"Primal solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use primal_status to return an MOI.ResultStatusCode enum describing the status of the primal solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are MOI.NO_SOLUTION, and MOI.INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the primal solution is a certificate of dual infeasbility (a primal unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_values, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_values(model)\ntrue","category":"page"},{"location":"manual/solutions/#Objective-values","page":"Solutions","title":"Objective values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The objective value of a solved problem can be obtained via objective_value. The best known bound on the optimal objective value can be obtained via objective_bound. If the solver supports it, the value of the dual objective can be obtained via dual_objective_value.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> objective_value(model)\n-205.14285714285714\n\njulia> objective_bound(model)  # GLPK only implements objective bound for MIPs\nInf\n\njulia> dual_objective_value(model)\n-205.1428571428571","category":"page"},{"location":"manual/solutions/#Primal-solution-values","page":"Solutions","title":"Primal solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a primal solution to return, use value to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(x)\n15.428571428571429","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Broadcast [value](@ref) over containers:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n 1.0\n 1.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"value also works on expressions:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(my_expr)\n100.57142857142857","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"and constraints:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> value(c1)\n120.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"info: Info\nCalling value on a constraint returns the constraint function evaluated at the solution.","category":"page"},{"location":"manual/solutions/#Dual-solutions","page":"Solutions","title":"Dual solutions","text":"","category":"section"},{"location":"manual/solutions/#Dual-solution-status","page":"Solutions","title":"Dual solution status","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Use dual_status to return an MOI.ResultStatusCode enum describing the status of the dual solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual_status(model)\nFEASIBLE_POINT::ResultStatusCode = 1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Other common returns are MOI.NO_SOLUTION, and MOI.INFEASIBILITY_CERTIFICATE. The first means that the solver doesn't have a solution to return, and the second means that the dual solution is a certificate of primal infeasbility (a dual unbounded ray).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"You can also use has_duals, which returns true if there is a solution that can be queried, and false otherwise.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> has_duals(model)\ntrue","category":"page"},{"location":"manual/solutions/#Dual-solution-values","page":"Solutions","title":"Dual solution values","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the solver has a dual solution to return, use dual to access it:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(c1)\n1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Query the duals of variable bounds using LowerBoundRef, UpperBoundRef, and FixRef:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> dual(LowerBoundRef(x))\n0.0\n\njulia> dual.(UpperBoundRef.(y))\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n -0.5714285714285694\n  0.0","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nJuMP's definition of duality is independent of the objective sense. That is, the sign of feasible duals associated with a constraint depends on the direction of the constraint and not whether the problem is maximization or minimization. This is a different convention from linear programming duality in some common textbooks. If you have a linear program, and you want the textbook definition, you probably want to use shadow_price and reduced_cost instead.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> shadow_price(c1)\n1.7142857142857142\n\njulia> reduced_cost(x)\n0.0\n\njulia> reduced_cost.(y)\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, Symbol[:a, :b]\nAnd data, a 2-element Array{Float64,1}:\n  0.5714285714285694\n -0.0","category":"page"},{"location":"manual/solutions/#Recommended-workflow","page":"Solutions","title":"Recommended workflow","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The recommended workflow for solving a model and querying the solution is something like the following:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"if termination_status(model) == MOI.OPTIMAL\n    println(\"Solution is optimal\")\nelseif termination_status(model) == MOI.TIME_LIMIT && has_values(model)\n    println(\"Solution is suboptimal due to a time limit, but a primal solution is available\")\nelse\n    error(\"The model was not solved correctly.\")\nend\nprintln(\"  objective value = \", objective_value(model))\nif primal_status(model) == MOI.FEASIBLE_POINT\n    println(\"  primal solution: x = \", value(x))\nend\nif dual_status(model) == MOI.FEASIBLE_POINT\n    println(\"  dual solution: c1 = \", dual(c1))\nend\n\n# output\n\nSolution is optimal\n  objective value = -205.14285714285714\n  primal solution: x = 15.428571428571429\n  dual solution: c1 = 1.7142857142857142","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nQuerying solution information after modifying a solved model is undefined behavior, and solvers may throw an error or return incorrect results. Modifications include adding, deleting, or modifying any variable, objective, or constraint. Instead of modify-then-query, query the results first, then modify the problem. For example:model = Model(GLPK.Optimizer)\n@variable(model, x >= 0)\noptimize!(model)\n# Bad:\nset_lower_bound(x, 1)\n@show value(x)\n# Good:\nx_val = value(x)\nset_lower_bound(x, 1)\n@show x_val","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# TODO: How to accurately measure the solve time.","category":"page"},{"location":"manual/solutions/#Accessing-attributes","page":"Solutions","title":"Accessing attributes","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"MathOptInterface defines a large number of model attributes that can be queried. Some attributes can be directly accessed by getter functions. These include:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"solve_time\nrelative_gap\nsimplex_iterations\nbarrier_iterations\nnode_count","category":"page"},{"location":"manual/solutions/#Sensitivity-analysis-for-LP","page":"Solutions","title":"Sensitivity analysis for LP","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Given an LP problem and an optimal solution corresponding to a basis, we can question how much an objective coefficient or standard form right-hand side coefficient (c.f., normalized_rhs) can change without violating primal or dual feasibility of the basic solution.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Note that not all solvers compute the basis, and for sensitivity analysis, the solver interface must implement MOI.ConstraintBasisStatus.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To give a simple example, we could analyze the sensitivity of the optimal solution to the following (non-degenerate) LP problem:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[1:2])\nset_lower_bound(x[2], -0.5)\nset_upper_bound(x[2], 0.5)\n@constraint(model, c1, x[1] + x[2] <= 1)\n@constraint(model, c2, x[1] - x[2] <= 1)\n@objective(model, Max, x[1])\nprint(model)\n\n# output\n\nMax x[1]\nSubject to\n c1 : x[1] + x[2] ‚â§ 1.0\n c2 : x[1] - x[2] ‚â§ 1.0\n x[2] ‚â• -0.5\n x[2] ‚â§ 0.5","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To analyze the sensitivity of the problem we could check the allowed perturbation ranges of, e.g., the cost coefficients and the right-hand side coefficient of the constraint c1 as follows:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> value.(x)\n2-element Array{Float64,1}:\n 1.0\n 0.0\n\njulia> report = lp_sensitivity_report(model);\n\njulia> x1_lo, x1_hi = report[x[1]]\n(-1.0, Inf)\n\njulia> println(\"The objective coefficient of x[1] could decrease by $(x1_lo) or increase by $(x1_hi).\")\nThe objective coefficient of x[1] could decrease by -1.0 or increase by Inf.\n\njulia> x2_lo, x2_hi = report[x[2]]\n(-1.0, 1.0)\n\njulia> println(\"The objective coefficient of x[2] could decrease by $(x2_lo) or increase by $(x2_hi).\")\nThe objective coefficient of x[2] could decrease by -1.0 or increase by 1.0.\n\njulia> c_lo, c_hi = report[c1]\n(-1.0, 1.0)\n\njulia> println(\"The RHS of c1 could decrease by $(c_lo) or increase by $(c_hi).\")\nThe RHS of c1 could decrease by -1.0 or increase by 1.0.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The range associated with a variable is the range of the allowed perturbation of the corresponding objective coefficient. Note that the current primal solution remains optimal within this range; however the corresponding dual solution might change since a cost coefficient is perturbed. Similarly, the range associated with a constraint is the range of the allowed perturbation of the corresponding right-hand side coefficient. In this range the current dual solution remains optimal, but the optimal primal solution might change.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the problem is degenerate, there are multiple optimal bases and hence these ranges might not be as intuitive and seem too narrow. E.g., a larger cost coefficient perturbation might not invalidate the optimality of the current primal solution. Moreover, if a problem is degenerate, due to finite precision, it can happen that, e.g., a perturbation seems to invalidate a basis even though it doesn't (again providing too narrow ranges). To prevent this, increase the atol keyword argument to lp_sensitivity_report. Note that this might make the ranges too wide for numerically challenging instances. Thus, do not blindly trust these ranges, especially not for highly degenerate or numerically unstable instances.","category":"page"},{"location":"manual/solutions/#Conflicts","page":"Solutions","title":"Conflicts","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"When the model you input is infeasible, some solvers can help you find the cause of this infeasibility by offering a conflict, i.e., a subset of the constraints that create this infeasibility. Depending on the solver, this can also be called an IIS (irreducible inconsistent subsystem).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function compute_conflict! is used to trigger the computation of a conflict. Once this process is finished, the attribute MOI.ConflictStatus returns a MOI.ConflictStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If there is a conflict, you can query from each constraint whether it participates in the conflict or not using the attribute MOI.ConstraintConflictStatus, which returns a MOI.ConflictParticipationStatusCode.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To create a new model containing only the constraints that participate in the conflict, use copy_conflict. It may be helpful to write this model to a file for easier debugging using write_to_file.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"For instance, this is how you can use this functionality:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model() # You must use a solver that supports conflict refining/IIS\n# computation, like CPLEX or Gurobi\n@variable(model, x >= 0)\n@constraint(model, c1, x >= 2)\n@constraint(model, c2, x <= 1)\noptimize!(model)\n\n# termination_status(model) will likely be MOI.INFEASIBLE,\n# depending on the solver\n\ncompute_conflict!(model)\nif MOI.get(model, MOI.ConflictStatus()) != MOI.CONFLICT_FOUND\n    error(\"No conflict could be found for an infeasible model.\")\nend\n\n# Both constraints should participate in the conflict.\nMOI.get(model, MOI.ConstraintConflictStatus(), c1)\nMOI.get(model, MOI.ConstraintConflictStatus(), c2)\n\n# Get a copy of the model with only the constraints in the conflict.\nnew_model, reference_map = copy_conflict(model)","category":"page"},{"location":"manual/solutions/#Multiple-solutions","page":"Solutions","title":"Multiple solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Some solvers support returning multiple solutions. You can check how many solutions are available to query using result_count.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Functions for querying the solutions, e.g., primal_status and value, all take an additional keyword argument result which can be used to specify which result to return.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"warning: Warning\nEven if termination_status is MOI.OPTIMAL, some of the returned solutions may be suboptimal! However, if the solver found at least one optimal solution, then result = 1 will always return an optimal solution. Use objective_value to assess the quality of the remaining solutions.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"using JuMP\nmodel = Model()\n@variable(model, x[1:10] >= 0)\n# ... other constraints ...\noptimize!(model)\n\nif termination_status(model) != MOI.OPTIMAL\n    error(\"The model was not solved correctly.\")\nend\n\nan_optimal_solution = value.(x; result = 1)\noptimal_objective = objective_value(model; result = 1)\nfor i in 2:result_count(model)\n    @assert has_values(model; result = i)\n    println(\"Solution $(i) = \", value.(x; result = i))\n    obj = objective_value(model; result = i)\n    println(\"Objective $(i) = \", obj)\n    if isapprox(obj, optimal_objective; atol = 1e-8)\n        print(\"Solution $(i) is also optimal!\")\n    end\nend","category":"page"},{"location":"manual/solutions/#Checking-feasibility-of-solutions","page":"Solutions","title":"Checking feasibility of solutions","text":"","category":"section"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To check the feasibility of a primal solution, use primal_feasibility_report, which takes a model, a dictionary mapping each variable to a primal solution value (defaults to the last solved solution), and a tolerance atol (defaults to 0.0).","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"The function returns a dictionary which maps the infeasible constraint references to the distance between the primal value of the constraint and the nearest point in the corresponding set. A point is classed as infeasible if the distance is greater than the supplied tolerance atol.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"# Add a filter here because the output of the dictionary is not ordered, and\n# changes in printing order will cause the doctest to fail.","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> model = Model(GLPK.Optimizer);\n\njulia> @variable(model, x >= 1, Int);\n\njulia> @variable(model, y);\n\njulia> @constraint(model, c1, x + y <= 1.95);\n\njulia> point = Dict(x => 1.9, y => 0.06);\n\njulia> primal_feasibility_report(model, point)\nDict{Any,Float64} with 2 entries:\n  c1 : x + y ‚â§ 1.95 => 0.01\n  x integer         => 0.1\n\njulia> primal_feasibility_report(model, point; atol = 0.02)\nDict{Any,Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"If the point is feasible, an empty dictionary is returned:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 1.0, y => 0.0))\nDict{Any,Float64} with 0 entries","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"To use the primal solution from a solve, omit the point argument:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> optimize!(model)\n\njulia> primal_feasibility_report(model)\nDict{Any,Float64} with 0 entries","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"Pass skip_mising = true to skip constraints which contain variables that are not in point:","category":"page"},{"location":"manual/solutions/","page":"Solutions","title":"Solutions","text":"julia> primal_feasibility_report(model, Dict(x => 2.1); skip_missing = true)\nDict{Any,Float64} with 1 entry:\n  x integer => 0.1","category":"page"},{"location":"reference/expressions/#ExpressionAPI","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"More information can be found in the Expressions section of the manual.","category":"page"},{"location":"reference/expressions/#Macros","page":"Expressions","title":"Macros","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"@expression\n@expressions","category":"page"},{"location":"reference/expressions/#JuMP.@expression","page":"Expressions","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#JuMP.@expressions","page":"Expressions","title":"JuMP.@expressions","text":"@expressions(model, args...)\n\nAdds multiple expressions to model at once, in the same fashion as the @expression macro.\n\nThe model must be the first argument, and multiple variables can be added on multiple lines wrapped in a begin ... end block.\n\nExamples\n\n@expressions(model, begin\n    my_expr, x^2 + y^2\n    my_expr_1[i = 1:2], a[i] - z[i]\nend)\n\n\n\n\n\n","category":"macro"},{"location":"reference/expressions/#Affine-expressions","page":"Expressions","title":"Affine expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericAffExpr\nAffExpr\nlinear_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericAffExpr","page":"Expressions","title":"JuMP.GenericAffExpr","text":"mutable struct GenericAffExpr{CoefType,VarType} <: AbstractJuMPScalar\n    constant::CoefType\n    terms::OrderedDict{VarType,CoefType}\nend\n\nAn expression type representing an affine expression of the form: sum a_i x_i + c.\n\nFields\n\n.constant: the constant c in the expression.\n.terms: an OrderedDict, with keys of VarType and values of CoefType describing the sparse vector a.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.AffExpr","page":"Expressions","title":"JuMP.AffExpr","text":"AffExpr\n\nAlias for GenericAffExpr{Float64,VariableRef}, the specific GenericAffExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.linear_terms","page":"Expressions","title":"JuMP.linear_terms","text":"linear_terms(aff::GenericAffExpr{C, V})\n\nProvides an iterator over coefficient-variable tuples (a_i::C, x_i::V) in the linear part of the affine expression.\n\n\n\n\n\nlinear_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, variable::V) in the linear part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Quadratic-expressions","page":"Expressions","title":"Quadratic expressions","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"GenericQuadExpr\nQuadExpr\nUnorderedPair\nquad_terms","category":"page"},{"location":"reference/expressions/#JuMP.GenericQuadExpr","page":"Expressions","title":"JuMP.GenericQuadExpr","text":"mutable struct GenericQuadExpr{CoefType,VarType} <: AbstractJuMPScalar\n    aff::GenericAffExpr{CoefType,VarType}\n    terms::OrderedDict{UnorderedPair{VarType}, CoefType}\nend\n\nAn expression type representing an quadratic expression of the form: sum q_ij x_i x_j + sum a_i x_i + c.\n\nFields\n\n.aff: an GenericAffExpr representing the affine portion of the expression.\n.terms: an OrderedDict, with keys of UnorderedPair{VarType} and values of CoefType, describing the sparse list of terms q.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.QuadExpr","page":"Expressions","title":"JuMP.QuadExpr","text":"QuadExpr\n\nAn alias for GenericQuadExpr{Float64,VariableRef}, the specific     GenericQuadExpr used by JuMP.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.UnorderedPair","page":"Expressions","title":"JuMP.UnorderedPair","text":"UnorderedPair(a::T, b::T)\n\nA wrapper type used by GenericQuadExpr with fields .a and .b.\n\n\n\n\n\n","category":"type"},{"location":"reference/expressions/#JuMP.quad_terms","page":"Expressions","title":"JuMP.quad_terms","text":"quad_terms(quad::GenericQuadExpr{C, V})\n\nProvides an iterator over tuples (coefficient::C, var_1::V, var_2::V) in the quadratic part of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#Utilities-and-modifications","page":"Expressions","title":"Utilities and modifications","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"constant\ncoefficient\nisequal_canonical\nadd_to_expression!\ndrop_zeros!\nmap_coefficients\nmap_coefficients_inplace!","category":"page"},{"location":"reference/expressions/#JuMP.constant","page":"Expressions","title":"JuMP.constant","text":"constant(aff::GenericAffExpr{C, V})::C\n\nReturn the constant of the affine expression.\n\n\n\n\n\nconstant(aff::GenericQuadExpr{C, V})::C\n\nReturn the constant of the quadratic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.coefficient","page":"Expressions","title":"JuMP.coefficient","text":"coefficient(v1::VariableRef, v2::VariableRef)\n\nReturn 1.0 if v1 == v2, and 0.0 otherwise.\n\nThis is a fallback for other coefficient methods to simplify code in which the expression may be a single variable.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine expression a.\n\n\n\n\n\ncoefficient(a::GenericAffExpr{C,V}, v1::V, v2::V) where {C,V}\n\nReturn the coefficient associated with the term v1 * v2 in the quadratic expression a.\n\nNote that coefficient(a, v1, v2) is the same as coefficient(a, v2, v1).\n\n\n\n\n\ncoefficient(a::GenericQuadExpr{C,V}, v::V) where {C,V}\n\nReturn the coefficient associated with variable v in the affine component of a.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.isequal_canonical","page":"Expressions","title":"JuMP.isequal_canonical","text":"isequal_canonical(\n    aff::GenericAffExpr{C,V},\n    other::GenericAffExpr{C,V}\n) where {C,V}\n\nReturn true if aff is equal to other after dropping zeros and disregarding the order. Mainly useful for testing.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.add_to_expression!","page":"Expressions","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.drop_zeros!","page":"Expressions","title":"JuMP.drop_zeros!","text":"drop_zeros!(expr::GenericAffExpr)\n\nRemove terms in the affine expression with 0 coefficients.\n\n\n\n\n\ndrop_zeros!(expr::GenericQuadExpr)\n\nRemove terms in the quadratic expression with 0 coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients","page":"Expressions","title":"JuMP.map_coefficients","text":"map_coefficients(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x + 2\n\njulia> a\nx + 1\n\n\n\n\n\nmap_coefficients(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and return a new expression.\n\nSee also: map_coefficients_inplace!\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx¬≤ + x + 1\n\njulia> map_coefficients(c -> 2 * c, a)\n2 x¬≤ + 2 x + 2\n\njulia> a\nx¬≤ + x + 1\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.map_coefficients_inplace!","page":"Expressions","title":"JuMP.map_coefficients_inplace!","text":"map_coefficients_inplace!(f::Function, a::GenericAffExpr)\n\nApply f to the coefficients and constant term of an GenericAffExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = GenericAffExpr(1.0, x => 1.0)\nx + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x + 2\n\njulia> a\n2 x + 2\n\n\n\n\n\nmap_coefficients_inplace!(f::Function, a::GenericQuadExpr)\n\nApply f to the coefficients and constant term of an GenericQuadExpr a and update them in-place.\n\nSee also: map_coefficients\n\nExample\n\njulia> a = @expression(model, x^2 + x + 1)\nx¬≤ + x + 1\n\njulia> map_coefficients_inplace!(c -> 2 * c, a)\n2 x¬≤ + 2 x + 2\n\njulia> a\n2 x¬≤ + 2 x + 2\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP-to-MOI-converters","page":"Expressions","title":"JuMP-to-MOI converters","text":"","category":"section"},{"location":"reference/expressions/","page":"Expressions","title":"Expressions","text":"variable_ref_type\njump_function\njump_function_type\nmoi_function\nmoi_function_type","category":"page"},{"location":"reference/expressions/#JuMP.variable_ref_type","page":"Expressions","title":"JuMP.variable_ref_type","text":"variable_ref_type(::GenericAffExpr{C, V}) where {C, V}\n\nA helper function used internally by JuMP and some JuMP extensions. Returns the variable type V from a GenericAffExpr\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function","page":"Expressions","title":"JuMP.jump_function","text":"jump_function(x)\n\nGiven an MathOptInterface object x, return the JuMP equivalent.\n\nSee also: moi_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.jump_function_type","page":"Expressions","title":"JuMP.jump_function_type","text":"jump_function_type(::Type{T}) where {T}\n\nGiven an MathOptInterface object type T, return the JuMP equivalent.\n\nSee also: moi_function_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function","page":"Expressions","title":"JuMP.moi_function","text":"moi_function(x)\n\nGiven a JuMP object x, return the MathOptInterface equivalent.\n\nSee also: jump_function.\n\n\n\n\n\n","category":"function"},{"location":"reference/expressions/#JuMP.moi_function_type","page":"Expressions","title":"JuMP.moi_function_type","text":"moi_function_type(::Type{T}) where {T}\n\nGiven a JuMP object type T, return the MathOptInterface equivalent.\n\nSee also: jump_function_type.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/performance_tips.jl\"","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This tutorial explains how to write performant JuMP code.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"tip: Tip\nRead the Performance tips section of the Julia manual. The most important rule is to avoid global variables!","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"using JuMP  # hide","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Use-macros-to-build-expressions","page":"Performance tips","title":"Use macros to build expressions","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/#What","page":"Performance tips","title":"What","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Use JuMP's macros (or add_to_expression! to build expressions. Avoid constructing expressions outside the macros.","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Why","page":"Performance tips","title":"Why","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Constructing an expression outside the macro results in intermediate copies of the expression. For example,","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"is equivalent to","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"a = x[1]\nb = a + x[2]\nc = b + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Since we only care about c, the a and b expressions are not needed and constructing them slows the program down!","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"JuMP's macros rewrite the expressions to operate in-place and avoid these extra copies. Because they allocate less memory, they are faster, particularly for large expressions.","category":"page"},{"location":"tutorials/Getting started/performance_tips/#Example","page":"Performance tips","title":"Example","text":"","category":"section"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"model = Model()\n@variable(model, x[1:3])","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"Here's what happens if we construct the expression outside the macro:","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated x[1] + x[2] + x[3]","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"info: Info\nThe @allocated measures how many bytes were allocated during the evaluation of an expression. Fewer is better.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"If we use the @expression macro, we get many fewer allocations:","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"@allocated @expression(model, x[1] + x[2] + x[3])","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"","category":"page"},{"location":"tutorials/Getting started/performance_tips/","page":"Performance tips","title":"Performance tips","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Mixed-integer linear programs/cannery.jl\"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/#The-cannery-problem","page":"The cannery problem","title":"The cannery problem","text":"","category":"section"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"A JuMP implementation of the cannery problem from:","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"Dantzig, Linear Programming and Extensions, Princeton University Press, Princeton, NJ, 1963.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"It was originally contributed by Louis Luangkesorn, January 30, 2015.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"using JuMP\nimport GLPK\n\nfunction example_cannery()\n    # Origin plants.\n    plants = [\"Seattle\", \"San-Diego\"]\n    num_plants = length(plants)\n    # Destination markets.\n    markets = [\"New-York\", \"Chicago\", \"Topeka\"]\n    num_markets = length(markets)\n    # Capacity and demand in cases.\n    capacity = [350, 600]\n    demand = [300, 300, 300]\n    # Distance in thousand miles.\n    distance = [2.5 1.7 1.8; 2.5 1.8 1.4]\n    # Cost per case per thousand miles.\n    freight = 90\n    cannery = Model()\n    set_optimizer(cannery, GLPK.Optimizer)\n    # Create decision variables.\n    @variable(cannery, ship[1:num_plants, 1:num_markets] >= 0)\n    # Ship no more than plant capacity\n    @constraint(\n        cannery, capacity_con[i = 1:num_plants], sum(ship[i, :]) <= capacity[i]\n    )\n    # Ship at least market demand\n    @constraint(\n        cannery, demand_con[j = 1:num_markets], sum(ship[:, j]) >= demand[j]\n    )\n    # Minimize transportation cost\n    @objective(\n        cannery,\n        Min,\n        sum(\n            distance[i, j] * freight * ship[i, j]\n            for i = 1:num_plants, j = 1:num_markets\n        )\n    )\n    optimize!(cannery)\n    println(\"RESULTS:\")\n    for i = 1:num_plants\n        for j = 1:num_markets\n            println(\"  $(plants[i]) $(markets[j]) = $(value(ship[i, j]))\")\n        end\n    end\n    return\nend\n\nexample_cannery()","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"View this file on Github.","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"","category":"page"},{"location":"tutorials/Mixed-integer linear programs/cannery/","page":"The cannery problem","title":"The cannery problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Getting started/working_with_data_files.jl\"","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Working-with-Data-Files","page":"Working with Data Files","title":"Working with Data Files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Originally Contributed by: Arpit Bhatia","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"In many cases we might need to read data available in an external file rather than type it into Julia ourselves.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"This tutorial is concerned with reading tabular data into Julia and using it for a JuMP model.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We'll be reading data using the DataFrames.jl package and some other packages specific to file types.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The data are stored in the /docs/src/tutorials/Getting started/data directory of the JuMP source code.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"const DATA_DIR = joinpath(@__DIR__, \"data\");\nnothing #hide","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"note: Note\nThere are multiple ways to read the same kind of data into Julia. This tutorial focuses on DataFrames.jl because it provides the ecosystem to work with most of the required file types in a straightforward manner.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#DataFrames.jl","page":"Working with Data Files","title":"DataFrames.jl","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The DataFrames package provides a set of tools for working with tabular data. It is available through the Julia package system.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import DataFrames","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#What-is-a-DataFrame?","page":"Working with Data Files","title":"What is a DataFrame?","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"A DataFrame is a data structure like a table or spreadsheet. You can use it for storing and exploring a set of related data values. Think of it as a smarter array for holding tabular data.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Reading-Tabular-Data-into-a-DataFrame","page":"Working with Data Files","title":"Reading Tabular Data into a DataFrame","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We will begin by reading data from different file formats into a DataFrame object.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Excel-Sheets","page":"Working with Data Files","title":"Excel Sheets","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Excel files can be read using the XLSX.jl package.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Pkg.add(\"XLSX\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import XLSX","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"To read a Excel file into a DataFrame, we use the following julia code. The first argument to the readtable function is the file to be read and the second argument is the name of the sheet.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df = DataFrames.DataFrame(\n    XLSX.readtable(joinpath(DATA_DIR, \"SalesData.xlsx\"), \"SalesOrders\")...\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#CSV-files","page":"Working with Data Files","title":"CSV files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"CSV and other delimited text files can be read by the CSV.jl package.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Pkg.add(\"CSV\")","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"import CSV","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"To read a CSV file into a DataFrame, we use the CSV.read function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df = CSV.read(joinpath(DATA_DIR, \"StarWars.csv\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Other-Delimited-Files","page":"Working with Data Files","title":"Other Delimited Files","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also use the CSV.jl package to read any other delimited text file format.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"By default, CSV.File will try to detect a file's delimiter from the first 10 lines of the file.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Candidate delimiters include ',', '\\t', ' ', '|', ';', and ':'. If it can't auto-detect the delimiter, it will assume ','.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let's take the example of space separated data.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"ss_df = CSV.read(joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also specify the delimiter by passing the delim argument.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"delim_df = CSV.read(\n    joinpath(DATA_DIR, \"Soccer.txt\"), DataFrames.DataFrame, delim = \"::\"\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Note that by default, are read-only. If we wish to make changes to the data read, we pass the copycols = true argument in the function call.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"ss_df = CSV.read(\n    joinpath(DATA_DIR, \"Cereal.txt\"), DataFrames.DataFrame, copycols = true\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Working-with-DataFrames","page":"Working with Data Files","title":"Working with DataFrames","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Now that we have read the required data into a DataFrame, let us look at some basic operations we can perform on it.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Querying-Basic-Information","page":"Working with Data Files","title":"Querying Basic Information","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The size function gets us the dimensions of the DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.size(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can also us the nrow and ncol functions to get the number of rows and columns respectively.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.nrow(ss_df), DataFrames.ncol(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The describe function gives basic summary statistics of data in a DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.describe(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Names of every column can be obtained by the names function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"DataFrames.names(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Corresponding data types are obtained using the broadcasted eltype function.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"eltype.(ss_df)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#Accessing-the-Data","page":"Working with Data Files","title":"Accessing the Data","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Similar to regular arrays, we use numerical indexing to access elements of a DataFrame.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1, 1]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The following are different ways to access a column.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[!, 1]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[!, :Name]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df.Name","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[:, 1] # Note that this creates a copy.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The following are different ways to access a row.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1:1, :]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"csv_df[1, :] # This produces a DataFrameRow.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We can change the values just as we normally assign values.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Assign a range to scalar.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[1:3, 5] .= 1","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Vector to equal length vector.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[4:6, 5] = [4, 5, 6]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Subset of the DataFrame to another data frame of matching size.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df[1:2, 6:7] =  DataFrames.DataFrame(\n    [-2 -2; -2 -2], [Symbol(\"Unit Cost\"), :Total]\n)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"excel_df","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"tip: Tip\nThere are a lot more things which can be done with a DataFrame. Read the docs for more information.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/#A-Complete-Modelling-Example-Passport-Problem","page":"Working with Data Files","title":"A Complete Modelling Example - Passport Problem","text":"","category":"section"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let's now apply what we have learnt to solve a real modelling problem.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The Passport Index Dataset lists travel visa requirements for 199 countries, in .csv format. Our task is to find out the minimum number of passports required to visit all countries.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"In this dataset, the first column represents a passport (=from) and each remaining column represents a foreign country (=to).","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The values in each cell are as follows:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"3 = visa-free travel\n2 = eTA is required\n1 = visa can be obtained on arrival\n0 = visa is required\n-1 is for all instances where passport and destination are the same","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Our task is to find out the minimum number of passports needed to visit every country without requiring a visa.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Thus, the values we are interested in are -1 and 3. Let us modify the data in the following manner:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"passport_data = CSV.read(\n    joinpath(DATA_DIR, \"passport-index-matrix.csv\"),\n    DataFrames.DataFrame;\n    copycols = true,\n)\n\nfor i in 1:DataFrames.nrow(passport_data)\n    for j in 2:DataFrames.ncol(passport_data)\n        if passport_data[i, j] == -1 || passport_data[i, j] == 3\n            passport_data[i, j] = 1\n        else\n            passport_data[i, j] = 0\n        end\n    end\nend","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"The values in the cells now represent:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"1 = no visa required for travel\n0 = visa required for travel","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Let us associate each passport with a decision variable pass_cntr for each country. We want to minimize the sum sum pass_cntr over all countries.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Since we wish to visit all the countries, for every country, we should own at least one passport that lets us travel to that country visa free. For one destination, this can be mathematically represented as sum_cntr in world passportdata_cntrdest cdot pass_cntr geq 1.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Thus, we can represent this problem using the following model:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"beginaligned\nmin  sum_cntr in World pass_cntr \ntextst  sum_cntr in World passportdata_cntrdest cdot pass_cntr geq 1  forall dest in World \n pass_cntr in 01  forall cntr in World\nendaligned","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"We'll now solve the problem using JuMP.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"using JuMP\nimport GLPK","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"First, create the set of countries:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"World = names(passport_data)[2:end]","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Then, create the model and initialize the decision variables:","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"model = Model(GLPK.Optimizer)\n@variable(model, pass[cntr in World], Bin)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Define the objective function","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"@objective(model, Min, sum(pass[cntr] for cntr in World))","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"@constraint(model, [dest in World], passport_data[:, dest]' * pass >= 1)","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"Now optimize!","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"optimize!(model)\nprintln(\"Minimum number of passports needed: \", objective_value(model))","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"optimal_passports = [cntr for cntr in World if value(pass[cntr]) > 0.5]\nprintln(\"Countries:\")\nfor p in optimal_passports\n    println(\" \", p)\nend","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"note: Note\nWe use value(pass[i]) > 0.5 rather than value(pass[i]) == 1 to avoid excluding solutions like pass[i] = 0.99999 that are \"1\" to some tolerance.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"View this file on Github.","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"","category":"page"},{"location":"tutorials/Getting started/working_with_data_files/","page":"Working with Data Files","title":"Working with Data Files","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"EditURL = \"https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/tutorials/Semidefinite programs/max_cut_sdp.jl\"","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/#SDP-relaxations:-max-cut","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"section"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Solves a semidefinite programming relaxation of the MAXCUT graph problem:","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"max   0.25 * L‚Ä¢X\ns.t.  diag(X) == e\n      X ‚âΩ 0","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Where L is the weighted graph Laplacian. Uses this relaxation to generate a solution to the original MAXCUT problem using the method from the paper:","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"Goemans, M. X., & Williamson, D. P. (1995). Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. Journal of the ACM (JACM), 42(6), 1115-1145.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"using JuMP\nimport LinearAlgebra\nimport Random\nimport SCS\nimport Test\n\nfunction solve_max_cut_sdp(num_vertex, weights)\n    # Calculate the (weighted) Lapacian of the graph: L = D - W.\n    laplacian = LinearAlgebra.diagm(0 => weights * ones(num_vertex)) - weights\n    # Solve the SDP relaxation\n    model = Model(SCS.Optimizer)\n    set_silent(model)\n    @variable(model, X[1:num_vertex, 1:num_vertex], PSD)\n    @objective(model, Max, 1 / 4 * LinearAlgebra.dot(laplacian, X))\n    @constraint(model, LinearAlgebra.diag(X) .== 1)\n    optimize!(model)\n    # Compute the Cholesky factorization of X, i.e., X = V^T V.\n    opt_X = LinearAlgebra.Hermitian(value.(X), :U)  # Tell Julia its PSD.\n    factorization = LinearAlgebra.cholesky(opt_X, Val(true); check = false)\n    V = (factorization.P * factorization.L)'\n    # Normalize columns.\n    for i in 1:num_vertex\n        V[:, i] ./= LinearAlgebra.norm(V[:, i])\n    end\n    # Generate random vector on unit sphere.\n    Random.seed!(num_vertex)\n    r = rand(num_vertex)\n    r /= LinearAlgebra.norm(r)\n    # Iterate over vertices, and assign each vertex to a side of cut.\n    cut = ones(num_vertex)\n    for i in 1:num_vertex\n        if LinearAlgebra.dot(r, V[:, i]) <= 0\n            cut[i] = -1\n        end\n    end\n\n    return cut, 0.25 * sum(laplacian .* (cut * cut'))\nend\n\nfunction example_max_cut_sdp()\n    #   [1] --- 5 --- [2]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1}, {2})\n    cut, cutval = solve_max_cut_sdp(2, [0.0 5.0; 5.0 0.0])\n    Test.@test cut[1] != cut[2]\n    #   [1] --- 5 --- [2]\n    #    |  \\          |\n    #    |    \\        |\n    #    7      6      1\n    #    |        \\    |\n    #    |          \\  |\n    #   [3] --- 1 --- [4]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1}, {2, 3, 4})\n    W = [0.0 5.0 7.0 6.0;\n         5.0 0.0 0.0 1.0;\n         7.0 0.0 0.0 1.0;\n         6.0 1.0 1.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] != cut[2]\n    Test.@test cut[2] == cut[3] == cut[4]\n    #   [1] --- 1 --- [2]\n    #    |             |\n    #    |             |\n    #    5             9\n    #    |             |\n    #    |             |\n    #   [3] --- 2 --- [4]\n    #\n    # Solution:\n    #  (S, S‚Ä≤)  = ({1, 4}, {2, 3})\n    W = [0.0 1.0 5.0 0.0;\n         1.0 0.0 0.0 9.0;\n         5.0 0.0 0.0 2.0;\n         0.0 9.0 2.0 0.0]\n    cut, cutval = solve_max_cut_sdp(4, W)\n    Test.@test cut[1] == cut[4]\n    Test.@test cut[2] == cut[3]\n    Test.@test cut[1] != cut[2]\n    return\nend\n\nexample_max_cut_sdp()","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"View this file on Github.","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"","category":"page"},{"location":"tutorials/Semidefinite programs/max_cut_sdp/","page":"SDP relaxations: max-cut","title":"SDP relaxations: max-cut","text":"This page was generated using Literate.jl.","category":"page"}]
}
