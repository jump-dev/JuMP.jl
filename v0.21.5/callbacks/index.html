<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Callbacks · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../"><img alt="JuMP logo" class="logo" src="../assets/logo.png"/></a><h1>JuMP</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation Guide</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li><a class="toctext" href="../objective/">Objective</a></li><li><a class="toctext" href="../constraints/">Constraints</a></li><li><a class="toctext" href="../containers/">Containers</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../solutions/">Query Solutions</a></li><li><a class="toctext" href="../nlp/">Nonlinear Modeling</a></li><li class="current"><a class="toctext" href="">Callbacks</a><ul class="internal"><li><a class="toctext" href="#Available-solvers-1">Available solvers</a></li><li><a class="toctext" href="#Information-that-can-be-queried-during-callbacks-1">Information that can be queried during callbacks</a></li><li><a class="toctext" href="#Lazy-constraints-1">Lazy constraints</a></li><li><a class="toctext" href="#User-cuts-1">User cuts</a></li><li><a class="toctext" href="#Heuristic-solutions-1">Heuristic solutions</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../style/">Style Guide</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../roadmap/">Development Roadmap</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Callbacks</a></li></ul><a class="edit-page" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/callbacks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Callbacks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Callbacks-1" id="Callbacks-1">Callbacks</a></h1><p>Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).</p><p>While historically this functionality has been limited to solver-specific interfaces, JuMP provides solver-independent support for three types of callbacks:</p><ol><li>lazy constraints</li><li>user-cuts</li><li>heuristic solutions</li></ol><h2><a class="nav-anchor" href="#Available-solvers-1" id="Available-solvers-1">Available solvers</a></h2><p>Callback support is limited to a few solvers. This includes <a href="https://github.com/JuliaOpt/CPLEX.jl">CPLEX</a>, <a href="https://github.com/JuliaOpt/GLPK.jl">GLPK</a>, and <a href="https://github.com/JuliaOpt/Gurobi.jl">Gurobi</a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>While JuMP provides a solver-independent way of accessing callbacks, you should not assume that you will see identical behavior when running the same code on different solvers. For example, some solvers may ignore user-cuts for various reasons, while other solvers may add every user-cut. Read the underlying solver's callback documentation to understand details specific to each solver.</p></div></div><h2><a class="nav-anchor" href="#Information-that-can-be-queried-during-callbacks-1" id="Information-that-can-be-queried-during-callbacks-1">Information that can be queried during callbacks</a></h2><p>In a callback, the only thing you may query is the primal value of the variables using <a href="#JuMP.callback_value"><code>callback_value</code></a>.</p><p>If you need any other information, use a solver-dependent callback instead.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>Solver-dependent callbacks are mostly un-documented. Using them will require you to read and understand the source-code of solver's Julia wrapper (i.e., the <code>Solver.jl</code> package).</p></div></div><h2><a class="nav-anchor" href="#Lazy-constraints-1" id="Lazy-constraints-1">Lazy constraints</a></h2><p>Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this <a href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post by Paul Rubin</a>.</p><p>A lazy constraint callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    x_val = callback_value(cb_data, x)
    if x_val &gt; 2 + 1e-6
        con = @build_constraint(x &lt;= 2)
        MOI.submit(model, MOI.LazyConstraint(cb_data), con)
    end
end
MOI.set(model, MOI.LazyConstraintCallback(), my_callback_function)</code></pre><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The lazy constraint callback <em>may</em> be called at fractional or integer nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> feasible primal solution.</p></div></div><h2><a class="nav-anchor" href="#User-cuts-1" id="User-cuts-1">User cuts</a></h2><p>User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned <a href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post</a>.</p><p>A user-cut callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10.5, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    x_val = callback_value(cb_data, x)
    con = @build_constraint(x &lt;= floor(x_val))
    MOI.submit(model, MOI.UserCut(cb_data), con)
end
MOI.set(model, MOI.UserCutCallback(), my_callback_function)</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Your user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions. If you add a cut that removes an integer solution, the solver may return an incorrect solution.</p></div></div><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The user-cut callback <em>may</em> be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> fractional primal solution.</p></div></div><h2><a class="nav-anchor" href="#Heuristic-solutions-1" id="Heuristic-solutions-1">Heuristic solutions</a></h2><p>Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap.</p><p>Some heuristics take integer solutions and explore their "local neighborhood" (e.g., flipping binary variables, fix some variables and solve a smaller MILP) and others take fractional solutions and attempt to round them in an intelligent way.</p><p>You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.</p><p>A heuristic solution callback can be set using the following syntax:</p><pre><code class="language-julia">model = Model(GLPK.Optimizer)
@variable(model, x &lt;= 10.5, Int)
@objective(model, Max, x)
function my_callback_function(cb_data)
    x_val = callback_value(cb_data, x)
    status = MOI.submit(
        model, MOI.HeuristicSolution(cb_data), [x], [floor(Int, x_val)]
    )
    println("I submitted a heuristic solution, and the status was: ", status)
end
MOI.set(model, MOI.HeuristicCallback(), my_callback_function)</code></pre><p>The third argument to <code>submit</code> should be a vector of JuMP variables, and the fourth argument should be a vector of values corresponding to each variable.</p><p><code>MOI.submit</code> returns an enum that depends on whether the solver accepted the solution. The possible return codes are:</p><ul><li><code>MOI.HEURISTIC_SOLUTION_ACCEPTED</code></li><li><code>MOI.HEURISTIC_SOLUTION_REJECTED</code></li><li><code>MOI.HEURISTIC_SOLUTION_UNKNOWN</code></li></ul><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Some solvers may accept partial solutions. Others require a feasible integer solution for every variable. If in doubt, provide a complete solution.</p></div></div><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The heuristic solution callback <em>may</em> be called at fractional nodes in the branch-and-bound tree. There is no guarantee that the callback is called at <em>every</em> fractional primal solution.</p></div></div><h2><a class="nav-anchor" href="#Reference-1" id="Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#JuMP.callback_value" id="JuMP.callback_value"><code>JuMP.callback_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">callback_value(cb_data, x::VariableRef)</code></pre><p>Return the primal solution of a variable inside a callback.</p><p><code>cb_data</code> is the argument to the callback function, and the type is dependent on the solver.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/a4dd2fbaee785a369cd873acdbcaaf7c4547525f/src/callbacks.jl#L11-L18" target="_blank">source</a><div><div><pre><code class="language-none">callback_value(cb_data, expr::Union{GenericAffExpr, GenericQuadExpr})</code></pre><p>Return the primal solution of an affine or quadratic expression inside a callback by getting the value for each variable appearing in the expression.</p><p><code>cb_data</code> is the argument to the callback function, and the type is dependent on the solver.</p></div></div><a class="source-link" href="https://github.com/jump-dev/JuMP.jl/blob/a4dd2fbaee785a369cd873acdbcaaf7c4547525f/src/callbacks.jl#L34-L42" target="_blank">source</a></section><footer><hr/><a class="previous" href="../nlp/"><span class="direction">Previous</span><span class="title">Nonlinear Modeling</span></a><a class="next" href="../style/"><span class="direction">Next</span><span class="title">Style Guide</span></a></footer></article></body></HTML>