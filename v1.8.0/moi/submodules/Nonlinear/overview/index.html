<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · JuMP</title><meta name="title" content="Overview · JuMP"/><meta property="og:title" content="Overview · JuMP"/><meta property="twitter:title" content="Overview · JuMP"/><meta name="description" content="Documentation for JuMP."/><meta property="og:description" content="Documentation for JuMP."/><meta property="twitter:description" content="Documentation for JuMP."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-44252521-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-44252521-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script><link href="../../../../assets/extra_styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img class="docs-light-only" src="../../../../assets/logo.svg" alt="JuMP logo"/><img class="docs-dark-only" src="../../../../assets/logo-dark.svg" alt="JuMP logo"/></a><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><input class="collapse-toggle" id="menuitem-1" type="checkbox"/><label class="tocitem" for="menuitem-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../">Introduction</a></li><li><a class="tocitem" href="../../../../should_i_use/">Should I use JuMP?</a></li><li><a class="tocitem" href="../../../../installation/">Installation Guide</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/getting_started/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_julia/">Getting started with Julia</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_JuMP/">Getting started with JuMP</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_sets_and_indexing/">Getting started with sets and indexing</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/getting_started_with_data_and_plotting/">Getting started with data and plotting</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/debugging/">Debugging</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/design_patterns_for_larger_models/">Design patterns for larger models</a></li><li><a class="tocitem" href="../../../../tutorials/getting_started/performance_tips/">Performance tips</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Linear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/linear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/linear/diet/">The diet problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/cannery/">The cannery problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/facility_location/">The facility location problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/factory_schedule/">The factory schedule example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/finance/">Financial modeling problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/geographic_clustering/">Geographical clustering</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi_objective_knapsack/">Multi-objective knapsack</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi_objective_examples/">Simple multi-objective examples</a></li><li><a class="tocitem" href="../../../../tutorials/linear/knapsack/">The knapsack problem example</a></li><li><a class="tocitem" href="../../../../tutorials/linear/multi/">The multi-commodity flow problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/n-queens/">N-Queens</a></li><li><a class="tocitem" href="../../../../tutorials/linear/lp_sensitivity/">Sensitivity analysis of a linear program</a></li><li><a class="tocitem" href="../../../../tutorials/linear/network_flows/">Network flow problems</a></li><li><a class="tocitem" href="../../../../tutorials/linear/sudoku/">Sudoku</a></li><li><a class="tocitem" href="../../../../tutorials/linear/transp/">The transportation problem</a></li><li><a class="tocitem" href="../../../../tutorials/linear/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../tutorials/linear/constraint_programming/">Constraint programming</a></li><li><a class="tocitem" href="../../../../tutorials/linear/mip_duality/">Computing the duals of a mixed-integer program</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Nonlinear programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/nonlinear/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/simple_examples/">Simple examples</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/portfolio/">Quadratic portfolio optimization</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/rocket_control/">Rocket Control</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/space_shuttle_reentry_trajectory/">Optimal control for a Space Shuttle reentry trajectory</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/user_defined_hessians/">User-defined Hessians</a></li><li><a class="tocitem" href="../../../../tutorials/nonlinear/querying_hessians/">Computing Hessians</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Conic programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/conic/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../tutorials/conic/start_values/">Primal and dual warm-starts</a></li><li><a class="tocitem" href="../../../../tutorials/conic/tips_and_tricks/">Tips and Tricks</a></li><li><a class="tocitem" href="../../../../tutorials/conic/logistic_regression/">Logistic regression</a></li><li><a class="tocitem" href="../../../../tutorials/conic/cluster/">K-means clustering via SDP</a></li><li><a class="tocitem" href="../../../../tutorials/conic/corr_sdp/">The correlation problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/experiment_design/">Experiment design</a></li><li><a class="tocitem" href="../../../../tutorials/conic/max_cut_sdp/">SDP relaxations: max-cut</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_distortion/">The minimum distortion problem</a></li><li><a class="tocitem" href="../../../../tutorials/conic/min_ellipse/">Minimal ellipses</a></li><li><a class="tocitem" href="../../../../tutorials/conic/ellipse_approx/">Ellipsoid approximation</a></li><li><a class="tocitem" href="../../../../tutorials/conic/robust_uncertainty/">Robust uncertainty sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/algorithms/benders_decomposition/">Benders decomposition</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/cutting_stock_column_generation/">Column generation</a></li><li><a class="tocitem" href="../../../../tutorials/algorithms/tsp_lazy_constraints/">Traveling Salesperson Problem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Applications</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../tutorials/applications/power_systems/">Power Systems</a></li><li><a class="tocitem" href="../../../../tutorials/applications/web_app/">Serving web apps</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../manual/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../manual/objective/">Objectives</a></li><li><a class="tocitem" href="../../../../manual/containers/">Containers</a></li><li><a class="tocitem" href="../../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../manual/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../manual/callbacks/">Solver-independent Callbacks</a></li><li><a class="tocitem" href="../../../../manual/complex/">Complex number support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../../reference/expressions/">Expressions</a></li><li><a class="tocitem" href="../../../../reference/objectives/">Objectives</a></li><li><a class="tocitem" href="../../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../../reference/containers/">Containers</a></li><li><a class="tocitem" href="../../../../reference/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../../reference/nlp/">Nonlinear Modeling</a></li><li><a class="tocitem" href="../../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../../reference/extensions/">Extensions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background Information</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../background/algebraic_modeling_languages/">Algebraic modeling languages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Docs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../developers/contributing/">Contributing</a></li><li><a class="tocitem" href="../../../../developers/extensions/">Extensions</a></li><li><a class="tocitem" href="../../../../developers/custom_solver_binaries/">Custom binaries</a></li><li><a class="tocitem" href="../../../../developers/style/">Style Guide</a></li><li><a class="tocitem" href="../../../../developers/roadmap/">Roadmap</a></li></ul></li><li><a class="tocitem" href="../../../../release_notes/">Release notes</a></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">MathOptInterface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../">Introduction</a></li><li><a class="tocitem" href="../../../background/motivation/">Motivation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/example/">Solving a problem using MathOptInterface</a></li><li><a class="tocitem" href="../../../tutorials/implementing/">Implementing a solver interface</a></li><li><a class="tocitem" href="../../../tutorials/mathprogbase/">Transitioning from MathProgBase</a></li><li><a class="tocitem" href="../../../tutorials/bridging_constraint/">Implementing a constraint bridge</a></li><li><a class="tocitem" href="../../../tutorials/manipulating_expressions/">Manipulating expressions</a></li><li><a class="tocitem" href="../../../tutorials/latency/">Latency</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/modification/">Problem modification</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/duality/">Duality</a></li><li><a class="tocitem" href="../../../background/infeasibility_certificates/">Infeasibility certificates</a></li><li><a class="tocitem" href="../../../background/naming_conventions/">Naming conventions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-6-1" type="checkbox"/><label class="tocitem" for="menuitem-8-6-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-2" type="checkbox"/><label class="tocitem" for="menuitem-8-6-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../Bridges/list_of_bridges/">List of bridges</a></li><li><a class="tocitem" href="../../Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-3" type="checkbox"/><label class="tocitem" for="menuitem-8-6-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-4" type="checkbox" checked/><label class="tocitem" for="menuitem-8-6-4"><span class="docs-label">Nonlinear</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Standard-form"><span>Standard form</span></a></li><li><a class="tocitem" href="#API-overview"><span>API overview</span></a></li><li><a class="tocitem" href="#Expression-graph-representation"><span>Expression-graph representation</span></a></li><li><a class="tocitem" href="#ReverseAD"><span>ReverseAD</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-5" type="checkbox"/><label class="tocitem" for="menuitem-8-6-5"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6-6"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li><li><a class="tocitem" href="../../Test/reference/">API Reference</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../release_notes/">Release notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">MathOptInterface</a></li><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Nonlinear</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jump-dev/JuMP.jl/blob/master/docs/src/moi/submodules/Nonlinear/overview.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nonlinear_developers"><a class="docs-heading-anchor" href="#nonlinear_developers">Nonlinear</a><a id="nonlinear_developers-1"></a><a class="docs-heading-anchor-permalink" href="#nonlinear_developers" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The Nonlinear submodule is experimental. Until this message is removed, breaking changes may be introduced in any minor or patch release of MathOptInterface.</p></div></div><p>The <code>Nonlinear</code> submodule contains data structures and functions for working with a nonlinear optimization problem in the form of an expression graph. This page explains the API and describes the rationale behind its design.</p><h2 id="Standard-form"><a class="docs-heading-anchor" href="#Standard-form">Standard form</a><a id="Standard-form-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-form" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Nonlinear_programming">Nonlinear programs (NLPs)</a> are a class of optimization problems in which some of the constraints or the objective function are nonlinear:</p><p class="math-container">\[\begin{align}
    \min_{x \in \mathbb{R}^n} &amp; f_0(x) \\
    \;\;\text{s.t.} &amp; l_j \le f_j(x) \le u_j &amp; j = 1 \ldots m
\end{align}\]</p><p>There may be additional constraints, as well as things like variable bounds and integrality restrictions, but we do not consider them here because they are best dealt with by other components of MathOptInterface.</p><h2 id="API-overview"><a class="docs-heading-anchor" href="#API-overview">API overview</a><a id="API-overview-1"></a><a class="docs-heading-anchor-permalink" href="#API-overview" title="Permalink"></a></h2><p>The core element of the <code>Nonlinear</code> submodule is <a href="../reference/#MathOptInterface.Nonlinear.Model"><code>Nonlinear.Model</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; const Nonlinear = MathOptInterface.Nonlinear;

julia&gt; model = Nonlinear.Model()
A Nonlinear.Model with:
 0 objectives
 0 parameters
 0 expressions
 0 constraints</code></pre><p><a href="../reference/#MathOptInterface.Nonlinear.Model"><code>Nonlinear.Model</code></a> is a mutable struct that stores all of the nonlinear information added to the model.</p><h3 id="Decision-variables"><a class="docs-heading-anchor" href="#Decision-variables">Decision variables</a><a id="Decision-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-variables" title="Permalink"></a></h3><p>Decision variables are represented by <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>es. The user is responsible for creating these using <code>MOI.VariableIndex(i)</code>, where <code>i</code> is the column associated with the variable.</p><h3 id="Nonlinear_Expressions"><a class="docs-heading-anchor" href="#Nonlinear_Expressions">Expressions</a><a id="Nonlinear_Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Expressions" title="Permalink"></a></h3><p>The input data structure is a Julia <code>Expr</code>. The input expressions can incorporate <a href="../../../reference/standard_form/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a>es, but these must be interpolated into the expression with <code>$</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = MOI.VariableIndex(1)
MathOptInterface.VariableIndex(1)

julia&gt; input = :(1 + sin($x)^2)
:(1 + sin(MathOptInterface.VariableIndex(1)) ^ 2)</code></pre><p>There are a number of restrictions on the input <code>Expr</code>:</p><ul><li>It cannot contain macros</li><li>It cannot contain broadcasting</li><li>It cannot contain splatting (except in limited situations)</li><li>It cannot contain linear algebra, such as matrix-vector products</li><li>It cannot contain generator expressions, including <code>sum(i for i in S)</code></li></ul><p>Given an input expression, add an expression using <a href="../reference/#MathOptInterface.Nonlinear.add_expression"><code>Nonlinear.add_expression</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = Nonlinear.add_expression(model, input)
MathOptInterface.Nonlinear.ExpressionIndex(1)</code></pre><p>The return value, <code>expr</code>, is a <a href="../reference/#MathOptInterface.Nonlinear.ExpressionIndex"><code>Nonlinear.ExpressionIndex</code></a> that can then be interpolated into other input expressions.</p><p>Looking  again at <code>model</code>, we see:</p><pre><code class="language-julia-repl hljs">julia&gt; model
A Nonlinear.Model with:
 0 objectives
 0 parameters
 1 expression
 0 constraints</code></pre><h3 id="Nonlinear_Parameters"><a class="docs-heading-anchor" href="#Nonlinear_Parameters">Parameters</a><a id="Nonlinear_Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Parameters" title="Permalink"></a></h3><p>In addition to constant literals like <code>1</code> or <code>1.23</code>, you can create parameters. Parameters are placeholders whose values can change before passing the expression to the solver. Create a parameter using <a href="../reference/#MathOptInterface.Nonlinear.add_parameter"><code>Nonlinear.add_parameter</code></a>, which accepts a default value:</p><pre><code class="language-julia-repl hljs">julia&gt; p = Nonlinear.add_parameter(model, 1.23)
MathOptInterface.Nonlinear.ParameterIndex(1)</code></pre><p>The return value, <code>p</code>, is a <a href="../reference/#MathOptInterface.Nonlinear.ParameterIndex"><code>Nonlinear.ParameterIndex</code></a> that can then be interpolated into other input expressions.</p><p>Looking  again at <code>model</code>, we see:</p><pre><code class="language-julia-repl hljs">julia&gt; model
A Nonlinear.Model with:
 0 objectives
 1 parameter
 1 expression
 0 constraints</code></pre><p>Update a parameter as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; model[p]
1.23

julia&gt; model[p] = 4.56
4.56

julia&gt; model[p]
4.56</code></pre><h3 id="Nonlinear_Objectives"><a class="docs-heading-anchor" href="#Nonlinear_Objectives">Objectives</a><a id="Nonlinear_Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Objectives" title="Permalink"></a></h3><p>Set a nonlinear objective using <a href="../reference/#MathOptInterface.Nonlinear.set_objective"><code>Nonlinear.set_objective</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_objective(model, :($p + $expr + $x))

julia&gt; model
A Nonlinear.Model with:
 1 objective
 1 parameter
 1 expression
 0 constraints</code></pre><p>Clear a nonlinear objective by passing <code>nothing</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_objective(model, nothing)

julia&gt; model
A Nonlinear.Model with:
 0 objectives
 1 parameter
 1 expression
 0 constraints</code></pre><p>But we&#39;ll re-add the objective for later:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.set_objective(model, :($p + $expr + $x));</code></pre><h3 id="Nonlinear_Constraints"><a class="docs-heading-anchor" href="#Nonlinear_Constraints">Constraints</a><a id="Nonlinear_Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_Constraints" title="Permalink"></a></h3><p>Add a constraint using <a href="../reference/#MathOptInterface.Nonlinear.add_constraint"><code>Nonlinear.add_constraint</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; c = Nonlinear.add_constraint(model, :(1 + sqrt($x)), MOI.LessThan(2.0))
MathOptInterface.Nonlinear.ConstraintIndex(1)

julia&gt; model
A Nonlinear.Model with:
 1 objective
 1 parameter
 1 expression
 1 constraint</code></pre><p>The return value, <code>c</code>, is a <a href="../reference/#MathOptInterface.Nonlinear.ConstraintIndex"><code>Nonlinear.ConstraintIndex</code></a> that is a unique identifier for the constraint. Interval constraints are also supported:</p><pre><code class="language-julia-repl hljs">julia&gt; c2 = Nonlinear.add_constraint(model, :(1 + sqrt($x)), MOI.Interval(-1.0, 2.0))
MathOptInterface.Nonlinear.ConstraintIndex(2)

julia&gt; model
A Nonlinear.Model with:
 1 objective
 1 parameter
 1 expression
 2 constraints</code></pre><p>Delete a constraint using <a href="../reference/#MathOptInterface.Nonlinear.delete"><code>Nonlinear.delete</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nonlinear.delete(model, c2)

julia&gt; model
A Nonlinear.Model with:
 1 objective
 1 parameter
 1 expression
 1 constraint</code></pre><h3 id="User-defined-operators"><a class="docs-heading-anchor" href="#User-defined-operators">User-defined operators</a><a id="User-defined-operators-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined-operators" title="Permalink"></a></h3><p>By default, <code>Nonlinear</code> supports a wide range of univariate and multivariate operators. However, you can also define your own operators by <em>registering</em> them.</p><h4 id="Univariate-operators"><a class="docs-heading-anchor" href="#Univariate-operators">Univariate operators</a><a id="Univariate-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-operators" title="Permalink"></a></h4><p>Register a univariate user-defined operator using <a href="../reference/#MathOptInterface.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = 1 + sin(x)^2
f (generic function with 1 method)

julia&gt; Nonlinear.register_operator(model, :my_f, 1, f)</code></pre><p>Now, you can use <code>:my_f</code> in expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; new_expr = Nonlinear.add_expression(model, :(my_f($x + 1)))
MathOptInterface.Nonlinear.ExpressionIndex(2)</code></pre><p>By default, <code>Nonlinear</code> will compute first- and second-derivatives of the registered operator using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. Override this by passing functions which compute the respective derivative:</p><pre><code class="language-julia-repl hljs">julia&gt; f′(x) = 2 * sin(x) * cos(x)
f′ (generic function with 1 method)

julia&gt; Nonlinear.register_operator(model, :my_f2, 1, f, f′)</code></pre><p>or</p><pre><code class="language-julia-repl hljs">julia&gt; f′′(x) = 2 * (cos(x)^2 - sin(x)^2)
f′′ (generic function with 1 method)

julia&gt; Nonlinear.register_operator(model, :my_f3, 1, f, f′, f′′)</code></pre><h4 id="Multivariate-operators"><a class="docs-heading-anchor" href="#Multivariate-operators">Multivariate operators</a><a id="Multivariate-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-operators" title="Permalink"></a></h4><p>Register a multivariate user-defined operator using <a href="../reference/#MathOptInterface.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; g(x...) = x[1]^2 + x[1] * x[2] + x[2]^2
g (generic function with 1 method)

julia&gt; Nonlinear.register_operator(model, :my_g, 2, g)</code></pre><p>Now, you can use <code>:my_g</code> in expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; new_expr = Nonlinear.add_expression(model, :(my_g($x + 1, $x)))
MathOptInterface.Nonlinear.ExpressionIndex(3)</code></pre><p>By default, <code>Nonlinear</code> will compute the gradient of the registered operator using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. (Hessian information is not supported.) Override this by passing a function to compute the gradient:</p><pre><code class="language-julia-repl hljs">julia&gt; function ∇g(ret, x...)
           ret[1] = 2 * x[1] + x[2]
           ret[2] = x[1] + 2 * x[2]
           return
       end
∇g (generic function with 1 method)

julia&gt; Nonlinear.register_operator(model, :my_g2, 2, g, ∇g)</code></pre><h3 id="Nonlinear_MOI_interface"><a class="docs-heading-anchor" href="#Nonlinear_MOI_interface">MathOptInterface</a><a id="Nonlinear_MOI_interface-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear_MOI_interface" title="Permalink"></a></h3><p>MathOptInterface communicates the nonlinear portion of an optimization problem to solvers using concrete subtypes of <a href="../../../reference/nonlinear/#MathOptInterface.AbstractNLPEvaluator"><code>AbstractNLPEvaluator</code></a>, which implement the <a href="../../../reference/nonlinear/#Nonlinear-programming">Nonlinear programming</a> API.</p><p>Create an <a href="../../../reference/nonlinear/#MathOptInterface.AbstractNLPEvaluator"><code>AbstractNLPEvaluator</code></a> from <a href="../reference/#MathOptInterface.Nonlinear.Model"><code>Nonlinear.Model</code></a> using <a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a>.</p><p><a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a> requires an <a href="../reference/#MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a> backend and an ordered list of the variables that are included in the model.</p><p>There following backends are available to choose from within MOI, although other packages may add more options by sub-typing <a href="../reference/#MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a>:</p><ul><li><a href="../reference/#MathOptInterface.Nonlinear.ExprGraphOnly"><code>Nonlinear.ExprGraphOnly</code></a></li><li><a href="../reference/#MathOptInterface.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; evaluator = Nonlinear.Evaluator(model, Nonlinear.ExprGraphOnly(), [x])
Nonlinear.Evaluator with available features:
  * :ExprGraph</code></pre><p>The functions of the <a href="../../../reference/nonlinear/#Nonlinear-programming">Nonlinear programming</a> API implemented by <a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a> depends upon the chosen <a href="../reference/#MathOptInterface.Nonlinear.AbstractAutomaticDifferentiation"><code>Nonlinear.AbstractAutomaticDifferentiation</code></a> backend.</p><p>The <code>:ExprGraph</code> feature means we can call <a href="../../../reference/nonlinear/#MathOptInterface.objective_expr"><code>objective_expr</code></a> and <a href="../../../reference/nonlinear/#MathOptInterface.constraint_expr"><code>constraint_expr</code></a> to retrieve the expression graph of the problem. However, we cannot call gradient terms such as <a href="../../../reference/nonlinear/#MathOptInterface.eval_objective_gradient"><code>eval_objective_gradient</code></a> because <a href="../reference/#MathOptInterface.Nonlinear.ExprGraphOnly"><code>Nonlinear.ExprGraphOnly</code></a> does not have the capability to differentiate a nonlinear expression.</p><p>If, instead, we pass <a href="../reference/#MathOptInterface.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a>, then we get access to <code>:Grad</code>, the gradient of the objective function, <code>:Jac</code>, the Jacobian matrix of the constraints, <code>:JacVec</code>, the ability to compute Jacobian-vector products, and <code>:ExprGraph</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; evaluator = Nonlinear.Evaluator(
           model,
           Nonlinear.SparseReverseMode(),
           [x],
       )
Nonlinear.Evaluator with available features:
  * :Grad
  * :Jac
  * :JacVec
  * :ExprGraph</code></pre><p>However, before using the evaluator, we need to call <a href="../../../reference/nonlinear/#MathOptInterface.initialize"><code>initialize</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; MOI.initialize(evaluator, [:Grad, :Jac, :JacVec, :ExprGraph])</code></pre><p>Now we can call methods like <a href="../../../reference/nonlinear/#MathOptInterface.eval_objective"><code>eval_objective</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = [1.0]
1-element Vector{Float64}:
 1.0

julia&gt; MOI.eval_objective(evaluator, x)
7.268073418273571</code></pre><p>and <a href="../../../reference/nonlinear/#MathOptInterface.eval_objective_gradient"><code>eval_objective_gradient</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; grad = [0.0]
1-element Vector{Float64}:
 0.0

julia&gt; MOI.eval_objective_gradient(evaluator, grad, x)

julia&gt; grad
1-element Vector{Float64}:
 1.909297426825682</code></pre><p>Instead of passing <a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a> directly to solvers, solvers query the <a href="../../../reference/nonlinear/#MathOptInterface.NLPBlock"><code>NLPBlock</code></a> attribute, which returns an <a href="../../../reference/nonlinear/#MathOptInterface.NLPBlockData"><code>NLPBlockData</code></a>. This object wraps an <a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a> and includes other information such as constraint bounds and whether the evaluator has a nonlinear objective. Create and set <a href="../../../reference/nonlinear/#MathOptInterface.NLPBlockData"><code>NLPBlockData</code></a> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; block = MOI.NLPBlockData(evaluator);

julia&gt; model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}());

julia&gt; MOI.set(model, MOI.NLPBlock(), block);</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Only call <a href="../../../reference/nonlinear/#MathOptInterface.NLPBlockData"><code>NLPBlockData</code></a> once you have finished modifying the problem in <code>model</code>.</p></div></div><p>Putting everything together, you can create a nonlinear optimization problem in MathOptInterface as follows:</p><pre><code class="language-julia hljs">import MathOptInterface
const MOI = MathOptInterface

function build_model(
    model::MOI.ModelLike;
    backend::MOI.Nonlinear.AbstractAutomaticDifferentiation,
)
    x = MOI.add_variable(model)
    y = MOI.add_variable(model)
    MOI.set(model, MOI.ObjectiveSense(), MOI.MIN_SENSE)
    nl_model = MOI.Nonlinear.Model()
    MOI.Nonlinear.set_objective(nl_model, :($x^2 + $y^2))
    evaluator = MOI.Nonlinear.Evaluator(nl_model, backend, [x, y])
    MOI.set(model, MOI.NLPBlock(), MOI.NLPBlockData(evaluator))
    return
end

# Replace `model` and `backend` with your optimizer and backend of choice.
model = MOI.Utilities.UniversalFallback(MOI.Utilities.Model{Float64}())
build_model(model; backend = MOI.Nonlinear.SparseReverseMode())</code></pre><h2 id="Expression-graph-representation"><a class="docs-heading-anchor" href="#Expression-graph-representation">Expression-graph representation</a><a id="Expression-graph-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-graph-representation" title="Permalink"></a></h2><p><a href="../reference/#MathOptInterface.Nonlinear.Model"><code>Nonlinear.Model</code></a> stores nonlinear expressions in <a href="../reference/#MathOptInterface.Nonlinear.Expression"><code>Nonlinear.Expression</code></a>s. This section explains the design of the expression graph data structure in <a href="../reference/#MathOptInterface.Nonlinear.Expression"><code>Nonlinear.Expression</code></a>.</p><p>Given a nonlinear function like <code>f(x) = sin(x)^2 + x</code>, a conceptual aid for thinking about the graph representation of the expression is to convert it into <a href="https://en.wikipedia.org/wiki/Polish_notation">Polish prefix notation</a>:</p><pre><code class="nohighlight hljs">f(x, y) = (+ (^ (sin x) 2) x)</code></pre><p>This format identifies each operator (function), as well as a list of arguments. Operators can be univariate, like <code>sin</code>, or multivariate, like <code>+</code>.</p><p>A common way of representing Polish prefix notation in code is as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; x = MOI.VariableIndex(1);

julia&gt; struct ExprNode
           op::Symbol
           children::Vector{Union{ExprNode,Float64,MOI.VariableIndex}}
       end

julia&gt; expr = ExprNode(:+, [ExprNode(:^, [ExprNode(:sin, [x]), 2.0]), x]);</code></pre><p>This data structure follows our Polish prefix notation very closely, and we can easily identify the arguments to an operator. However, it has a significant draw-back: each node in the graph requires a <code>Vector</code>, which is heap-allocated and tracked by Julia&#39;s garbage collector (GC). For large models, we can expect to have millions of nodes in the expression graph, so this overhead quickly becomes prohibitive for computation.</p><p>An alternative is to record the expression as a linear tape:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = Any[:+, 2, :^, 2, :sin, 1, x, 2.0, x]
9-element Vector{Any}:
  :+
 2
  :^
 2
  :sin
 1
  MathOptInterface.VariableIndex(1)
 2.0
  MathOptInterface.VariableIndex(1)</code></pre><p>The <code>Int</code> after each operator <code>Symbol</code> specifies the number of arguments.</p><p>This data-structure is a single vector, which resolves our problem with the GC, but each element is the abstract type, <code>Any</code>, and so any operations on it will lead to slower dynamic dispatch. It&#39;s also hard to identify the children of each operation without reading the entire tape.</p><p>To summarize, representing expression graphs in Julia has the following challenges:</p><ul><li>Nodes in the expression graph should not contain a heap-allocated object</li><li>All data-structures should be concretely typed</li><li>It should be easy to identify the children of a node</li></ul><h3 id="Sketch-of-the-design-in-Nonlinear"><a class="docs-heading-anchor" href="#Sketch-of-the-design-in-Nonlinear">Sketch of the design in Nonlinear</a><a id="Sketch-of-the-design-in-Nonlinear-1"></a><a class="docs-heading-anchor-permalink" href="#Sketch-of-the-design-in-Nonlinear" title="Permalink"></a></h3><p><code>Nonlinear</code> overcomes these problems by decomposing the data structure into a number of different concrete-typed vectors.</p><p>First, we create vectors of the supported uni- and multivariate operators.</p><pre><code class="language-julia-repl hljs">julia&gt; const UNIVARIATE_OPERATORS = [:sin];

julia&gt; const MULTIVARIATE_OPERATORS = [:+, :^];</code></pre><p>In practice, there are many more supported operations than the ones listed here.</p><p>Second, we create an enum to represent the different types of nodes present in the expression graph:</p><pre><code class="language-julia-repl hljs">julia&gt; @enum(
           NodeType,
           NODE_CALL_MULTIVARIATE,
           NODE_CALL_UNIVARIATE,
           NODE_VARIABLE,
           NODE_VALUE,
       )</code></pre><p>In practice, there are node types other than the ones listed here.</p><p>Third, we create two concretely-typed structs as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; struct Node
           type::NodeType
           parent::Int
           index::Int
       end

julia&gt; struct Expression
           nodes::Vector{Node}
           values::Vector{Float64}
       end</code></pre><p>For each node <code>node</code> in the <code>.nodes</code> field, if <code>node.type</code> is:</p><ul><li><code>NODE_CALL_MULTIVARIATE</code>, we look up <code>MULTIVARIATE_OPERATORS[node.index]</code> to retrieve the operator</li><li><code>NODE_CALL_UNIVARIATE</code>, we look up <code>UNIVARIATE_OPERATORS[node.index]</code> to retrieve the operator</li><li><code>NODE_VARIABLE</code>, we create <code>MOI.VariableIndex(node.index)</code></li><li><code>NODE_VALUE</code>, we look up <code>values[node.index]</code></li></ul><p>The <code>.parent</code> field of each node is the integer index of the parent node in <code>.nodes</code>. For the first node, the parent is <code>-1</code> by convention.</p><p>Therefore, we can represent our function as:</p><pre><code class="language-julia-repl hljs">julia&gt; expr = Expression(
           [
               Node(NODE_CALL_MULTIVARIATE, -1, 1),
               Node(NODE_CALL_MULTIVARIATE, 1, 2),
               Node(NODE_CALL_UNIVARIATE, 2, 1),
               Node(NODE_VARIABLE, 3, 1),
               Node(NODE_VALUE, 2, 1),
               Node(NODE_VARIABLE, 1, 1),
           ],
           [2.0],
       );</code></pre><p>This is less readable than the other options, but does this data structure meet our design goals?</p><p>Instead of a heap-allocated object for each node, we only have two <code>Vector</code>s for each expression, <code>nodes</code> and <code>values</code>, as well as two constant vectors for the <code>OPERATORS</code>. In addition, all fields are concretely typed, and there are no <code>Union</code> or <code>Any</code> types.</p><p>For our third goal, it is not easy to identify the children of a node, but it is easy to identify the <em>parent</em> of any node. Therefore, we can use <a href="../reference/#MathOptInterface.Nonlinear.adjacency_matrix"><code>Nonlinear.adjacency_matrix</code></a> to compute a sparse matrix that maps parents to their children.</p><p>The tape is also ordered topologically, so that a reverse pass of the nodes evaluates all children nodes before their parent.</p><h3 id="The-design-in-practice"><a class="docs-heading-anchor" href="#The-design-in-practice">The design in practice</a><a id="The-design-in-practice-1"></a><a class="docs-heading-anchor-permalink" href="#The-design-in-practice" title="Permalink"></a></h3><p>In practice, <code>Node</code> and <code>Expression</code> are exactly <a href="../reference/#MathOptInterface.Nonlinear.Node"><code>Nonlinear.Node</code></a> and <a href="../reference/#MathOptInterface.Nonlinear.Expression"><code>Nonlinear.Expression</code></a>. However, <a href="../reference/#MathOptInterface.Nonlinear.NodeType"><code>Nonlinear.NodeType</code></a> has more fields to account for comparison operators such as <code>:&gt;=</code> and <code>:&lt;=</code>, logic operators such as <code>:&amp;&amp;</code> and <code>:||</code>, nonlinear parameters, and nested subexpressions.</p><p>Moreover, instead of storing the operators as global constants, they are stored in <a href="../reference/#MathOptInterface.Nonlinear.OperatorRegistry"><code>Nonlinear.OperatorRegistry</code></a>, and it also stores a vector of logic operators and a vector of comparison operators. In addition to <a href="../reference/#MathOptInterface.Nonlinear.DEFAULT_UNIVARIATE_OPERATORS"><code>Nonlinear.DEFAULT_UNIVARIATE_OPERATORS</code></a> and <a href="../reference/#MathOptInterface.Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS"><code>Nonlinear.DEFAULT_MULTIVARIATE_OPERATORS</code></a>, you can register user-defined functions using <a href="../reference/#MathOptInterface.Nonlinear.register_operator"><code>Nonlinear.register_operator</code></a>.</p><p><a href="../reference/#MathOptInterface.Nonlinear.Model"><code>Nonlinear.Model</code></a> is a struct that stores the <a href="../reference/#MathOptInterface.Nonlinear.OperatorRegistry"><code>Nonlinear.OperatorRegistry</code></a>, as well as a list of parameters and subexpressions in the model.</p><h2 id="ReverseAD"><a class="docs-heading-anchor" href="#ReverseAD">ReverseAD</a><a id="ReverseAD-1"></a><a class="docs-heading-anchor-permalink" href="#ReverseAD" title="Permalink"></a></h2><p><code>Nonlinear.ReverseAD</code> is a submodule for computing derivatives of a nonlinear optimization problem using sparse reverse-mode automatic differentiation (AD).</p><p>This section does not attempt to explain how sparse reverse-mode AD works, but instead explains why MOI contains its own implementation, and highlights notable differences from similar packages.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Don&#39;t use the API in <code>ReverseAD</code> to compute derivatives. Instead, create a <a href="../reference/#MathOptInterface.Nonlinear.Evaluator"><code>Nonlinear.Evaluator</code></a> object with <a href="../reference/#MathOptInterface.Nonlinear.SparseReverseMode"><code>Nonlinear.SparseReverseMode</code></a> as the backend, and then query the MOI API methods.</p></div></div><h3 id="Design-goals"><a class="docs-heading-anchor" href="#Design-goals">Design goals</a><a id="Design-goals-1"></a><a class="docs-heading-anchor-permalink" href="#Design-goals" title="Permalink"></a></h3><p>The JuliaDiff organization maintains a <a href="https://juliadiff.org">list of packages</a> for doing AD in Julia. At last count, there were at least ten packages–-not including <code>ReverseAD</code>-–for reverse-mode AD in Julia. <code>ReverseAD</code> exists because it has a different set of design goals.</p><ul><li><strong>Goal: handle scale and sparsity.</strong> The types of nonlinear optimization problems that MOI represents can be large scale (10^5 or more functions across 10^5 or more variables) with very sparse derivatives. The ability to compute a sparse Hessian matrix is essential. To the best of our knowledge, <code>ReverseAD</code> is the only reverse-mode AD system in Julia that handles sparsity by default.</li><li><strong>Goal: limit the scope to improve robustness.</strong> Most other AD packages accept arbitrary Julia functions as input and then trace an expression graph using operator overloading. This means they must deal (or detect and ignore) with control flow, I/O, and other vagaries of Julia. In contrast, <code>ReverseAD</code> only accepts functions in the form of <a href="../reference/#MathOptInterface.Nonlinear.Expression"><code>Nonlinear.Expression</code></a>, which greatly limits the range of syntax that it must deal with. By reducing the scope of what we accept as input to functions relevant for mathematical optimization, we can provide a simpler implementation with various performance optimizations.</li><li><strong>Goal: provide outputs which match what solvers expect.</strong> Other AD packages focus on differentiating individual Julia functions. In contrast, <code>ReverseAD</code> has a very specific use-case: to generate outputs needed by the MOI nonlinear API. This means it needs to efficiently compute sparse Hessians, and it needs subexpression handling to avoid recomputing subexpressions that are shared between functions.</li></ul><h3 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h3><p><code>ReverseAD</code> started life as <a href="https://github.com/mlubin/ReverseDiffSparse.jl">ReverseDiffSparse.jl</a>, development of which began in early 2014(!). This was well before the other AD packages started development. Because we had a well-tested, working AD in JuMP, there was less motivation to contribute to and explore other AD packages. The lack of historical interaction also meant that other packages were not optimized for the types of problems that JuMP is built for (i.e., large-scale sparse problems). When we first created MathOptInterface, we kept the AD in JuMP to simplify the transition, and post-poned the development of a first-class nonlinear interface in MathOptInterface.</p><p>Prior to the introduction of <code>Nonlinear</code>, JuMP&#39;s nonlinear implementation was a confusing mix of functions and types spread across the code base and in the private <code>_Derivatives</code> submodule. This made it hard to swap the AD system for another. The main motivation for refactoring JuMP to create the <code>Nonlinear</code> submodule in MathOptInterface was to abstract the interface between JuMP and the AD system, allowing us to swap-in and test new AD systems in the future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../FileFormats/reference/">« API Reference</a><a class="docs-footer-nextpage" href="../reference/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Thursday 16 February 2023 02:21">Thursday 16 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
